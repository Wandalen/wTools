//! This example demonstrates using the `mod_interface!` macro
//! with the `layer` keyword to integrate a child module (`child.rs`)
//! and shows how to use the `#![ debug ]` directive to inspect
//! the code generated by the macro during compilation.

use mod_interface::mod_interface;

//

// This module is intentionally left empty in this example,
// as the focus is on integrating the `child` layer.
// A `mod private {}` is often required by `mod_interface!`
// as the default location for item definitions.
mod private {}

mod_interface! {
  // Uncomment the line below to enable debug output during compilation.
  // This will print the expanded code generated by `mod_interface!`
  // to the standard output, showing the resulting module structure
  // with its exposure levels (`own`, `orphan`, `exposed`, `prelude`).
  // #![ debug ]

  /// Child layer integration.
  /// Defines the `child` module in this file and integrates its interface.
  layer child;
}

//

fn main() {
  // Assert that the `inner_is` function from the child's prelude
  // is accessible both directly via the child module and
  // via the parent's propagated prelude.
  assert_eq!(prelude::inner_is(), child::prelude::inner_is());
  assert_eq!(child::inner_is(), true); // Also accessible directly in child's root
  assert_eq!(prelude::inner_is(), true); // Accessible via parent's prelude
}
