[package]
name = "unilang"
version = "0.44.0"
edition = "2021"
rust-version = "1.70"
authors = [
  "Kostiantyn Wandalen <wandalen@obox.systems>",
]
license = "MIT"
readme = "readme.md"
documentation = "https://docs.rs/unilang"
repository = "https://github.com/Wandalen/wTools/tree/master/module/core/unilang"
homepage = "https://github.com/Wandalen/wTools/tree/master/module/core/unilang/readme.md"
description = """
Define your command-line utility interface once and get consistent interaction across multiple modalities — CLI, GUI, TUI, AUI, Web APIs, and more—essentially for free.
"""
categories = [ "command-line-interface", "command-line-utilities" ]
keywords = [ "wtools", "CLI", "CUI", "user-interface" ]
# Note: stress_test_bin in tests/ causes a harmless warning about duplicate targets

[lints]
workspace = true

[package.metadata.docs.rs]
features = [ "full", "error_tools/enabled", "mod_interface/enabled", "former/enabled" ]
all-features = false

[features]
# ========================================
# Default Configuration (ONLY Approach #2)
# ========================================
# By default, ONLY multi-YAML build-time static approach is enabled.
# This is the recommended production approach for 95% of users.
# To use other approaches, explicitly enable their feature flags.

default = [ "enabled", "simd", "repl", "enhanced_repl", "approach_yaml_multi_build" ]

# ========================================
# Approach Features (User-Facing)
# ========================================
# Each approach is self-contained - just enable the one you want.
# Note: Approach #7 (Rust DSL builder) is always available as core API.

# Implemented approaches (8 features):
approach_yaml_single_build = [ "static_registry", "yaml_parser" ]              # #1: Single YAML → Build-time static
approach_yaml_multi_build = [ "static_registry", "yaml_parser", "multi_file" ] # #2: Multi-YAML → Build-time static (DEFAULT)
approach_yaml_runtime = [ "yaml_parser" ]                                       # #3: YAML → Runtime loading

approach_json_single_build = [ "static_registry", "json_parser" ]              # #4: Single JSON → Build-time static
approach_json_multi_build = [ "static_registry", "json_parser", "multi_file" ] # #5: Multi-JSON → Build-time static
approach_json_runtime = [ "json_parser" ]                                       # #6: JSON → Runtime loading

# Approach #7 (Rust DSL builder): NO FEATURE - Always available as core API

approach_rust_dsl_const = [ "static_registry" ]                                # #8: Rust DSL const fn → Static
approach_hybrid = [ "static_registry" ]                                         # #18: Hybrid (static + runtime)

# Future approaches (12 features):
approach_macro_declarative = [ "static_registry" ]                             # #9: Declarative macro → Static
approach_macro_proc = [ "static_registry" ]                                    # #10: Proc macro → Static

approach_toml_single_build = [ "static_registry", "toml_parser" ]              # #11: Single TOML → Build-time static
approach_toml_multi_build = [ "static_registry", "toml_parser", "multi_file" ] # #11+multi: Multi-TOML → Build-time static
approach_toml_runtime = [ "toml_parser" ]                                      # #12: TOML → Runtime loading

approach_ron_single_build = [ "static_registry", "ron_parser" ]                # #13: Single RON → Build-time static
approach_ron_multi_build = [ "static_registry", "ron_parser", "multi_file" ]   # #13+multi: Multi-RON → Build-time static
approach_ron_runtime = [ "ron_parser" ]                                        # #14: RON → Runtime loading

approach_protobuf = [ "static_registry", "protobuf_support" ]                  # #15: Protobuf → Build-time static
approach_graphql = [ "static_registry", "graphql_support" ]                    # #16: GraphQL → Build-time static
approach_openapi = [ "static_registry", "openapi_support" ]                    # #17: OpenAPI → Build-time static

approach_plugin = [ "static_registry", "plugin_system" ]                       # #19: Plugin system (.so/.dll)
approach_binary = [ "static_registry", "binary_serialization" ]                # #20: Binary serialization
approach_inline_literals = [ "static_registry", "const_parsing" ]              # #21: Inline YAML/JSON literals

# ========================================
# Infrastructure Features (Building Blocks)
# ========================================
# These are automatically enabled by approach features above.
# Advanced users can enable these directly for custom configurations.

static_registry = [ "dep:phf" ]              # Static command registry infrastructure
yaml_parser = [ "dep:serde_yaml" ]           # YAML parsing support (build-time + runtime)
json_parser = [ "dep:serde_json" ]           # JSON parsing support (build-time + runtime)
multi_file = [ "dep:walkdir" ]               # Multi-file auto-discovery (any format)

# Future infrastructure:
toml_parser = [ "dep:toml" ]                 # TOML parsing (future)
ron_parser = [ "dep:ron" ]                   # RON parsing (future)
protobuf_support = [ "dep:prost" ]           # Protobuf (future)
graphql_support = [ "dep:async-graphql" ]    # GraphQL (future)
openapi_support = [ "dep:utoipa" ]           # OpenAPI (future)
plugin_system = [ "dep:libloading" ]         # Dynamic library loading (future)
binary_serialization = [ "dep:bincode" ]     # Binary serialization (future)
const_parsing = [ ]                          # Const eval parsing (future)

# Output processing utilities (DEPRECATED in 0.31.0, will be removed in 0.32.0)
# Use cli_fmt::output directly instead
output_processing = [ "dep:cli_fmt", "dep:strs_tools" ]

# ========================================
# Convenience Features
# ========================================

# Full feature set (all implemented approaches):
full = [
  "enabled",
  "on_unknown_suggest",
  "simd",
  "repl",
  "enhanced_repl",
  "approach_yaml_single_build",
  "approach_yaml_multi_build",
  "approach_yaml_runtime",
  "approach_json_single_build",
  "approach_json_multi_build",
  "approach_json_runtime",
  "approach_rust_dsl_const",
  "approach_hybrid"
]

# All YAML approaches:
all_yaml_approaches = [
  "approach_yaml_single_build",
  "approach_yaml_multi_build",
  "approach_yaml_runtime"
]

# All JSON approaches:
all_json_approaches = [
  "approach_json_single_build",
  "approach_json_multi_build",
  "approach_json_runtime"
]

# All build-time static approaches:
all_static_approaches = [
  "approach_yaml_single_build",
  "approach_yaml_multi_build",
  "approach_json_single_build",
  "approach_json_multi_build",
  "approach_rust_dsl_const",
  "approach_hybrid"
]

# All runtime approaches:
all_runtime_approaches = [
  "approach_yaml_runtime",
  "approach_json_runtime"
]

# ========================================
# Core & Performance Features
# ========================================

enabled = []
# NOTE: Benchmark features removed - use unilang_benchmarks workspace crate instead
advanced_cli_tests = [ ]

# WebAssembly-compatible feature set - excludes platform-specific dependencies
wasm = [ "enabled" ]

# SIMD performance optimizations - enabled by default for maximum performance
simd = [ "simd-json", "memchr", "bytecount", "unilang_parser/simd" ]

# REPL (Read-Eval-Print Loop) support
repl = []
enhanced_repl = [ "repl", "dep:rustyline" ]

# Command suggestions when command is unknown
on_unknown_suggest = [ ]

[dependencies]
# Core dependencies (always compiled):
serde = { version = "1.0", features = ["derive"] }
url = "2.5.0"
chrono = { version = "0.4.38", features = ["serde"] }
regex = "1.10.4"

# Format parsers (optional, gated by infrastructure features):
serde_json = { version = "1.0", optional = true }      # Enabled by json_parser
serde_yaml = { version = "0.9", optional = true }      # Enabled by yaml_parser
toml = { version = "0.8", optional = true }            # Enabled by toml_parser (future)
ron = { version = "0.8", optional = true }             # Enabled by ron_parser (future)

# Static registry infrastructure (optional):
phf = { version = "0.11", features = ["macros"], optional = true }  # Enabled by static_registry

# Multi-file discovery (optional):
walkdir = { version = "2.4", optional = true }         # Enabled by multi_file

# Future dependencies (optional):
prost = { version = "0.12", optional = true }          # Enabled by protobuf_support (future)
async-graphql = { version = "7.0", optional = true }   # Enabled by graphql_support (future)
utoipa = { version = "4.0", optional = true }          # Enabled by openapi_support (future)
libloading = { version = "0.8", optional = true }      # Enabled by plugin_system (future)
bincode = { version = "1.3", optional = true }         # Enabled by binary_serialization (future)
sysinfo = { version = "0.30", optional = true }

## internal
error_tools = { workspace = true, features = [ "enabled", "error_typed", "error_untyped" ] }
mod_interface = { workspace = true, features = [ "enabled" ] }
former = { workspace = true, features = [ "enabled", "derive_former" ] }
unilang_parser = { workspace = true } # SIMD features controlled by main unilang features

## external
log = "0.4"
rustyline = { version = "14.0", optional = true } # Enhanced REPL with history and arrow keys
indexmap = "2.2.6"
lru = "0.12.3" # LRU cache for hot command optimization

# Performance optimization dependencies
simd-json = { version = "0.13", optional = true } # SIMD-optimized JSON parsing
memchr = { version = "2.7", optional = true } # SIMD-optimized byte searching (6x faster than std)
bytecount = { version = "0.6", optional = true } # SIMD byte counting and operations

# CLI output utilities (deprecated - use cli_fmt directly)
cli_fmt = { workspace = true, features = [ "output" ], optional = true }
strs_tools = { workspace = true, features = [ "ansi", "string_split", "std" ], optional = true }

# NOTE: Benchmark dependencies have been moved to unilang_benchmarks workspace crate
# to avoid polluting the production dependency tree

[[bin]]
name = "unilang_cli"
path = "src/bin/unilang_cli.rs"



# Benchmark binaries moved to standard directory structure per benchkit requirements



[[test]]
name = "command_loader_yaml_test"
path = "tests/inc/phase2/command_loader_yaml_test.rs"

[[test]]
name = "command_loader_json_test"
path = "tests/inc/phase2/command_loader_json_test.rs"
required-features = ["json_parser"]

[[test]]
name = "command_loader_build_time_test"
path = "tests/inc/phase2/command_loader_build_time_test.rs"
required-features = ["json_parser"]

[[test]]
name = "command_loader_error_test"
path = "tests/inc/phase2/command_loader_error_test.rs"
required-features = ["json_parser"]

[[test]]
name = "cli_integration_test"
path = "tests/inc/phase2/cli_integration_test.rs"

[[test]]
name = "command_validation_test"
path = "tests/inc/phase2/command_validation_test.rs"

[[test]]
name = "help_generation_test"
path = "tests/inc/phase2/help_generation_test.rs"

[[test]]
name = "rust_dsl_inline_closure_test"
path = "tests/inc/phase2/rust_dsl_inline_closure_test.rs"
required-features = ["json_parser"]

[[test]]
name = "static_const_constructor_test"
path = "tests/inc/phase2/static_const_constructor_test.rs"

[[test]]
name = "data_model_features_test"
path = "tests/inc/phase3/data_model_features_test.rs"

# Performance tests excluded from regular 'cargo test' - run manually if needed
# [[test]]
# name = "performance_stress_test"
# path = "tests/inc/phase4/performance_stress_test.rs"

# Criterion-based benchmarks for cargo bench (following benchkit standard directory compliance)
# [[bench]]
# name = "comprehensive_benchmark"
# path = "benches/comprehensive_framework_comparison.rs"
# harness = false

# [[bench]]
# name = "throughput_benchmark"
# path = "benches/throughput_benchmark.rs"
# harness = false

# [[bench]]
# name = "string_interning_benchmark"
# path = "benches/string_interning_benchmark.rs"
# harness = false

# [[bench]]
# name = "integrated_string_interning_benchmark"
# path = "benches/integrated_string_interning_benchmark.rs"
# harness = false

# [[bench]]
# name = "simd_json_benchmark"
# path = "benches/simd_json_benchmark.rs"
# harness = false

# [[bench]]
# name = "strs_tools_benchmark"
# path = "benches/strs_tools_benchmark.rs"
# harness = false

# [[bench]]
# name = "comparative_parsing_benchmark"
# path = "benches/comparative_parsing_benchmark.rs"
# harness = false

# [[bench]]
# name = "context_rich_documentation_demo"
# path = "benches/context_rich_documentation_demo.rs"
# harness = false

# [[bench]]
# name = "optimization_workflow_demo"
# path = "benches/optimization_workflow_demo.rs"
# harness = false

# [[bench]]
# name = "simd_tokenizer_benchmark"
# path = "benches/simd_tokenizer_benchmark.rs"
# harness = false

# [[bench]]
# name = "simple_json_perf_test"
# path = "benches/simple_json_perf_test.rs"
# harness = false

# [[bench]]
# name = "run_all_benchmarks"
# path = "benches/run_all_benchmarks.rs"
# harness = false

# [[bench]]
# name = "stress_test_bin"
# path = "benches/stress_test_bin.rs"
# harness = false

# [[bench]]
# name = "performance_stress_test"
# path = "benches/performance_stress_test.rs"
# harness = false

# [[bench]]
# name = "simd_json_performance_validation"
# path = "benches/simd_json_performance_validation.rs"
# harness = false

# Removed benchmark test entries for deleted files:
# - exponential_benchmark.rs (redundant with throughput)
# - framework_comparison.rs (2-way comparison removed)
# - parsing_benchmark_test.rs (rarely used)
# - clap_comparison_benchmark.rs (Clap-only testing removed)
# - true_exponential_benchmark.rs (redundant with comprehensive)



# stress_test_bin is a binary, not a test - no [[test]] entry needed

[[example]]
name = "help_conventions_demo"
path = "examples/18_help_conventions_demo.rs"

# Examples requiring JSON parser feature
[[example]]
name = "02_argument_types"
required-features = ["json_parser"]

[[example]]
name = "07_yaml_json_loading"
required-features = ["json_parser"]

[[example]]
name = "10_full_pipeline"
required-features = ["json_parser"]

[[example]]
name = "12_error_handling"
required-features = ["json_parser"]

[[example]]
name = "14_advanced_types_validation"
required-features = ["json_parser"]

[[example]]
name = "16_comprehensive_loader_demo"
required-features = ["json_parser"]




[build-dependencies]
# Core (always available):
serde = "1.0"
serde_yaml = "0.9"  # Always available for build.rs (only used when static_registry enabled)

# Build-time format parsers (optional, gated by infrastructure features):
serde_json = { version = "1.0", optional = true }     # Enabled by json_parser
toml = { version = "0.8", optional = true }           # Enabled by toml_parser (future)
ron = { version = "0.8", optional = true }            # Enabled by ron_parser (future)

# Static registry codegen (optional):
phf_codegen = { version = "0.11", optional = true }   # Enabled by static_registry

# Multi-file discovery (optional):
walkdir = { version = "2.4", optional = true }        # Enabled by multi_file

[dev-dependencies]
test_tools = { workspace = true, features = [ "full" ] }
assert_cmd = "2.0"
predicates = "2.1"
assert_fs = "1.0"
clap = "4.4"
pico-args = "0.5"
chrono = "0.4"
tempfile = "3.8"
walkdir = "2.4"  # For build-time test verification

criterion = "0.5"

[package.metadata.cargo-udeps.ignore]
normal = ["num_cpus", "sysinfo"]
build = ["phf_codegen"]
