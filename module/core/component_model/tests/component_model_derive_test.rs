//! Test file for ComponentModel derive macro
//!
//! ## Test Matrix: ComponentModel Derive Functionality
//!
//! ### Test Factors
//! - **Field Count**: One, Multiple
//! - **Field Types**: Basic (String, i32, bool)
//! - **Attributes**: None, Debug
//! - **Assignment Style**: Direct (assign), Fluent (impute)
//! - **Type Conflicts**: None, Conflicting types
//!
//! ### Test Combinations
//!
//! | ID    | Field Count | Field Types     | Attributes | Type Conflicts | Assignment Style | Expected Behavior |
//! |-------|-------------|----------------|------------|----------------|------------------|-------------------|
//! | TCM01 | Multiple    | Basic mixed     | None       | None           | Direct + Fluent  | Multiple Assign impls generated |
//! | TCM02 | Multiple    | Conflicting     | None       | String x2      | Direct           | Only unique types get impls |  
//! | TCM03 | Multiple    | Basic mixed     | None       | None           | Direct           | Sequential assignment works |
//! | TCM04 | Multiple    | Basic mixed     | Debug      | None           | Direct           | Debug output + assignment works |
//!

/// Test module alias for aggregating crate
#[allow(unused_imports)]
use component_model as the_module;
use the_module::Assign;

/// Tests ComponentModel derive with multiple basic field types using both direct and fluent assignment.
/// Test Combination: TCM01
#[test]
fn test_component_model_basic_derive()
{
  #[derive(Default, Debug, PartialEq)]
  #[derive(the_module::ComponentModel)]
  struct TestStruct
  {
    name: String,
    value: i32,
  }

  // Test that all traits are implemented
  let mut obj = TestStruct::default();
  
  // Should be able to use Assign trait
  Assign::assign(&mut obj, "test_name".to_string());
  Assign::assign(&mut obj, 42i32);
  
  assert_eq!(obj.name, "test_name");
  assert_eq!(obj.value, 42);
  
  // Should be able to use impute (fluent style)
  let obj2 = TestStruct::default()
    .impute("fluent_name".to_string())
    .impute(100i32);
    
  assert_eq!(obj2.name, "fluent_name");
  assert_eq!(obj2.value, 100);
}

/// Tests ComponentModel derive handles conflicting field types by generating only unique type implementations.
/// Test Combination: TCM02
#[test]
fn test_component_model_with_conflicting_types()
{
  #[derive(Default, Debug, PartialEq)]
  #[derive(the_module::ComponentModel)]
  struct ConflictStruct
  {
    first_string: String,
    second_string: String, // This should cause conflicts for String assignment
    number: i32,
  }

  let mut obj = ConflictStruct::default();
  
  // With conflicting types, assignment should still work but may be ambiguous
  // The macro should handle this by not generating conflicting implementations
  Assign::assign(&mut obj, 42i32);
  assert_eq!(obj.number, 42);
}

/// Tests ComponentModel derive with sequential direct assignment to multiple basic field types.
/// Test Combination: TCM03
#[test]
fn test_component_model_tuple_assignment()
{
  #[derive(Default, Debug, PartialEq)]
  #[derive(the_module::ComponentModel)]
  struct TupleStruct
  {
    name: String,
    value: i32,
    flag: bool,
  }

  // Should be able to create from tuple components if implemented
  // This test may fail initially until tuple support is added
  let mut obj = TupleStruct::default();
  Assign::assign(&mut obj, "tuple_name".to_string());
  Assign::assign(&mut obj, 123i32);
  Assign::<bool, _>::assign(&mut obj, true);
    
  assert_eq!(obj.name, "tuple_name");
  assert_eq!(obj.value, 123);
  assert_eq!(obj.flag, true);
}

/// Tests ComponentModel derive with debug attribute processing and direct assignment.  
/// Test Combination: TCM04
#[test]
fn test_component_model_with_attributes()
{
  #[derive(Default, Debug, PartialEq)]
  #[derive(the_module::ComponentModel)]
  #[debug]
  struct AttributedStruct
  {
    #[component(default = "default_value")]
    name: String,
    value: i32,
  }

  // Test that attributes are processed
  let obj = AttributedStruct::default();
  
  // For now, just test that the derive compiles with attributes
  // Actual attribute behavior will be implemented later
  let mut obj2 = obj;
  Assign::assign(&mut obj2, "new_name".to_string());
  Assign::assign(&mut obj2, 42i32);
  
  assert_eq!(obj2.name, "new_name");
  assert_eq!(obj2.value, 42);
}