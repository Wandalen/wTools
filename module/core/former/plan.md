# Project Plan: Refactor Enum Unit Variant Handling in `former`

### Goal
*   Refactor the implementation of `#[derive(Former)]` for **enum unit variants** within the `former_meta` crate.
*   This refactoring will focus on:
    1.  Intensively analyzing and integrating reusable components from the `macro_tools` crate into the enum unit variant handling logic (`former_meta/src/derive_former/former_enum/unit_variant_handler.rs`).
    2.  Analyzing the existing enum unit variant handling logic in `former_meta` to identify and potentially extract generalizable, well-tested utilities into the `macro_tools` crate.
*   The process will include proposing an initial detailed refactoring solution, critiquing it, and then implementing an improved version.
*   All changes must strictly adhere to `code/gen` instructions, Design Rules, and Codestyle Rules.

### Relevant Context
*   **Primary Crates for Modification:**
    *   `module/core/former_meta` (specifically `src/derive_former/former_enum/unit_variant_handler.rs` and potentially `src/derive_former/former_enum.rs`)
    *   `module/core/macro_tools` (for potential additions and modifications)
*   **Key `macro_tools` Files for Analysis (Full Analysis in Increment 1):**
    *   All files within `module/core/macro_tools/src/` including `attr.rs`, `attr_prop.rs`, `diag.rs`, `ident.rs`, `kw.rs`, `generic_params.rs`, `typ.rs`, `item.rs`, `name.rs`, `punctuated.rs`, `quantifier.rs`, `tokens.rs`, etc.
*   **Key `former_meta` Files for Analysis:**
    *   `module/core/former_meta/src/derive_former/former_enum/unit_variant_handler.rs`
    *   `module/core/former_meta/src/derive_former/former_enum.rs` (for context, dispatch, and `EnumVariantHandlerContext`)
    *   `module/core/former_meta/src/derive_former/field_attrs.rs`
    *   `module/core/former_meta/src/derive_former/struct_attrs.rs` (for `ItemAttributes` like `standalone_constructors`, `debug`)
*   **Key Documentation for Reference:**
    *   `module/core/former/Readme.md`
    *   `module/core/former/advanced.md`
    *   Existing `plan.md` files for "Expected Enum Former Behavior" rules.
*   **Workspace:** Yes, this is part of a Cargo workspace.
*   **Other Active Plans:** The refactoring plan for `former_meta` (`former_meta/plan.md`) should be considered, as changes here might affect its assumptions.

### Project Requirements
*   (This section should be cumulative. Assuming previous project requirements like Rust edition 2021, documentation for public APIs, etc., are still in effect. New project-level requirements identified will be added here.)
*   **Behavioral Equivalence:** Refactoring must not change the externally observable behavior or the generated code structure of the `Former` macro for enum unit variants, unless explicitly justified by a bug fix or alignment with documented "Expected Enum Former Behavior". Existing tests in the `former` crate for unit variants serve as the primary regression guard.
*   **`macro_tools` Generalization:** All new or modified code in `macro_tools` must be general-purpose, well-documented, and include unit tests. Utilities should not be overly specific to `former_meta`'s internal implementation details.
*   **Code Quality:** Code changes should demonstrably improve clarity, maintainability, and reduce redundancy in `unit_variant_handler.rs`.
*   **Error Reporting:** If `macro_tools` utilities are used for error handling, the quality (clarity, span accuracy) of compiler error messages generated by `former_meta` must be maintained or improved.
*   **Performance:** The refactoring should not introduce measurable performance regressions in macro expansion time. (Primarily a consideration for complex macros, but good to keep in mind).
*   **Rule Adherence:** All new and modified code must strictly adhere to the system prompt's Design Rules and Codestyle Rules, overriding existing styles in the repository if they conflict.
*   **Proc Macro Workflow:** While this is primarily a refactoring task, if any part of the core macro logic generation for unit variants is significantly altered (beyond just using helper functions), the principles of the "Proc Macro: Development Workflow" (e.g., clear separation of concerns, testability) should be respected.
*   **Verification Scope:** All `cargo` commands for verification (check, test, clippy) **must be scoped to individual packages** (e.g., `cargo test --package former_meta`) unless an increment explicitly plans for workspace-level integration testing as a final step.

### Expected Behavior Rules (Enum Unit Variants)
*   **Rule 1a (Unit + `#[scalar]`):** Generates `Enum::variant() -> Enum`. (Handled by: `unit_variant_handler.rs`)
*   **Rule 2a (Unit + `#[subform_scalar]`):** Error. (Checked in: `unit_variant_handler.rs`)
*   **Rule 3a (Unit + Default):** Generates `Enum::variant() -> Enum`. (Handled by: `unit_variant_handler.rs`)
*   **Rule 4a (`#[standalone_constructors]` on Enum):**
    *   For unit variants, generates top-level `fn variant_name() -> EnumName` (or `fn enum_name_variant_name() -> EnumName` depending on naming convention for standalone, to be confirmed from existing behavior). The name should be snake_case.

### Increments

*   [✅] **Increment 1: Analyze `macro_tools` for `former_meta` (Enum Unit Variants)**
    *   Target Crate(s): `macro_tools` (read-only), `former_meta` (analysis target)
    *   Pre-Analysis: The goal is to identify how `macro_tools` can simplify `former_meta`'s unit variant handling. This requires a thorough understanding of `macro_tools` capabilities and the current implementation in `former_meta/src/derive_former/former_enum/unit_variant_handler.rs`. The existing "Notes & Insights" section already provides some initial pointers (e.g., `ident_maybe_raw`, `syn_err!`, `generic_params::decompose`).
    *   Detailed Plan Step 1: Systematically review each module and public item in `module/core/macro_tools/src/`. This involves using `list_files` to get an accurate list of modules and then conceptually (or with `read_file` if needed for specific complex utilities) understanding their purpose.
    *   Detailed Plan Step 2: For each identified `macro_tools` utility, assess its direct applicability to simplifying or improving the logic in `module/core/former_meta/src/derive_former/former_enum/unit_variant_handler.rs` and its interaction with `module/core/former_meta/src/derive_former/former_enum.rs` (e.g., `EnumVariantHandlerContext`, attribute parsing). Consider:
        *   Attribute parsing (`attr.rs`, `attr_prop.rs`): For `#[scalar]`, `#[subform_scalar]` on variants, and `#[standalone_constructors]`, `#[debug]` on the enum.
        *   Identifier generation/manipulation (`ident.rs`, `name.rs`, `kw.rs`): For constructor names, handling raw identifiers.
        *   Generic parameter handling (`generic_params.rs`, `generic_args.rs`): For generic enums and their constructors.
        *   Error reporting (`diag.rs`): For `syn_err!`, `return_syn_err!`.
        *   Code quoting (`qt!`, `quote!`).
        *   Type analysis (`typ.rs`): If any type introspection is needed for unit variants (less likely for units).
    *   Detailed Plan Step 3: **Output (as a textual report in the AI's response, not a file):** Produce a detailed report mapping specific `macro_tools` utilities to concrete code sections or logic patterns in `unit_variant_handler.rs` and `former_enum.rs` (related to unit variants). For each mapping, explain the potential benefit (e.g., "Replace custom ident logic with `ident::ident_maybe_raw`", "Use `AttributePropertyOptionalSingletone` for `#[scalar]` flag"). This report will be the main deliverable of this increment.
    *   Crucial Design Rules: [Prioritize Reuse and Minimal Change], [Comments and Documentation].
    *   Relevant Behavior Rules: Rules 1a, 2a, 3a, 4a (to ensure proposed `macro_tools` usage aligns with expected outcomes).
    *   Verification Strategy: User reviews the detailed analysis report and mapping presented in the AI's response. No code changes, so no compilation or tests.
    *   Test Matrix: Not applicable for this analysis increment.
    *   Commit Message: `docs(former_meta): Analyze macro_tools for refactoring unit variant handling`

*   [⚫] **Increment 2: Analyze `former_meta` (Enum Unit Variants) for `macro_tools` Generalizations**
    *   Target Crate(s): `former_meta` (read-only), `macro_tools` (analysis target)
    *   Detailed Plan Step 1: Review `former_meta/src/derive_former/former_enum/unit_variant_handler.rs` and related logic in `former_meta/src/derive_former/former_enum.rs` (e.g., parts of `EnumVariantHandlerContext` or its setup if relevant to unit variants specifically and generalizable).
    *   Detailed Plan Step 2: Identify any custom logic, patterns, or helper functions used for unit variant handling that are sufficiently generic and could be beneficial to other procedural macro development if moved to `macro_tools`.
    *   Detailed Plan Step 3: **Output:** Document findings as a list of concrete proposals for new utilities or modifications for `macro_tools`. Each proposal must include:
        *   Proposed function/struct/trait signature.
        *   Target module within `macro_tools`.
        *   Clear description of its purpose and generic applicability.
        *   A brief example of how it would be used.
    *   Verification Strategy: User reviews the documented analysis and concrete proposals for `macro_tools`.
    *   Commit Message: `docs(macro_tools): Analyze former_meta unit variant logic for potential generalizations`

*   [⚫] **Increment 3: Propose Initial Detailed Refactoring Solution for Enum Unit Variants**
    *   Target Crate(s): `former_meta`, `macro_tools`
    *   Detailed Plan Step 1: Based on the analyses from Increments 1 and 2, draft a detailed initial refactoring plan for `former_meta/src/derive_former/former_enum/unit_variant_handler.rs`.
    *   Detailed Plan Step 2: **Output:** For `unit_variant_handler.rs`, provide:
        *   Conceptual "before-and-after" code snippets (or pseudo-code) demonstrating how `macro_tools` utilities will replace or augment existing logic.
        *   Clear explanation of changes to data flow or helper function usage.
    *   Detailed Plan Step 3: **Output:** For `macro_tools`, provide:
        *   Finalized signatures and intended module placement for any new utilities proposed in Increment 2.
    *   Detailed Plan Step 4: Outline the expected impact on code size, readability, and maintainability in `unit_variant_handler.rs`.
    *   Detailed Plan Step 5: Briefly assess if this refactoring impacts the `former_meta/plan.md` for splitting large files (e.g., if `unit_variant_handler.rs` becomes trivial, does it still need to be a separate file?).
    *   Verification Strategy: User reviews the detailed refactoring solution, including code change proposals and `macro_tools` additions.
    *   Commit Message: `docs(former_meta): Propose initial detailed refactoring for unit variant handling`

*   [⚫] **Increment 4: Critique and Improve Refactoring Solution**
    *   Target Crate(s): `former_meta`, `macro_tools`
    *   Input: The detailed refactoring solution from Increment 3.
    *   Detailed Plan Step 1: Perform a self-critique of the *detailed* initial refactoring solution. Consider:
        *   **Effectiveness & Simplification:** Does the plan significantly leverage `macro_tools`? Does it genuinely simplify `unit_variant_handler.rs` logic? Are the `macro_tools` usages idiomatic and clear?
        *   **Generalization Quality:** Are the proposed additions to `macro_tools` truly generic, well-justified, and do they have clean APIs?
        *   **Complexity Trade-offs:** Does the refactoring introduce unnecessary complexity or layers of abstraction for the problem at hand?
        *   **Rule Adherence & Correctness:** Does the plan fully align with "Expected Enum Former Behavior" for unit variants and all project/codestyle rules? Are there any edge cases missed?
        *   **Maintainability Impact:** Will the refactored code be demonstrably easier to understand, test, and maintain?
    *   Detailed Plan Step 2: **Output:** Based on the critique, propose specific, actionable improvements or alternatives to the refactoring plan. This might involve choosing different `macro_tools` utilities, refining proposed generalizations (APIs, scope), or adjusting the implementation strategy for `unit_variant_handler.rs`.
    *   Verification Strategy: User reviews the critique and the improved refactoring solution.
    *   Commit Message: `docs(former_meta): Critique and improve refactoring plan for unit variants`

*   [⚫] **Increment 5: Implement Improved Refactoring (Enum Unit Variants in `former_meta`)**
    *   Target Crate(s): `former_meta`
    *   Pre-Analysis: Review the approved improved refactoring solution from Increment 4. Confirm the exact `macro_tools` utilities to be used (assuming they exist or will be implemented in Increment 6).
    *   Detailed Plan Step 1: Modify `former_meta/src/derive_former/former_enum/unit_variant_handler.rs` according to the approved plan, integrating `macro_tools` utilities.
    *   Detailed Plan Step 2: Ensure all existing tests in `former` crate for enum unit variants continue to pass with identical behavior (unless a bug fix was part of the approved plan).
    *   Crucial Design Rules: [Prioritize Reuse and Minimal Change], [Proc Macro: Development Workflow].
    *   Relevant Behavior Rules: Rules 1a, 2a, 3a, 4a.
    *   Verification Strategy: User applies changes. `cargo check --package former_meta` must pass. `cargo test --package former --test tests -- inc::enum_unit_tests` (or more specific unit variant tests) must pass. Review diffs to ensure changes align with the plan and no unintended behavior changes occurred.
    *   Commit Message: `refactor(former_meta): Improve unit variant handling using macro_tools`

*   [⚫] **Increment 6: Implement Generalizations (New Utilities in `macro_tools`)**
    *   Target Crate(s): `macro_tools`
    *   Pre-Analysis: Review the approved new utilities for `macro_tools` from Increment 4.
    *   Detailed Plan Step 1: Implement the new general-purpose utilities in the appropriate modules within `macro_tools/src/`.
    *   Detailed Plan Step 2: Add comprehensive unit tests for these new utilities within `macro_tools/tests/inc/`. Each new public function/method should have corresponding tests.
    *   Detailed Plan Step 3: Update `macro_tools/src/lib.rs` and relevant module files (`mod.rs`) to correctly export the new utilities under the appropriate namespaces (`own`, `orphan`, `exposed`, `prelude`).
    *   Detailed Plan Step 4: Add clear ///doc comments for all new public items in `macro_tools`.
    *   Crucial Design Rules: [Traits: Encourage Modular Design], [Visibility: Keep Implementation Details Private], [Comments and Documentation].
    *   Verification Strategy: User applies changes. `cargo test --package macro_tools` must pass. `cargo doc --package macro_tools --no-deps` should build successfully.
    *   Commit Message: `feat(macro_tools): Add new utilities generalized from former_meta enum handling`

*   [⚫] **Increment 7: Final Verification and Documentation Update**
    *   Target Crate(s): `former_meta`, `macro_tools`, `former`
    *   Detailed Plan Step 1: Run `cargo clippy --package former_meta --all-targets -- -D warnings` and address any new lints.
    *   Detailed Plan Step 2: Run `cargo clippy --package macro_tools --all-targets -- -D warnings` and address any new lints.
    *   Detailed Plan Step 3: Run `cargo test --package former_meta` and `cargo test --package macro_tools`.
    *   Detailed Plan Step 4: Run `cargo test --package former --test tests -- inc::enum_unit_tests` (and any other directly affected test suites) to ensure no regressions.
    *   Detailed Plan Step 5: Update any relevant internal documentation or comments in `former_meta` (especially `unit_variant_handler.rs`) and `macro_tools` to reflect the refactoring and new utilities.
    *   Detailed Plan Step 6: Review if the `former_meta/plan.md` (for splitting large files) needs adjustment based on changes to `unit_variant_handler.rs` or `former_enum.rs`. Propose updates if necessary.
    *   Verification Strategy: User confirms all checks pass and reviews documentation updates and any proposed changes to other plans.
    *   Commit Message: `chore(former): Final verification and docs update after unit variant refactor`

### Requirements (Task-Specific)
*   The refactoring should prioritize clarity, maintainability, and testability of `unit_variant_handler.rs`.
*   Any utilities moved to or created in `macro_tools` must be genuinely reusable, well-documented with examples (if applicable for complex utilities), and not overly specific to `former_meta`'s internal logic.
*   The "Expected Enum Former Behavior" for unit variants must be strictly preserved or corrected if bugs are found and approved as part of the plan.
*   Naming conventions for standalone constructors (e.g., `variant_name()` vs `enum_name_variant_name()`) should be consistent with the established patterns in `former_meta` or clarified if ambiguous.
*   Consider the impact on generic enums: ensure refactoring correctly handles generics in unit variant constructors (both static and standalone).

### Notes & Insights
*   (This section will be populated as the plan progresses)
*   `unit_variant_handler.rs` currently handles `#[scalar]` (which is the default behavior for unit variants) and correctly errors on `#[subform_scalar]`. It also needs to interact with the enum-level `#[standalone_constructors]` attribute (parsed in `struct_attrs.rs` and available in `EnumVariantHandlerContext`).
*   The primary logic in `unit_variant_handler.rs` involves generating a simple static method and, if `#[standalone_constructors]` is present, a corresponding standalone function. Both typically construct the enum variant directly (e.g., `EnumName::VariantName`).
*   `macro_tools::ident::ident_maybe_raw` will be useful for generating constructor names from variant idents, especially if variants use raw identifiers (e.g., `r#fn`).
*   `macro_tools::diag::syn_err!` and `return_syn_err!` are already suitable for error reporting (e.g., for `#[subform_scalar]` on a unit variant).
*   `macro_tools::generic_params::decompose` and related functions will be crucial if the enum is generic, to correctly propagate generics to standalone constructors.
*   The `EnumVariantHandlerContext` provides necessary context like `vis`, `generics`, `enum_name`, `variant_ident`, and `struct_attrs`. The refactoring should leverage this context effectively.
