warning: unused variable: `struct_generics_ty_without_lifetimes`
   --> module/core/former_meta/src/derive_former/former_struct.rs:133:7
    |
133 |   let struct_generics_ty_without_lifetimes = generic_params::filter_params(
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_struct_generics_ty_without_lifetimes`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `former_perform_generics_impl`
   --> module/core/former_meta/src/derive_former/former_struct.rs:237:5
    |
237 |     former_perform_generics_impl,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_former_perform_generics_impl`

warning: unused variable: `former_perform_generics_ty`
   --> module/core/former_meta/src/derive_former/former_struct.rs:238:5
    |
238 |     former_perform_generics_ty,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_former_perform_generics_ty`

warning: unused variable: `former_perform_generics_ty_clean`
   --> module/core/former_meta/src/derive_former/former_struct.rs:243:7
    |
243 |   let former_perform_generics_ty_clean = quote! { Definition };
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_former_perform_generics_ty_clean`

warning: `former_meta` (lib) generated 4 warnings
   Compiling former v2.19.0 (/home/user1/pro/lib/wTools/module/core/former)
Struct: Struct1
has_only_lifetimes: false
classification: GenericsClassification { lifetimes: [], types: [], consts: [], has_only_lifetimes: false, has_only_types: false, has_only_consts: false, has_mixed: false, is_empty: true }

 = context

  derive : Former
  struct : Struct1

 = original

  #[debug] pub struct Struct1
  {
      #[subform_collection(definition = former::VectorDefinition)] vec_1:
      Vec<String>, #[subform_collection(definition = former::HashMapDefinition)]
      hashmap_1: collection_tools::HashMap<String, String>,
      #[subform_collection(definition = former::HashSetDefinition)] hashset_1:
      collection_tools::HashSet<String>,
  }

 = generated

  #[automatically_derived] impl Struct1
  {
      #[doc =
      r" Provides a mechanism to initiate the formation process with a default completion behavior."]
      #[inline(always)] pub fn former() -> Struct1Former <
      Struct1FormerDefinition < (), Struct1, former :: ReturnPreformed > >
      { Struct1Former :: begin(None, None, former :: ReturnPreformed) }
  } impl < Definition > former :: EntityToFormer < Definition > for Struct1
  where Definition : former :: FormerDefinition < Storage = Struct1FormerStorage
  > , { type Former = Struct1Former < Definition > ; } impl former ::
  EntityToStorage for Struct1 { type Storage = Struct1FormerStorage; } impl <
  __Context, __Formed, __End > former :: EntityToDefinition < __Context,
  __Formed, __End > for Struct1 where __End : former :: FormingEnd <
  Struct1FormerDefinitionTypes < __Context, __Formed > > ,
  {
      type Definition = Struct1FormerDefinition < __Context, __Formed, __End > ;
      type Types = Struct1FormerDefinitionTypes < __Context, __Formed > ;
  } impl < __Context, __Formed > former :: EntityToDefinitionTypes < __Context,
  __Formed > for Struct1
  { type Types = Struct1FormerDefinitionTypes < __Context, __Formed > ; }
  #[doc =
  r" Defines the generic parameters for formation behavior including context, form, and end conditions."]
  #[derive(Debug)] pub struct Struct1FormerDefinitionTypes < __Context = (),
  __Formed = Struct1, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (* const __Context, * const __Formed) > ,
  } impl < __Context, __Formed > :: core :: default :: Default for
  Struct1FormerDefinitionTypes < __Context, __Formed >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < __Context, __Formed > former :: FormerDefinitionTypes for
  Struct1FormerDefinitionTypes < __Context, __Formed >
  {
      type Storage = Struct1FormerStorage; type Formed = __Formed; type Context
      = __Context;
  } impl < __Context, __Formed > former :: FormerMutator for
  Struct1FormerDefinitionTypes < __Context, __Formed > where {}
  #[doc = r" Holds the definition types used during the formation process."]
  #[derive(Debug)] pub struct Struct1FormerDefinition < __Context = (), __Formed
  = Struct1, __End = former :: ReturnPreformed, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (* const __Context, * const __Formed, * const __End) > ,
  } impl < __Context, __Formed, __End > :: core :: default :: Default for
  Struct1FormerDefinition < __Context, __Formed, __End >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < __Context, __Formed, __End > former :: FormerDefinition for
  Struct1FormerDefinition < __Context, __Formed, __End > where __End : former ::
  FormingEnd < Struct1FormerDefinitionTypes < __Context, __Formed > >
  {
      type Types = Struct1FormerDefinitionTypes < __Context, __Formed > ; type
      End = __End; type Storage = Struct1FormerStorage; type Formed = __Formed;
      type Context = __Context;
  } #[doc = "Stores potential values for fields during the formation process."]
  #[allow(explicit_outlives_requirements)] pub struct Struct1FormerStorage < >
  {
      #[doc = r" A field"] pub vec_1 : :: core :: option :: Option < Vec <
      String > > , #[doc = r" A field"] pub hashmap_1 : :: core :: option ::
      Option < collection_tools :: HashMap < String, String > > ,
      #[doc = r" A field"] pub hashset_1 : :: core :: option :: Option <
      collection_tools :: HashSet < String > > ,
  } impl :: core :: default :: Default for Struct1FormerStorage
  {
      #[inline(always)] fn default() -> Self
      {
          Self
          {
              vec_1 : :: core :: option :: Option :: None, hashmap_1 : :: core
              :: option :: Option :: None, hashset_1 : :: core :: option ::
              Option :: None,
          }
      }
  } impl former :: Storage for Struct1FormerStorage
  { type Preformed = Struct1; } impl former :: StoragePreform for
  Struct1FormerStorage
  {
      fn preform(mut self) -> Self :: Preformed
      {
          let vec_1 = if self.vec_1.is_some() { self.vec_1.take().unwrap() }
          else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'vec_1' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData < Vec < String
                  > > = :: core :: marker :: PhantomData;
                  (& phantom).maybe_default()
              }
          }; let hashmap_1 = if self.hashmap_1.is_some()
          { self.hashmap_1.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'hashmap_1' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData <
                  collection_tools :: HashMap < String, String > > = :: core ::
                  marker :: PhantomData; (& phantom).maybe_default()
              }
          }; let hashset_1 = if self.hashset_1.is_some()
          { self.hashset_1.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'hashset_1' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData <
                  collection_tools :: HashSet < String > > = :: core :: marker
                  :: PhantomData; (& phantom).maybe_default()
              }
          }; let result = Struct1 { vec_1, hashmap_1, hashset_1, }; return
          result;
      }
  }
  #[doc =
  "\nStructure to form [Struct1]. Represents a forming entity designed to construct objects through a builder pattern.\n\nThis structure holds temporary storage and context during the formation process and\nutilizes a defined end strategy to finalize the object creation.\n"]
  pub struct Struct1Former < Definition = Struct1FormerDefinition < (), Struct1,
  former :: ReturnPreformed > , > where Definition : former :: FormerDefinition
  < Storage = Struct1FormerStorage > , Definition :: Types : former ::
  FormerDefinitionTypes < Storage = Struct1FormerStorage > ,
  {
      #[doc =
      r" Temporary storage for all fields during the formation process."] pub
      storage : Definition :: Storage, #[doc = r" Optional context."] pub
      context : :: core :: option :: Option < Definition :: Context > ,
      #[doc = r" Optional handler for the end of formation."] pub on_end : ::
      core :: option :: Option < Definition :: End > ,
  } #[automatically_derived] impl < Definition > Struct1Former < Definition >
  where Definition : former :: FormerDefinition < Storage = Struct1FormerStorage
  > , Definition :: Types : former :: FormerDefinitionTypes < Storage =
  Struct1FormerStorage > ,
  {
      #[doc =
      r" Initializes a former with an end condition and default storage."]
      #[inline(always)] pub fn new(on_end : Definition :: End) -> Self
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, on_end)
      } #[doc = r" Initializes a former with a coercible end condition."]
      #[inline(always)] pub fn new_coercing < IntoEnd > (end : IntoEnd) -> Self
      where IntoEnd : :: core :: convert :: Into < Definition :: End > ,
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, end,)
      }
      #[doc =
      r" Begins the formation process with specified context and termination logic."]
      #[inline(always)] pub fn
      begin(mut storage : :: core :: option :: Option < Definition :: Storage >
      , context : :: core :: option :: Option < Definition :: Context > , on_end
      : < Definition as former :: FormerDefinition > :: End,) -> Self
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option :: Some(on_end),
          }
      }
      #[doc =
      r" Starts the formation process with coercible end condition and optional initial values."]
      #[inline(always)] pub fn begin_coercing < IntoEnd >
      (mut storage : :: core :: option :: Option < Definition :: Storage > ,
      context : :: core :: option :: Option < Definition :: Context > , on_end :
      IntoEnd,) -> Self where IntoEnd : :: core :: convert :: Into < <
      Definition as former :: FormerDefinition > :: End > ,
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option ::
              Some(:: core :: convert :: Into :: into(on_end)),
          }
      }
      #[doc =
      r" Wrapper for `end` to align with common builder pattern terminologies."]
      #[inline(always)] pub fn form(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed { self.end() }
      #[doc = r" Completes the formation and returns the formed object."]
      #[inline(always)] pub fn end(mut self) -> < Definition :: Types as former
      :: FormerDefinitionTypes > :: Formed
      {
          let on_end = self.on_end.take().unwrap(); let mut context =
          self.context.take(); < Definition :: Types as former :: FormerMutator
          > :: form_mutation(& mut self.storage, & mut context); former ::
          FormingEnd :: < Definition :: Types > ::
          call(& on_end, self.storage, context)
      }
      #[doc =
      "Collection setter for the 'vec_1' field. Method _vec_1_subform_collection unlike method vec_1 accept custom collection subformer."]
      #[inline(always)] pub fn _vec_1_subform_collection < 'a, Former2 > (self)
      -> Former2 where Former2 : former :: FormerBegin < 'a, former ::
      VectorDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionVec1End < Definition > > > , former
      :: VectorDefinition < String, Struct1Former < Definition > , Struct1Former
      < Definition > , Struct1SubformCollectionVec1End < Definition > > : former
      :: FormerDefinition < Storage = Vec < String > , Context = Struct1Former <
      Definition > , End = Struct1SubformCollectionVec1End < Definition > , > ,
      < former :: VectorDefinition < String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionVec1End <
      Definition > > as former :: FormerDefinition > :: Storage : 'a, < former
      :: VectorDefinition < String, Struct1Former < Definition > , Struct1Former
      < Definition > , Struct1SubformCollectionVec1End < Definition > > as
      former :: FormerDefinition > :: Context : 'a, < former :: VectorDefinition
      < String, Struct1Former < Definition > , Struct1Former < Definition > ,
      Struct1SubformCollectionVec1End < Definition > > as former ::
      FormerDefinition > :: End : 'a, Definition : 'a,
      {
          Former2 ::
          former_begin(:: core :: option :: Option :: None, :: core :: option ::
          Option :: Some(self), Struct1SubformCollectionVec1End :: < Definition
          > :: default(),)
      }
      #[doc =
      "Collection setter for the 'vec_1' field. Method _vec_1_subform_collection unlike method vec_1 accept custom collection subformer."]
      #[inline(always)] pub fn vec_1(self) -> former :: CollectionFormer :: < <
      Vec < String > as former :: Collection > :: Entry, former ::
      VectorDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionVec1End < Definition > > , > where
      former :: VectorDefinition < String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionVec1End <
      Definition > > : former :: FormerDefinition < Storage = Vec < String > ,
      Context = Struct1Former < Definition > , End =
      Struct1SubformCollectionVec1End < Definition > , > ,
      {
          self._vec_1_subform_collection :: < former :: CollectionFormer < _, _
          > > ()
      }
      #[doc =
      "Collection setter for the 'hashmap_1' field. Method _hashmap_1_subform_collection unlike method hashmap_1 accept custom collection subformer."]
      #[inline(always)] pub fn _hashmap_1_subform_collection < 'a, Former2 >
      (self) -> Former2 where Former2 : former :: FormerBegin < 'a, former ::
      HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > > , former :: HashMapDefinition < String, String,
      Struct1Former < Definition > , Struct1Former < Definition > ,
      Struct1SubformCollectionHashmap1End < Definition > > : former ::
      FormerDefinition < Storage = collection_tools :: HashMap < String, String
      > , Context = Struct1Former < Definition > , End =
      Struct1SubformCollectionHashmap1End < Definition > , > , < former ::
      HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > as former :: FormerDefinition > :: Storage : 'a, < former
      :: HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > as former :: FormerDefinition > :: Context : 'a, < former
      :: HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > as former :: FormerDefinition > :: End : 'a, Definition :
      'a,
      {
          Former2 ::
          former_begin(:: core :: option :: Option :: None, :: core :: option ::
          Option :: Some(self), Struct1SubformCollectionHashmap1End :: <
          Definition > :: default(),)
      }
      #[doc =
      "Collection setter for the 'hashmap_1' field. Method _hashmap_1_subform_collection unlike method hashmap_1 accept custom collection subformer."]
      #[inline(always)] pub fn hashmap_1(self) -> former :: CollectionFormer ::
      < < collection_tools :: HashMap < String, String > as former :: Collection
      > :: Entry, former :: HashMapDefinition < String, String, Struct1Former <
      Definition > , Struct1Former < Definition > ,
      Struct1SubformCollectionHashmap1End < Definition > > , > where former ::
      HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > : former :: FormerDefinition < Storage = collection_tools
      :: HashMap < String, String > , Context = Struct1Former < Definition > ,
      End = Struct1SubformCollectionHashmap1End < Definition > , > ,
      {
          self._hashmap_1_subform_collection :: < former :: CollectionFormer <
          _, _ > > ()
      }
      #[doc =
      "Collection setter for the 'hashset_1' field. Method _hashset_1_subform_collection unlike method hashset_1 accept custom collection subformer."]
      #[inline(always)] pub fn _hashset_1_subform_collection < 'a, Former2 >
      (self) -> Former2 where Former2 : former :: FormerBegin < 'a, former ::
      HashSetDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionHashset1End < Definition > > > ,
      former :: HashSetDefinition < String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashset1End <
      Definition > > : former :: FormerDefinition < Storage = collection_tools
      :: HashSet < String > , Context = Struct1Former < Definition > , End =
      Struct1SubformCollectionHashset1End < Definition > , > , < former ::
      HashSetDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionHashset1End < Definition > > as
      former :: FormerDefinition > :: Storage : 'a, < former ::
      HashSetDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionHashset1End < Definition > > as
      former :: FormerDefinition > :: Context : 'a, < former ::
      HashSetDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionHashset1End < Definition > > as
      former :: FormerDefinition > :: End : 'a, Definition : 'a,
      {
          Former2 ::
          former_begin(:: core :: option :: Option :: None, :: core :: option ::
          Option :: Some(self), Struct1SubformCollectionHashset1End :: <
          Definition > :: default(),)
      }
      #[doc =
      "Collection setter for the 'hashset_1' field. Method _hashset_1_subform_collection unlike method hashset_1 accept custom collection subformer."]
      #[inline(always)] pub fn hashset_1(self) -> former :: CollectionFormer ::
      < < collection_tools :: HashSet < String > as former :: Collection > ::
      Entry, former :: HashSetDefinition < String, Struct1Former < Definition >
      , Struct1Former < Definition > , Struct1SubformCollectionHashset1End <
      Definition > > , > where former :: HashSetDefinition < String,
      Struct1Former < Definition > , Struct1Former < Definition > ,
      Struct1SubformCollectionHashset1End < Definition > > : former ::
      FormerDefinition < Storage = collection_tools :: HashSet < String > ,
      Context = Struct1Former < Definition > , End =
      Struct1SubformCollectionHashset1End < Definition > , > ,
      {
          self._hashset_1_subform_collection :: < former :: CollectionFormer <
          _, _ > > ()
      }
  } impl < Definition > Struct1Former < Definition > where Definition : former
  :: FormerDefinition < Storage = Struct1FormerStorage, Formed = Struct1 > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  Struct1FormerStorage, Formed = Struct1 > , Definition : former ::
  FormerDefinition < Storage = Struct1FormerStorage > , Definition :: Types :
  former :: FormerDefinitionTypes < Storage = Struct1FormerStorage > ,
  {
      #[doc =
      r" Executes the transformation from the former's storage state to the preformed object."]
      pub fn preform(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed
      { former :: StoragePreform :: preform(self.storage) }
  } #[automatically_derived] impl < Definition > Struct1Former < Definition >
  where Definition : former :: FormerDefinition < Storage =
  Struct1FormerStorage, Formed = Struct1 > , Definition :: Types : former ::
  FormerDefinitionTypes < Storage = Struct1FormerStorage, Formed = Struct1 > ,
  {
      #[doc = r" Finish setting options and call perform on formed entity."]
      #[inline(always)] pub fn perform(self) -> Definition :: Formed
      { let result = self.form(); return result; }
  } impl < 'a, Definition > former :: FormerBegin < 'a, Definition > for
  Struct1Former < Definition > where Definition : former :: FormerDefinition <
  Storage = Struct1FormerStorage > , Definition :: Storage : 'a, Definition ::
  Context : 'a, Definition :: End : 'a,
  {
      #[inline(always)] fn
      former_begin(storage : :: core :: option :: Option < Definition :: Storage
      > , context : :: core :: option :: Option < Definition :: Context > ,
      on_end : Definition :: End,) -> Self
      { Self :: begin(:: core :: option :: Option :: None, context, on_end) }
  }
  #[doc =
  r" Provides a specialized former for structure using predefined settings for superformer and end conditions."]
  pub type Struct1AsSubformer < __Superformer, __End > = Struct1Former <
  Struct1FormerDefinition < __Superformer, __Superformer, __End > > ;
  #[doc =
  "\nRepresents an end condition for former of [`$Struct1`], tying the lifecycle of forming processes to a broader context.\n\nThis trait is intended for use with subformer alias, ensuring that end conditions are met according to the\nspecific needs of the broader forming context. It mandates the implementation of `former::FormingEnd`.\n    "]
  pub trait Struct1AsSubformerEnd < SuperFormer > where Self : former ::
  FormingEnd < Struct1FormerDefinitionTypes < SuperFormer, SuperFormer > > {}
  impl < SuperFormer, __T > Struct1AsSubformerEnd < SuperFormer > for __T where
  Self : former :: FormingEnd < Struct1FormerDefinitionTypes < SuperFormer,
  SuperFormer > > {}
  #[doc =
  "\nA callback structure to manage the final stage of forming a `Vec < String >` for the `Struct1` collection.\n\nThis callback is used to integrate the contents of a temporary `Vec < String >` back into the original `Struct1` former\nafter the subforming process is completed. It replaces the existing content of the `vec_1` field in `Struct1`\nwith the new content generated during the subforming process.\n      "]
  pub struct Struct1SubformCollectionVec1End < Definition >
  { _phantom : core :: marker :: PhantomData < (Definition,) > , } impl <
  Definition > :: core :: default :: Default for Struct1SubformCollectionVec1End
  < Definition >
  {
      #[inline(always)] fn default() -> Self
      { Self { _phantom : core :: marker :: PhantomData, } }
  } #[automatically_derived] impl < Definition > former :: FormingEnd < former
  :: VectorDefinitionTypes < String, Struct1Former < Definition > ,
  Struct1Former < Definition > > > for Struct1SubformCollectionVec1End <
  Definition > where Definition : former :: FormerDefinition < Storage =
  Struct1FormerStorage > , Definition :: Types : former :: FormerDefinitionTypes
  < Storage = Struct1FormerStorage > ,
  {
      #[inline(always)] fn
      call(& self, storage : Vec < String > , super_former : Option <
      Struct1Former < Definition > > ,) -> Struct1Former < Definition >
      {
          let mut super_former = super_former.unwrap(); if let
          Some(ref mut field) = super_former.storage.vec_1
          { former :: CollectionAssign :: assign(field, storage); } else
          { super_former.storage.vec_1 = Some(storage); } super_former
      }
  }
  #[doc =
  "\nA callback structure to manage the final stage of forming a `collection_tools :: HashMap < String, String >` for the `Struct1` collection.\n\nThis callback is used to integrate the contents of a temporary `collection_tools :: HashMap < String, String >` back into the original `Struct1` former\nafter the subforming process is completed. It replaces the existing content of the `hashmap_1` field in `Struct1`\nwith the new content generated during the subforming process.\n      "]
  pub struct Struct1SubformCollectionHashmap1End < Definition >
  { _phantom : core :: marker :: PhantomData < (Definition,) > , } impl <
  Definition > :: core :: default :: Default for
  Struct1SubformCollectionHashmap1End < Definition >
  {
      #[inline(always)] fn default() -> Self
      { Self { _phantom : core :: marker :: PhantomData, } }
  } #[automatically_derived] impl < Definition > former :: FormingEnd < former
  :: HashMapDefinitionTypes < String, String, Struct1Former < Definition > ,
  Struct1Former < Definition > > > for Struct1SubformCollectionHashmap1End <
  Definition > where Definition : former :: FormerDefinition < Storage =
  Struct1FormerStorage > , Definition :: Types : former :: FormerDefinitionTypes
  < Storage = Struct1FormerStorage > ,
  {
      #[inline(always)] fn
      call(& self, storage : collection_tools :: HashMap < String, String > ,
      super_former : Option < Struct1Former < Definition > > ,) -> Struct1Former
      < Definition >
      {
          let mut super_former = super_former.unwrap(); if let
          Some(ref mut field) = super_former.storage.hashmap_1
          { former :: CollectionAssign :: assign(field, storage); } else
          { super_former.storage.hashmap_1 = Some(storage); } super_former
      }
  }
  #[doc =
  "\nA callback structure to manage the final stage of forming a `collection_tools :: HashSet < String >` for the `Struct1` collection.\n\nThis callback is used to integrate the contents of a temporary `collection_tools :: HashSet < String >` back into the original `Struct1` former\nafter the subforming process is completed. It replaces the existing content of the `hashset_1` field in `Struct1`\nwith the new content generated during the subforming process.\n      "]
  pub struct Struct1SubformCollectionHashset1End < Definition >
  { _phantom : core :: marker :: PhantomData < (Definition,) > , } impl <
  Definition > :: core :: default :: Default for
  Struct1SubformCollectionHashset1End < Definition >
  {
      #[inline(always)] fn default() -> Self
      { Self { _phantom : core :: marker :: PhantomData, } }
  } #[automatically_derived] impl < Definition > former :: FormingEnd < former
  :: HashSetDefinitionTypes < String, Struct1Former < Definition > ,
  Struct1Former < Definition > > > for Struct1SubformCollectionHashset1End <
  Definition > where Definition : former :: FormerDefinition < Storage =
  Struct1FormerStorage > , Definition :: Types : former :: FormerDefinitionTypes
  < Storage = Struct1FormerStorage > ,
  {
      #[inline(always)] fn
      call(& self, storage : collection_tools :: HashSet < String > ,
      super_former : Option < Struct1Former < Definition > > ,) -> Struct1Former
      < Definition >
      {
          let mut super_former = super_former.unwrap(); if let
          Some(ref mut field) = super_former.storage.hashset_1
          { former :: CollectionAssign :: assign(field, storage); } else
          { super_former.storage.hashset_1 = Some(storage); } super_former
      }
  }


 = context

  derive : Former
  structure : Struct1

 = original

  #[debug] pub struct Struct1
  {
      #[subform_collection(definition = former::VectorDefinition)] vec_1:
      Vec<String>, #[subform_collection(definition = former::HashMapDefinition)]
      hashmap_1: collection_tools::HashMap<String, String>,
      #[subform_collection(definition = former::HashSetDefinition)] hashset_1:
      collection_tools::HashSet<String>,
  }

 = generated

  #[automatically_derived] impl Struct1
  {
      #[doc =
      r" Provides a mechanism to initiate the formation process with a default completion behavior."]
      #[inline(always)] pub fn former() -> Struct1Former <
      Struct1FormerDefinition < (), Struct1, former :: ReturnPreformed > >
      { Struct1Former :: begin(None, None, former :: ReturnPreformed) }
  } impl < Definition > former :: EntityToFormer < Definition > for Struct1
  where Definition : former :: FormerDefinition < Storage = Struct1FormerStorage
  > , { type Former = Struct1Former < Definition > ; } impl former ::
  EntityToStorage for Struct1 { type Storage = Struct1FormerStorage; } impl <
  __Context, __Formed, __End > former :: EntityToDefinition < __Context,
  __Formed, __End > for Struct1 where __End : former :: FormingEnd <
  Struct1FormerDefinitionTypes < __Context, __Formed > > ,
  {
      type Definition = Struct1FormerDefinition < __Context, __Formed, __End > ;
      type Types = Struct1FormerDefinitionTypes < __Context, __Formed > ;
  } impl < __Context, __Formed > former :: EntityToDefinitionTypes < __Context,
  __Formed > for Struct1
  { type Types = Struct1FormerDefinitionTypes < __Context, __Formed > ; }
  #[doc =
  r" Defines the generic parameters for formation behavior including context, form, and end conditions."]
  #[derive(Debug)] pub struct Struct1FormerDefinitionTypes < __Context = (),
  __Formed = Struct1, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (* const __Context, * const __Formed) > ,
  } impl < __Context, __Formed > :: core :: default :: Default for
  Struct1FormerDefinitionTypes < __Context, __Formed >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < __Context, __Formed > former :: FormerDefinitionTypes for
  Struct1FormerDefinitionTypes < __Context, __Formed >
  {
      type Storage = Struct1FormerStorage; type Formed = __Formed; type Context
      = __Context;
  } impl < __Context, __Formed > former :: FormerMutator for
  Struct1FormerDefinitionTypes < __Context, __Formed > where {}
  #[doc = r" Holds the definition types used during the formation process."]
  #[derive(Debug)] pub struct Struct1FormerDefinition < __Context = (), __Formed
  = Struct1, __End = former :: ReturnPreformed, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (* const __Context, * const __Formed, * const __End) > ,
  } impl < __Context, __Formed, __End > :: core :: default :: Default for
  Struct1FormerDefinition < __Context, __Formed, __End >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < __Context, __Formed, __End > former :: FormerDefinition for
  Struct1FormerDefinition < __Context, __Formed, __End > where __End : former ::
  FormingEnd < Struct1FormerDefinitionTypes < __Context, __Formed > >
  {
      type Types = Struct1FormerDefinitionTypes < __Context, __Formed > ; type
      End = __End; type Storage = Struct1FormerStorage; type Formed = __Formed;
      type Context = __Context;
  } #[doc = "Stores potential values for fields during the formation process."]
  #[allow(explicit_outlives_requirements)] pub struct Struct1FormerStorage < >
  {
      #[doc = r" A field"] pub vec_1 : :: core :: option :: Option < Vec <
      String > > , #[doc = r" A field"] pub hashmap_1 : :: core :: option ::
      Option < collection_tools :: HashMap < String, String > > ,
      #[doc = r" A field"] pub hashset_1 : :: core :: option :: Option <
      collection_tools :: HashSet < String > > ,
  } impl :: core :: default :: Default for Struct1FormerStorage
  {
      #[inline(always)] fn default() -> Self
      {
          Self
          {
              vec_1 : :: core :: option :: Option :: None, hashmap_1 : :: core
              :: option :: Option :: None, hashset_1 : :: core :: option ::
              Option :: None,
          }
      }
  } impl former :: Storage for Struct1FormerStorage
  { type Preformed = Struct1; } impl former :: StoragePreform for
  Struct1FormerStorage
  {
      fn preform(mut self) -> Self :: Preformed
      {
          let vec_1 = if self.vec_1.is_some() { self.vec_1.take().unwrap() }
          else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'vec_1' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData < Vec < String
                  > > = :: core :: marker :: PhantomData;
                  (& phantom).maybe_default()
              }
          }; let hashmap_1 = if self.hashmap_1.is_some()
          { self.hashmap_1.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'hashmap_1' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData <
                  collection_tools :: HashMap < String, String > > = :: core ::
                  marker :: PhantomData; (& phantom).maybe_default()
              }
          }; let hashset_1 = if self.hashset_1.is_some()
          { self.hashset_1.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'hashset_1' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData <
                  collection_tools :: HashSet < String > > = :: core :: marker
                  :: PhantomData; (& phantom).maybe_default()
              }
          }; let result = Struct1 { vec_1, hashmap_1, hashset_1, }; return
          result;
      }
  }
  #[doc =
  "\nStructure to form [Struct1]. Represents a forming entity designed to construct objects through a builder pattern.\n\nThis structure holds temporary storage and context during the formation process and\nutilizes a defined end strategy to finalize the object creation.\n"]
  pub struct Struct1Former < Definition = Struct1FormerDefinition < (), Struct1,
  former :: ReturnPreformed > , > where Definition : former :: FormerDefinition
  < Storage = Struct1FormerStorage > , Definition :: Types : former ::
  FormerDefinitionTypes < Storage = Struct1FormerStorage > ,
  {
      #[doc =
      r" Temporary storage for all fields during the formation process."] pub
      storage : Definition :: Storage, #[doc = r" Optional context."] pub
      context : :: core :: option :: Option < Definition :: Context > ,
      #[doc = r" Optional handler for the end of formation."] pub on_end : ::
      core :: option :: Option < Definition :: End > ,
  } #[automatically_derived] impl < Definition > Struct1Former < Definition >
  where Definition : former :: FormerDefinition < Storage = Struct1FormerStorage
  > , Definition :: Types : former :: FormerDefinitionTypes < Storage =
  Struct1FormerStorage > ,
  {
      #[doc =
      r" Initializes a former with an end condition and default storage."]
      #[inline(always)] pub fn new(on_end : Definition :: End) -> Self
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, on_end)
      } #[doc = r" Initializes a former with a coercible end condition."]
      #[inline(always)] pub fn new_coercing < IntoEnd > (end : IntoEnd) -> Self
      where IntoEnd : :: core :: convert :: Into < Definition :: End > ,
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, end,)
      }
      #[doc =
      r" Begins the formation process with specified context and termination logic."]
      #[inline(always)] pub fn
      begin(mut storage : :: core :: option :: Option < Definition :: Storage >
      , context : :: core :: option :: Option < Definition :: Context > , on_end
      : < Definition as former :: FormerDefinition > :: End,) -> Self
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option :: Some(on_end),
          }
      }
      #[doc =
      r" Starts the formation process with coercible end condition and optional initial values."]
      #[inline(always)] pub fn begin_coercing < IntoEnd >
      (mut storage : :: core :: option :: Option < Definition :: Storage > ,
      context : :: core :: option :: Option < Definition :: Context > , on_end :
      IntoEnd,) -> Self where IntoEnd : :: core :: convert :: Into < <
      Definition as former :: FormerDefinition > :: End > ,
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option ::
              Some(:: core :: convert :: Into :: into(on_end)),
          }
      }
      #[doc =
      r" Wrapper for `end` to align with common builder pattern terminologies."]
      #[inline(always)] pub fn form(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed { self.end() }
      #[doc = r" Completes the formation and returns the formed object."]
      #[inline(always)] pub fn end(mut self) -> < Definition :: Types as former
      :: FormerDefinitionTypes > :: Formed
      {
          let on_end = self.on_end.take().unwrap(); let mut context =
          self.context.take(); < Definition :: Types as former :: FormerMutator
          > :: form_mutation(& mut self.storage, & mut context); former ::
          FormingEnd :: < Definition :: Types > ::
          call(& on_end, self.storage, context)
      }
      #[doc =
      "Collection setter for the 'vec_1' field. Method _vec_1_subform_collection unlike method vec_1 accept custom collection subformer."]
      #[inline(always)] pub fn _vec_1_subform_collection < 'a, Former2 > (self)
      -> Former2 where Former2 : former :: FormerBegin < 'a, former ::
      VectorDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionVec1End < Definition > > > , former
      :: VectorDefinition < String, Struct1Former < Definition > , Struct1Former
      < Definition > , Struct1SubformCollectionVec1End < Definition > > : former
      :: FormerDefinition < Storage = Vec < String > , Context = Struct1Former <
      Definition > , End = Struct1SubformCollectionVec1End < Definition > , > ,
      < former :: VectorDefinition < String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionVec1End <
      Definition > > as former :: FormerDefinition > :: Storage : 'a, < former
      :: VectorDefinition < String, Struct1Former < Definition > , Struct1Former
      < Definition > , Struct1SubformCollectionVec1End < Definition > > as
      former :: FormerDefinition > :: Context : 'a, < former :: VectorDefinition
      < String, Struct1Former < Definition > , Struct1Former < Definition > ,
      Struct1SubformCollectionVec1End < Definition > > as former ::
      FormerDefinition > :: End : 'a, Definition : 'a,
      {
          Former2 ::
          former_begin(:: core :: option :: Option :: None, :: core :: option ::
          Option :: Some(self), Struct1SubformCollectionVec1End :: < Definition
          > :: default(),)
      }
      #[doc =
      "Collection setter for the 'vec_1' field. Method _vec_1_subform_collection unlike method vec_1 accept custom collection subformer."]
      #[inline(always)] pub fn vec_1(self) -> former :: CollectionFormer :: < <
      Vec < String > as former :: Collection > :: Entry, former ::
      VectorDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionVec1End < Definition > > , > where
      former :: VectorDefinition < String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionVec1End <
      Definition > > : former :: FormerDefinition < Storage = Vec < String > ,
      Context = Struct1Former < Definition > , End =
      Struct1SubformCollectionVec1End < Definition > , > ,
      {
          self._vec_1_subform_collection :: < former :: CollectionFormer < _, _
          > > ()
      }
      #[doc =
      "Collection setter for the 'hashmap_1' field. Method _hashmap_1_subform_collection unlike method hashmap_1 accept custom collection subformer."]
      #[inline(always)] pub fn _hashmap_1_subform_collection < 'a, Former2 >
      (self) -> Former2 where Former2 : former :: FormerBegin < 'a, former ::
      HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > > , former :: HashMapDefinition < String, String,
      Struct1Former < Definition > , Struct1Former < Definition > ,
      Struct1SubformCollectionHashmap1End < Definition > > : former ::
      FormerDefinition < Storage = collection_tools :: HashMap < String, String
      > , Context = Struct1Former < Definition > , End =
      Struct1SubformCollectionHashmap1End < Definition > , > , < former ::
      HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > as former :: FormerDefinition > :: Storage : 'a, < former
      :: HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > as former :: FormerDefinition > :: Context : 'a, < former
      :: HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > as former :: FormerDefinition > :: End : 'a, Definition :
      'a,
      {
          Former2 ::
          former_begin(:: core :: option :: Option :: None, :: core :: option ::
          Option :: Some(self), Struct1SubformCollectionHashmap1End :: <
          Definition > :: default(),)
      }
      #[doc =
      "Collection setter for the 'hashmap_1' field. Method _hashmap_1_subform_collection unlike method hashmap_1 accept custom collection subformer."]
      #[inline(always)] pub fn hashmap_1(self) -> former :: CollectionFormer ::
      < < collection_tools :: HashMap < String, String > as former :: Collection
      > :: Entry, former :: HashMapDefinition < String, String, Struct1Former <
      Definition > , Struct1Former < Definition > ,
      Struct1SubformCollectionHashmap1End < Definition > > , > where former ::
      HashMapDefinition < String, String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashmap1End <
      Definition > > : former :: FormerDefinition < Storage = collection_tools
      :: HashMap < String, String > , Context = Struct1Former < Definition > ,
      End = Struct1SubformCollectionHashmap1End < Definition > , > ,
      {
          self._hashmap_1_subform_collection :: < former :: CollectionFormer <
          _, _ > > ()
      }
      #[doc =
      "Collection setter for the 'hashset_1' field. Method _hashset_1_subform_collection unlike method hashset_1 accept custom collection subformer."]
      #[inline(always)] pub fn _hashset_1_subform_collection < 'a, Former2 >
      (self) -> Former2 where Former2 : former :: FormerBegin < 'a, former ::
      HashSetDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionHashset1End < Definition > > > ,
      former :: HashSetDefinition < String, Struct1Former < Definition > ,
      Struct1Former < Definition > , Struct1SubformCollectionHashset1End <
      Definition > > : former :: FormerDefinition < Storage = collection_tools
      :: HashSet < String > , Context = Struct1Former < Definition > , End =
      Struct1SubformCollectionHashset1End < Definition > , > , < former ::
      HashSetDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionHashset1End < Definition > > as
      former :: FormerDefinition > :: Storage : 'a, < former ::
      HashSetDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionHashset1End < Definition > > as
      former :: FormerDefinition > :: Context : 'a, < former ::
      HashSetDefinition < String, Struct1Former < Definition > , Struct1Former <
      Definition > , Struct1SubformCollectionHashset1End < Definition > > as
      former :: FormerDefinition > :: End : 'a, Definition : 'a,
      {
          Former2 ::
          former_begin(:: core :: option :: Option :: None, :: core :: option ::
          Option :: Some(self), Struct1SubformCollectionHashset1End :: <
          Definition > :: default(),)
      }
      #[doc =
      "Collection setter for the 'hashset_1' field. Method _hashset_1_subform_collection unlike method hashset_1 accept custom collection subformer."]
      #[inline(always)] pub fn hashset_1(self) -> former :: CollectionFormer ::
      < < collection_tools :: HashSet < String > as former :: Collection > ::
      Entry, former :: HashSetDefinition < String, Struct1Former < Definition >
      , Struct1Former < Definition > , Struct1SubformCollectionHashset1End <
      Definition > > , > where former :: HashSetDefinition < String,
      Struct1Former < Definition > , Struct1Former < Definition > ,
      Struct1SubformCollectionHashset1End < Definition > > : former ::
      FormerDefinition < Storage = collection_tools :: HashSet < String > ,
      Context = Struct1Former < Definition > , End =
      Struct1SubformCollectionHashset1End < Definition > , > ,
      {
          self._hashset_1_subform_collection :: < former :: CollectionFormer <
          _, _ > > ()
      }
  } impl < Definition > Struct1Former < Definition > where Definition : former
  :: FormerDefinition < Storage = Struct1FormerStorage, Formed = Struct1 > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  Struct1FormerStorage, Formed = Struct1 > , Definition : former ::
  FormerDefinition < Storage = Struct1FormerStorage > , Definition :: Types :
  former :: FormerDefinitionTypes < Storage = Struct1FormerStorage > ,
  {
      #[doc =
      r" Executes the transformation from the former's storage state to the preformed object."]
      pub fn preform(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed
      { former :: StoragePreform :: preform(self.storage) }
  } #[automatically_derived] impl < Definition > Struct1Former < Definition >
  where Definition : former :: FormerDefinition < Storage =
  Struct1FormerStorage, Formed = Struct1 > , Definition :: Types : former ::
  FormerDefinitionTypes < Storage = Struct1FormerStorage, Formed = Struct1 > ,
  {
      #[doc = r" Finish setting options and call perform on formed entity."]
      #[inline(always)] pub fn perform(self) -> Definition :: Formed
      { let result = self.form(); return result; }
  } impl < 'a, Definition > former :: FormerBegin < 'a, Definition > for
  Struct1Former < Definition > where Definition : former :: FormerDefinition <
  Storage = Struct1FormerStorage > , Definition :: Storage : 'a, Definition ::
  Context : 'a, Definition :: End : 'a,
  {
      #[inline(always)] fn
      former_begin(storage : :: core :: option :: Option < Definition :: Storage
      > , context : :: core :: option :: Option < Definition :: Context > ,
      on_end : Definition :: End,) -> Self
      { Self :: begin(:: core :: option :: Option :: None, context, on_end) }
  }
  #[doc =
  r" Provides a specialized former for structure using predefined settings for superformer and end conditions."]
  pub type Struct1AsSubformer < __Superformer, __End > = Struct1Former <
  Struct1FormerDefinition < __Superformer, __Superformer, __End > > ;
  #[doc =
  "\nRepresents an end condition for former of [`$Struct1`], tying the lifecycle of forming processes to a broader context.\n\nThis trait is intended for use with subformer alias, ensuring that end conditions are met according to the\nspecific needs of the broader forming context. It mandates the implementation of `former::FormingEnd`.\n    "]
  pub trait Struct1AsSubformerEnd < SuperFormer > where Self : former ::
  FormingEnd < Struct1FormerDefinitionTypes < SuperFormer, SuperFormer > > {}
  impl < SuperFormer, __T > Struct1AsSubformerEnd < SuperFormer > for __T where
  Self : former :: FormingEnd < Struct1FormerDefinitionTypes < SuperFormer,
  SuperFormer > > {}
  #[doc =
  "\nA callback structure to manage the final stage of forming a `Vec < String >` for the `Struct1` collection.\n\nThis callback is used to integrate the contents of a temporary `Vec < String >` back into the original `Struct1` former\nafter the subforming process is completed. It replaces the existing content of the `vec_1` field in `Struct1`\nwith the new content generated during the subforming process.\n      "]
  pub struct Struct1SubformCollectionVec1End < Definition >
  { _phantom : core :: marker :: PhantomData < (Definition,) > , } impl <
  Definition > :: core :: default :: Default for Struct1SubformCollectionVec1End
  < Definition >
  {
      #[inline(always)] fn default() -> Self
      { Self { _phantom : core :: marker :: PhantomData, } }
  } #[automatically_derived] impl < Definition > former :: FormingEnd < former
  :: VectorDefinitionTypes < String, Struct1Former < Definition > ,
  Struct1Former < Definition > > > for Struct1SubformCollectionVec1End <
  Definition > where Definition : former :: FormerDefinition < Storage =
  Struct1FormerStorage > , Definition :: Types : former :: FormerDefinitionTypes
  < Storage = Struct1FormerStorage > ,
  {
      #[inline(always)] fn
      call(& self, storage : Vec < String > , super_former : Option <
      Struct1Former < Definition > > ,) -> Struct1Former < Definition >
      {
          let mut super_former = super_former.unwrap(); if let
          Some(ref mut field) = super_former.storage.vec_1
          { former :: CollectionAssign :: assign(field, storage); } else
          { super_former.storage.vec_1 = Some(storage); } super_former
      }
  }
  #[doc =
  "\nA callback structure to manage the final stage of forming a `collection_tools :: HashMap < String, String >` for the `Struct1` collection.\n\nThis callback is used to integrate the contents of a temporary `collection_tools :: HashMap < String, String >` back into the original `Struct1` former\nafter the subforming process is completed. It replaces the existing content of the `hashmap_1` field in `Struct1`\nwith the new content generated during the subforming process.\n      "]
  pub struct Struct1SubformCollectionHashmap1End < Definition >
  { _phantom : core :: marker :: PhantomData < (Definition,) > , } impl <
  Definition > :: core :: default :: Default for
  Struct1SubformCollectionHashmap1End < Definition >
  {
      #[inline(always)] fn default() -> Self
      { Self { _phantom : core :: marker :: PhantomData, } }
  } #[automatically_derived] impl < Definition > former :: FormingEnd < former
  :: HashMapDefinitionTypes < String, String, Struct1Former < Definition > ,
  Struct1Former < Definition > > > for Struct1SubformCollectionHashmap1End <
  Definition > where Definition : former :: FormerDefinition < Storage =
  Struct1FormerStorage > , Definition :: Types : former :: FormerDefinitionTypes
  < Storage = Struct1FormerStorage > ,
  {
      #[inline(always)] fn
      call(& self, storage : collection_tools :: HashMap < String, String > ,
      super_former : Option < Struct1Former < Definition > > ,) -> Struct1Former
      < Definition >
      {
          let mut super_former = super_former.unwrap(); if let
          Some(ref mut field) = super_former.storage.hashmap_1
          { former :: CollectionAssign :: assign(field, storage); } else
          { super_former.storage.hashmap_1 = Some(storage); } super_former
      }
  }
  #[doc =
  "\nA callback structure to manage the final stage of forming a `collection_tools :: HashSet < String >` for the `Struct1` collection.\n\nThis callback is used to integrate the contents of a temporary `collection_tools :: HashSet < String >` back into the original `Struct1` former\nafter the subforming process is completed. It replaces the existing content of the `hashset_1` field in `Struct1`\nwith the new content generated during the subforming process.\n      "]
  pub struct Struct1SubformCollectionHashset1End < Definition >
  { _phantom : core :: marker :: PhantomData < (Definition,) > , } impl <
  Definition > :: core :: default :: Default for
  Struct1SubformCollectionHashset1End < Definition >
  {
      #[inline(always)] fn default() -> Self
      { Self { _phantom : core :: marker :: PhantomData, } }
  } #[automatically_derived] impl < Definition > former :: FormingEnd < former
  :: HashSetDefinitionTypes < String, Struct1Former < Definition > ,
  Struct1Former < Definition > > > for Struct1SubformCollectionHashset1End <
  Definition > where Definition : former :: FormerDefinition < Storage =
  Struct1FormerStorage > , Definition :: Types : former :: FormerDefinitionTypes
  < Storage = Struct1FormerStorage > ,
  {
      #[inline(always)] fn
      call(& self, storage : collection_tools :: HashSet < String > ,
      super_former : Option < Struct1Former < Definition > > ,) -> Struct1Former
      < Definition >
      {
          let mut super_former = super_former.unwrap(); if let
          Some(ref mut field) = super_former.storage.hashset_1
          { former :: CollectionAssign :: assign(field, storage); } else
          { super_former.storage.hashset_1 = Some(storage); } super_former
      }
  }

Struct: WithLifetime
has_only_lifetimes: true
classification: GenericsClassification { lifetimes: [LifetimeParam { attrs: [], lifetime: Lifetime { apostrophe: #0 bytes(67774..67776), ident: Ident { ident: "a", span: #0 bytes(67774..67776) } }, colon_token: None, bounds: [] }], types: [], consts: [], has_only_lifetimes: true, has_only_types: false, has_only_consts: false, has_mixed: false, is_empty: false }

 = context

  derive : Former
  struct : WithLifetime

 = original

  #[debug] pub struct WithLifetime<'a> { name: &'a str, }

 = generated

  #[automatically_derived] impl < 'a > WithLifetime < 'a >
  {
      #[doc =
      r" Provides a mechanism to initiate the formation process with a default completion behavior."]
      #[inline(always)] pub fn former() -> WithLifetimeFormer < 'a,
      WithLifetimeFormerDefinition < 'a, (), WithLifetime < 'a > , former ::
      ReturnPreformed > >
      { WithLifetimeFormer :: begin(None, None, former :: ReturnPreformed) }
  } impl < 'a, Definition > former :: EntityToFormer < Definition > for
  WithLifetime < 'a > where Definition : former :: FormerDefinition < Storage =
  WithLifetimeFormerStorage < 'a > > ,
  { type Former = WithLifetimeFormer < 'a, Definition > ; } impl < 'a > former
  :: EntityToStorage for WithLifetime < 'a >
  { type Storage = WithLifetimeFormerStorage < 'a > ; } impl < 'a, __Context,
  __Formed, __End > former :: EntityToDefinition < __Context, __Formed, __End >
  for WithLifetime < 'a > where __End : former :: FormingEnd <
  WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > > ,
  {
      type Definition = WithLifetimeFormerDefinition < 'a, __Context, __Formed,
      __End > ; type Types = WithLifetimeFormerDefinitionTypes < 'a, __Context,
      __Formed > ;
  } impl < 'a, __Context, __Formed > former :: EntityToDefinitionTypes <
  __Context, __Formed > for WithLifetime < 'a >
  {
      type Types = WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
      ;
  }
  #[doc =
  r" Defines the generic parameters for formation behavior including context, form, and end conditions."]
  #[derive(Debug)] pub struct WithLifetimeFormerDefinitionTypes < 'a, __Context
  = (), __Formed = WithLifetime < 'a > , >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed) > ,
  } impl < 'a, __Context, __Formed > :: core :: default :: Default for
  WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed > former :: FormerDefinitionTypes for
  WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      type Storage = WithLifetimeFormerStorage < 'a > ; type Formed = __Formed;
      type Context = __Context;
  } impl < 'a, __Context, __Formed > former :: FormerMutator for
  WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > where {}
  #[doc = r" Holds the definition types used during the formation process."]
  #[derive(Debug)] pub struct WithLifetimeFormerDefinition < 'a, __Context = (),
  __Formed = WithLifetime < 'a > , __End = former :: ReturnPreformed, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed, * const __End) > ,
  } impl < 'a, __Context, __Formed, __End > :: core :: default :: Default for
  WithLifetimeFormerDefinition < 'a, __Context, __Formed, __End >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed, __End > former :: FormerDefinition for
  WithLifetimeFormerDefinition < 'a, __Context, __Formed, __End > where __End :
  former :: FormingEnd < WithLifetimeFormerDefinitionTypes < 'a, __Context,
  __Formed > >
  {
      type Types = WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
      ; type End = __End; type Storage = WithLifetimeFormerStorage < 'a > ; type
      Formed = __Formed; type Context = __Context;
  } #[doc = "Stores potential values for fields during the formation process."]
  #[allow(explicit_outlives_requirements)] pub struct WithLifetimeFormerStorage
  < 'a, >
  { #[doc = r" A field"] pub name : :: core :: option :: Option < & 'a str > , }
  impl < 'a > :: core :: default :: Default for WithLifetimeFormerStorage < 'a >
  {
      #[inline(always)] fn default() -> Self
      { Self { name : :: core :: option :: Option :: None, } }
  } impl < 'a > former :: Storage for WithLifetimeFormerStorage < 'a >
  { type Preformed = WithLifetime < 'a > ; } impl < 'a > former ::
  StoragePreform for WithLifetimeFormerStorage < 'a >
  {
      fn preform(mut self) -> Self :: Preformed
      {
          let name = if self.name.is_some() { self.name.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'name' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData < & 'a str > =
                  :: core :: marker :: PhantomData; (& phantom).maybe_default()
              }
          }; let result = WithLifetime { name, }; return result;
      }
  }
  #[doc =
  "\nStructure to form [WithLifetime]. Represents a forming entity designed to construct objects through a builder pattern.\n\nThis structure holds temporary storage and context during the formation process and\nutilizes a defined end strategy to finalize the object creation.\n"]
  pub struct WithLifetimeFormer < 'a, Definition > where Definition : former ::
  FormerDefinition < Storage = WithLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Temporary storage for all fields during the formation process."] pub
      storage : Definition :: Storage, #[doc = r" Optional context."] pub
      context : :: core :: option :: Option < Definition :: Context > ,
      #[doc = r" Optional handler for the end of formation."] pub on_end : ::
      core :: option :: Option < Definition :: End > ,
  } #[automatically_derived] impl < 'a, Definition > WithLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  WithLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Initializes a former with an end condition and default storage."]
      #[inline(always)] pub fn new(on_end : Definition :: End) -> Self
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, on_end)
      } #[doc = r" Initializes a former with a coercible end condition."]
      #[inline(always)] pub fn new_coercing < IntoEnd > (end : IntoEnd) -> Self
      where IntoEnd : :: core :: convert :: Into < Definition :: End > ,
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, end,)
      }
      #[doc =
      r" Begins the formation process with specified context and termination logic."]
      #[inline(always)] pub fn
      begin(mut storage : :: core :: option :: Option < Definition :: Storage >
      , context : :: core :: option :: Option < Definition :: Context > , on_end
      : < Definition as former :: FormerDefinition > :: End,) -> Self
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option :: Some(on_end),
          }
      }
      #[doc =
      r" Starts the formation process with coercible end condition and optional initial values."]
      #[inline(always)] pub fn begin_coercing < IntoEnd >
      (mut storage : :: core :: option :: Option < Definition :: Storage > ,
      context : :: core :: option :: Option < Definition :: Context > , on_end :
      IntoEnd,) -> Self where IntoEnd : :: core :: convert :: Into < <
      Definition as former :: FormerDefinition > :: End > ,
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option ::
              Some(:: core :: convert :: Into :: into(on_end)),
          }
      }
      #[doc =
      r" Wrapper for `end` to align with common builder pattern terminologies."]
      #[inline(always)] pub fn form(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed { self.end() }
      #[doc = r" Completes the formation and returns the formed object."]
      #[inline(always)] pub fn end(mut self) -> < Definition :: Types as former
      :: FormerDefinitionTypes > :: Formed
      {
          let on_end = self.on_end.take().unwrap(); let mut context =
          self.context.take(); < Definition :: Types as former :: FormerMutator
          > :: form_mutation(& mut self.storage, & mut context); former ::
          FormingEnd :: < Definition :: Types > ::
          call(& on_end, self.storage, context)
      } #[doc = "Scalar setter for the 'name' field."] #[inline] pub fn
      name(mut self, src : & 'a str) -> Self
      {
          debug_assert! (self.storage.name.is_none()); self.storage.name = ::
          core :: option :: Option :: Some(src); self
      }
  } impl < 'a, Definition > WithLifetimeFormer < 'a, Definition > where
  Definition : former :: FormerDefinition < Storage = WithLifetimeFormerStorage
  < 'a > , Formed = WithLifetime < 'a > > , Definition :: Types : former ::
  FormerDefinitionTypes < Storage = WithLifetimeFormerStorage < 'a > , Formed =
  WithLifetime < 'a > > , Definition : former :: FormerDefinition < Storage =
  WithLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Executes the transformation from the former's storage state to the preformed object."]
      pub fn preform(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed
      { former :: StoragePreform :: preform(self.storage) }
  } #[automatically_derived] impl < 'a, Definition > WithLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  WithLifetimeFormerStorage < 'a > , Formed = WithLifetime < 'a > > , Definition
  :: Types : former :: FormerDefinitionTypes < Storage =
  WithLifetimeFormerStorage < 'a > , Formed = WithLifetime < 'a > > ,
  {
      #[doc = r" Finish setting options and call perform on formed entity."]
      #[inline(always)] pub fn perform(self) -> Definition :: Formed
      { let result = self.form(); return result; }
  } impl < 'a, Definition > former :: FormerBegin < 'a, Definition > for
  WithLifetimeFormer < 'a, Definition > where Definition : former ::
  FormerDefinition < Storage = WithLifetimeFormerStorage < 'a > > , Definition
  :: Storage : 'a, Definition :: Context : 'a, Definition :: End : 'a,
  {
      #[inline(always)] fn
      former_begin(storage : :: core :: option :: Option < Definition :: Storage
      > , context : :: core :: option :: Option < Definition :: Context > ,
      on_end : Definition :: End,) -> Self
      { Self :: begin(:: core :: option :: Option :: None, context, on_end) }
  }
  #[doc =
  r" Provides a specialized former for structure using predefined settings for superformer and end conditions."]
  pub type WithLifetimeAsSubformer < 'a, __Superformer, __End > =
  WithLifetimeFormer < 'a, WithLifetimeFormerDefinition < 'a, __Superformer,
  __Superformer, __End > > ;
  #[doc =
  "\nRepresents an end condition for former of [`$WithLifetime`], tying the lifecycle of forming processes to a broader context.\n\nThis trait is intended for use with subformer alias, ensuring that end conditions are met according to the\nspecific needs of the broader forming context. It mandates the implementation of `former::FormingEnd`.\n    "]
  pub trait WithLifetimeAsSubformerEnd < 'a, SuperFormer > where Self : former
  :: FormingEnd < WithLifetimeFormerDefinitionTypes < 'a, SuperFormer,
  SuperFormer > > {} impl < 'a, SuperFormer, __T > WithLifetimeAsSubformerEnd <
  'a, SuperFormer > for __T where Self : former :: FormingEnd <
  WithLifetimeFormerDefinitionTypes < 'a, SuperFormer, SuperFormer > > {}


 = context

  derive : Former
  structure : WithLifetime

 = original

  #[debug] pub struct WithLifetime<'a> { name: &'a str, }

 = generated

  #[automatically_derived] impl < 'a > WithLifetime < 'a >
  {
      #[doc =
      r" Provides a mechanism to initiate the formation process with a default completion behavior."]
      #[inline(always)] pub fn former() -> WithLifetimeFormer < 'a,
      WithLifetimeFormerDefinition < 'a, (), WithLifetime < 'a > , former ::
      ReturnPreformed > >
      { WithLifetimeFormer :: begin(None, None, former :: ReturnPreformed) }
  } impl < 'a, Definition > former :: EntityToFormer < Definition > for
  WithLifetime < 'a > where Definition : former :: FormerDefinition < Storage =
  WithLifetimeFormerStorage < 'a > > ,
  { type Former = WithLifetimeFormer < 'a, Definition > ; } impl < 'a > former
  :: EntityToStorage for WithLifetime < 'a >
  { type Storage = WithLifetimeFormerStorage < 'a > ; } impl < 'a, __Context,
  __Formed, __End > former :: EntityToDefinition < __Context, __Formed, __End >
  for WithLifetime < 'a > where __End : former :: FormingEnd <
  WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > > ,
  {
      type Definition = WithLifetimeFormerDefinition < 'a, __Context, __Formed,
      __End > ; type Types = WithLifetimeFormerDefinitionTypes < 'a, __Context,
      __Formed > ;
  } impl < 'a, __Context, __Formed > former :: EntityToDefinitionTypes <
  __Context, __Formed > for WithLifetime < 'a >
  {
      type Types = WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
      ;
  }
  #[doc =
  r" Defines the generic parameters for formation behavior including context, form, and end conditions."]
  #[derive(Debug)] pub struct WithLifetimeFormerDefinitionTypes < 'a, __Context
  = (), __Formed = WithLifetime < 'a > , >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed) > ,
  } impl < 'a, __Context, __Formed > :: core :: default :: Default for
  WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed > former :: FormerDefinitionTypes for
  WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      type Storage = WithLifetimeFormerStorage < 'a > ; type Formed = __Formed;
      type Context = __Context;
  } impl < 'a, __Context, __Formed > former :: FormerMutator for
  WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > where {}
  #[doc = r" Holds the definition types used during the formation process."]
  #[derive(Debug)] pub struct WithLifetimeFormerDefinition < 'a, __Context = (),
  __Formed = WithLifetime < 'a > , __End = former :: ReturnPreformed, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed, * const __End) > ,
  } impl < 'a, __Context, __Formed, __End > :: core :: default :: Default for
  WithLifetimeFormerDefinition < 'a, __Context, __Formed, __End >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed, __End > former :: FormerDefinition for
  WithLifetimeFormerDefinition < 'a, __Context, __Formed, __End > where __End :
  former :: FormingEnd < WithLifetimeFormerDefinitionTypes < 'a, __Context,
  __Formed > >
  {
      type Types = WithLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
      ; type End = __End; type Storage = WithLifetimeFormerStorage < 'a > ; type
      Formed = __Formed; type Context = __Context;
  } #[doc = "Stores potential values for fields during the formation process."]
  #[allow(explicit_outlives_requirements)] pub struct WithLifetimeFormerStorage
  < 'a, >
  { #[doc = r" A field"] pub name : :: core :: option :: Option < & 'a str > , }
  impl < 'a > :: core :: default :: Default for WithLifetimeFormerStorage < 'a >
  {
      #[inline(always)] fn default() -> Self
      { Self { name : :: core :: option :: Option :: None, } }
  } impl < 'a > former :: Storage for WithLifetimeFormerStorage < 'a >
  { type Preformed = WithLifetime < 'a > ; } impl < 'a > former ::
  StoragePreform for WithLifetimeFormerStorage < 'a >
  {
      fn preform(mut self) -> Self :: Preformed
      {
          let name = if self.name.is_some() { self.name.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'name' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData < & 'a str > =
                  :: core :: marker :: PhantomData; (& phantom).maybe_default()
              }
          }; let result = WithLifetime { name, }; return result;
      }
  }
  #[doc =
  "\nStructure to form [WithLifetime]. Represents a forming entity designed to construct objects through a builder pattern.\n\nThis structure holds temporary storage and context during the formation process and\nutilizes a defined end strategy to finalize the object creation.\n"]
  pub struct WithLifetimeFormer < 'a, Definition > where Definition : former ::
  FormerDefinition < Storage = WithLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Temporary storage for all fields during the formation process."] pub
      storage : Definition :: Storage, #[doc = r" Optional context."] pub
      context : :: core :: option :: Option < Definition :: Context > ,
      #[doc = r" Optional handler for the end of formation."] pub on_end : ::
      core :: option :: Option < Definition :: End > ,
  } #[automatically_derived] impl < 'a, Definition > WithLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  WithLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Initializes a former with an end condition and default storage."]
      #[inline(always)] pub fn new(on_end : Definition :: End) -> Self
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, on_end)
      } #[doc = r" Initializes a former with a coercible end condition."]
      #[inline(always)] pub fn new_coercing < IntoEnd > (end : IntoEnd) -> Self
      where IntoEnd : :: core :: convert :: Into < Definition :: End > ,
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, end,)
      }
      #[doc =
      r" Begins the formation process with specified context and termination logic."]
      #[inline(always)] pub fn
      begin(mut storage : :: core :: option :: Option < Definition :: Storage >
      , context : :: core :: option :: Option < Definition :: Context > , on_end
      : < Definition as former :: FormerDefinition > :: End,) -> Self
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option :: Some(on_end),
          }
      }
      #[doc =
      r" Starts the formation process with coercible end condition and optional initial values."]
      #[inline(always)] pub fn begin_coercing < IntoEnd >
      (mut storage : :: core :: option :: Option < Definition :: Storage > ,
      context : :: core :: option :: Option < Definition :: Context > , on_end :
      IntoEnd,) -> Self where IntoEnd : :: core :: convert :: Into < <
      Definition as former :: FormerDefinition > :: End > ,
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option ::
              Some(:: core :: convert :: Into :: into(on_end)),
          }
      }
      #[doc =
      r" Wrapper for `end` to align with common builder pattern terminologies."]
      #[inline(always)] pub fn form(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed { self.end() }
      #[doc = r" Completes the formation and returns the formed object."]
      #[inline(always)] pub fn end(mut self) -> < Definition :: Types as former
      :: FormerDefinitionTypes > :: Formed
      {
          let on_end = self.on_end.take().unwrap(); let mut context =
          self.context.take(); < Definition :: Types as former :: FormerMutator
          > :: form_mutation(& mut self.storage, & mut context); former ::
          FormingEnd :: < Definition :: Types > ::
          call(& on_end, self.storage, context)
      } #[doc = "Scalar setter for the 'name' field."] #[inline] pub fn
      name(mut self, src : & 'a str) -> Self
      {
          debug_assert! (self.storage.name.is_none()); self.storage.name = ::
          core :: option :: Option :: Some(src); self
      }
  } impl < 'a, Definition > WithLifetimeFormer < 'a, Definition > where
  Definition : former :: FormerDefinition < Storage = WithLifetimeFormerStorage
  < 'a > , Formed = WithLifetime < 'a > > , Definition :: Types : former ::
  FormerDefinitionTypes < Storage = WithLifetimeFormerStorage < 'a > , Formed =
  WithLifetime < 'a > > , Definition : former :: FormerDefinition < Storage =
  WithLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Executes the transformation from the former's storage state to the preformed object."]
      pub fn preform(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed
      { former :: StoragePreform :: preform(self.storage) }
  } #[automatically_derived] impl < 'a, Definition > WithLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  WithLifetimeFormerStorage < 'a > , Formed = WithLifetime < 'a > > , Definition
  :: Types : former :: FormerDefinitionTypes < Storage =
  WithLifetimeFormerStorage < 'a > , Formed = WithLifetime < 'a > > ,
  {
      #[doc = r" Finish setting options and call perform on formed entity."]
      #[inline(always)] pub fn perform(self) -> Definition :: Formed
      { let result = self.form(); return result; }
  } impl < 'a, Definition > former :: FormerBegin < 'a, Definition > for
  WithLifetimeFormer < 'a, Definition > where Definition : former ::
  FormerDefinition < Storage = WithLifetimeFormerStorage < 'a > > , Definition
  :: Storage : 'a, Definition :: Context : 'a, Definition :: End : 'a,
  {
      #[inline(always)] fn
      former_begin(storage : :: core :: option :: Option < Definition :: Storage
      > , context : :: core :: option :: Option < Definition :: Context > ,
      on_end : Definition :: End,) -> Self
      { Self :: begin(:: core :: option :: Option :: None, context, on_end) }
  }
  #[doc =
  r" Provides a specialized former for structure using predefined settings for superformer and end conditions."]
  pub type WithLifetimeAsSubformer < 'a, __Superformer, __End > =
  WithLifetimeFormer < 'a, WithLifetimeFormerDefinition < 'a, __Superformer,
  __Superformer, __End > > ;
  #[doc =
  "\nRepresents an end condition for former of [`$WithLifetime`], tying the lifecycle of forming processes to a broader context.\n\nThis trait is intended for use with subformer alias, ensuring that end conditions are met according to the\nspecific needs of the broader forming context. It mandates the implementation of `former::FormingEnd`.\n    "]
  pub trait WithLifetimeAsSubformerEnd < 'a, SuperFormer > where Self : former
  :: FormingEnd < WithLifetimeFormerDefinitionTypes < 'a, SuperFormer,
  SuperFormer > > {} impl < 'a, SuperFormer, __T > WithLifetimeAsSubformerEnd <
  'a, SuperFormer > for __T where Self : former :: FormingEnd <
  WithLifetimeFormerDefinitionTypes < 'a, SuperFormer, SuperFormer > > {}

Struct: MinimalLifetime
has_only_lifetimes: true
classification: GenericsClassification { lifetimes: [LifetimeParam { attrs: [], lifetime: Lifetime { apostrophe: #0 bytes(69169..69171), ident: Ident { ident: "a", span: #0 bytes(69169..69171) } }, colon_token: None, bounds: [] }], types: [], consts: [], has_only_lifetimes: true, has_only_types: false, has_only_consts: false, has_mixed: false, is_empty: false }

 = context

  derive : Former
  struct : MinimalLifetime

 = original

  #[debug] pub struct MinimalLifetime<'a> { data: &'a str, }

 = generated

  #[automatically_derived] impl < 'a > MinimalLifetime < 'a >
  {
      #[doc =
      r" Provides a mechanism to initiate the formation process with a default completion behavior."]
      #[inline(always)] pub fn former() -> MinimalLifetimeFormer < 'a,
      MinimalLifetimeFormerDefinition < 'a, (), MinimalLifetime < 'a > , former
      :: ReturnPreformed > >
      { MinimalLifetimeFormer :: begin(None, None, former :: ReturnPreformed) }
  } impl < 'a, Definition > former :: EntityToFormer < Definition > for
  MinimalLifetime < 'a > where Definition : former :: FormerDefinition < Storage
  = MinimalLifetimeFormerStorage < 'a > > ,
  { type Former = MinimalLifetimeFormer < 'a, Definition > ; } impl < 'a >
  former :: EntityToStorage for MinimalLifetime < 'a >
  { type Storage = MinimalLifetimeFormerStorage < 'a > ; } impl < 'a, __Context,
  __Formed, __End > former :: EntityToDefinition < __Context, __Formed, __End >
  for MinimalLifetime < 'a > where __End : former :: FormingEnd <
  MinimalLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > > ,
  {
      type Definition = MinimalLifetimeFormerDefinition < 'a, __Context,
      __Formed, __End > ; type Types = MinimalLifetimeFormerDefinitionTypes <
      'a, __Context, __Formed > ;
  } impl < 'a, __Context, __Formed > former :: EntityToDefinitionTypes <
  __Context, __Formed > for MinimalLifetime < 'a >
  {
      type Types = MinimalLifetimeFormerDefinitionTypes < 'a, __Context,
      __Formed > ;
  }
  #[doc =
  r" Defines the generic parameters for formation behavior including context, form, and end conditions."]
  #[derive(Debug)] pub struct MinimalLifetimeFormerDefinitionTypes < 'a,
  __Context = (), __Formed = MinimalLifetime < 'a > , >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed) > ,
  } impl < 'a, __Context, __Formed > :: core :: default :: Default for
  MinimalLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed > former :: FormerDefinitionTypes for
  MinimalLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      type Storage = MinimalLifetimeFormerStorage < 'a > ; type Formed =
      __Formed; type Context = __Context;
  } impl < 'a, __Context, __Formed > former :: FormerMutator for
  MinimalLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > where {}
  #[doc = r" Holds the definition types used during the formation process."]
  #[derive(Debug)] pub struct MinimalLifetimeFormerDefinition < 'a, __Context =
  (), __Formed = MinimalLifetime < 'a > , __End = former :: ReturnPreformed, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed, * const __End) > ,
  } impl < 'a, __Context, __Formed, __End > :: core :: default :: Default for
  MinimalLifetimeFormerDefinition < 'a, __Context, __Formed, __End >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed, __End > former :: FormerDefinition for
  MinimalLifetimeFormerDefinition < 'a, __Context, __Formed, __End > where __End
  : former :: FormingEnd < MinimalLifetimeFormerDefinitionTypes < 'a, __Context,
  __Formed > >
  {
      type Types = MinimalLifetimeFormerDefinitionTypes < 'a, __Context,
      __Formed > ; type End = __End; type Storage = MinimalLifetimeFormerStorage
      < 'a > ; type Formed = __Formed; type Context = __Context;
  } #[doc = "Stores potential values for fields during the formation process."]
  #[allow(explicit_outlives_requirements)] pub struct
  MinimalLifetimeFormerStorage < 'a, >
  { #[doc = r" A field"] pub data : :: core :: option :: Option < & 'a str > , }
  impl < 'a > :: core :: default :: Default for MinimalLifetimeFormerStorage <
  'a >
  {
      #[inline(always)] fn default() -> Self
      { Self { data : :: core :: option :: Option :: None, } }
  } impl < 'a > former :: Storage for MinimalLifetimeFormerStorage < 'a >
  { type Preformed = MinimalLifetime < 'a > ; } impl < 'a > former ::
  StoragePreform for MinimalLifetimeFormerStorage < 'a >
  {
      fn preform(mut self) -> Self :: Preformed
      {
          let data = if self.data.is_some() { self.data.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'data' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData < & 'a str > =
                  :: core :: marker :: PhantomData; (& phantom).maybe_default()
              }
          }; let result = MinimalLifetime { data, }; return result;
      }
  }
  #[doc =
  "\nStructure to form [MinimalLifetime]. Represents a forming entity designed to construct objects through a builder pattern.\n\nThis structure holds temporary storage and context during the formation process and\nutilizes a defined end strategy to finalize the object creation.\n"]
  pub struct MinimalLifetimeFormer < 'a, Definition > where Definition : former
  :: FormerDefinition < Storage = MinimalLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Temporary storage for all fields during the formation process."] pub
      storage : Definition :: Storage, #[doc = r" Optional context."] pub
      context : :: core :: option :: Option < Definition :: Context > ,
      #[doc = r" Optional handler for the end of formation."] pub on_end : ::
      core :: option :: Option < Definition :: End > ,
  } #[automatically_derived] impl < 'a, Definition > MinimalLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  MinimalLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Initializes a former with an end condition and default storage."]
      #[inline(always)] pub fn new(on_end : Definition :: End) -> Self
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, on_end)
      } #[doc = r" Initializes a former with a coercible end condition."]
      #[inline(always)] pub fn new_coercing < IntoEnd > (end : IntoEnd) -> Self
      where IntoEnd : :: core :: convert :: Into < Definition :: End > ,
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, end,)
      }
      #[doc =
      r" Begins the formation process with specified context and termination logic."]
      #[inline(always)] pub fn
      begin(mut storage : :: core :: option :: Option < Definition :: Storage >
      , context : :: core :: option :: Option < Definition :: Context > , on_end
      : < Definition as former :: FormerDefinition > :: End,) -> Self
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option :: Some(on_end),
          }
      }
      #[doc =
      r" Starts the formation process with coercible end condition and optional initial values."]
      #[inline(always)] pub fn begin_coercing < IntoEnd >
      (mut storage : :: core :: option :: Option < Definition :: Storage > ,
      context : :: core :: option :: Option < Definition :: Context > , on_end :
      IntoEnd,) -> Self where IntoEnd : :: core :: convert :: Into < <
      Definition as former :: FormerDefinition > :: End > ,
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option ::
              Some(:: core :: convert :: Into :: into(on_end)),
          }
      }
      #[doc =
      r" Wrapper for `end` to align with common builder pattern terminologies."]
      #[inline(always)] pub fn form(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed { self.end() }
      #[doc = r" Completes the formation and returns the formed object."]
      #[inline(always)] pub fn end(mut self) -> < Definition :: Types as former
      :: FormerDefinitionTypes > :: Formed
      {
          let on_end = self.on_end.take().unwrap(); let mut context =
          self.context.take(); < Definition :: Types as former :: FormerMutator
          > :: form_mutation(& mut self.storage, & mut context); former ::
          FormingEnd :: < Definition :: Types > ::
          call(& on_end, self.storage, context)
      } #[doc = "Scalar setter for the 'data' field."] #[inline] pub fn
      data(mut self, src : & 'a str) -> Self
      {
          debug_assert! (self.storage.data.is_none()); self.storage.data = ::
          core :: option :: Option :: Some(src); self
      }
  } impl < 'a, Definition > MinimalLifetimeFormer < 'a, Definition > where
  Definition : former :: FormerDefinition < Storage =
  MinimalLifetimeFormerStorage < 'a > , Formed = MinimalLifetime < 'a > > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  MinimalLifetimeFormerStorage < 'a > , Formed = MinimalLifetime < 'a > > ,
  Definition : former :: FormerDefinition < Storage =
  MinimalLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Executes the transformation from the former's storage state to the preformed object."]
      pub fn preform(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed
      { former :: StoragePreform :: preform(self.storage) }
  } #[automatically_derived] impl < 'a, Definition > MinimalLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  MinimalLifetimeFormerStorage < 'a > , Formed = MinimalLifetime < 'a > > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  MinimalLifetimeFormerStorage < 'a > , Formed = MinimalLifetime < 'a > > ,
  {
      #[doc = r" Finish setting options and call perform on formed entity."]
      #[inline(always)] pub fn perform(self) -> Definition :: Formed
      { let result = self.form(); return result; }
  } impl < 'a, Definition > former :: FormerBegin < 'a, Definition > for
  MinimalLifetimeFormer < 'a, Definition > where Definition : former ::
  FormerDefinition < Storage = MinimalLifetimeFormerStorage < 'a > > ,
  Definition :: Storage : 'a, Definition :: Context : 'a, Definition :: End :
  'a,
  {
      #[inline(always)] fn
      former_begin(storage : :: core :: option :: Option < Definition :: Storage
      > , context : :: core :: option :: Option < Definition :: Context > ,
      on_end : Definition :: End,) -> Self
      { Self :: begin(:: core :: option :: Option :: None, context, on_end) }
  }
  #[doc =
  r" Provides a specialized former for structure using predefined settings for superformer and end conditions."]
  pub type MinimalLifetimeAsSubformer < 'a, __Superformer, __End > =
  MinimalLifetimeFormer < 'a, MinimalLifetimeFormerDefinition < 'a,
  __Superformer, __Superformer, __End > > ;
  #[doc =
  "\nRepresents an end condition for former of [`$MinimalLifetime`], tying the lifecycle of forming processes to a broader context.\n\nThis trait is intended for use with subformer alias, ensuring that end conditions are met according to the\nspecific needs of the broader forming context. It mandates the implementation of `former::FormingEnd`.\n    "]
  pub trait MinimalLifetimeAsSubformerEnd < 'a, SuperFormer > where Self :
  former :: FormingEnd < MinimalLifetimeFormerDefinitionTypes < 'a, SuperFormer,
  SuperFormer > > {} impl < 'a, SuperFormer, __T > MinimalLifetimeAsSubformerEnd
  < 'a, SuperFormer > for __T where Self : former :: FormingEnd <
  MinimalLifetimeFormerDefinitionTypes < 'a, SuperFormer, SuperFormer > > {}


 = context

  derive : Former
  structure : MinimalLifetime

 = original

  #[debug] pub struct MinimalLifetime<'a> { data: &'a str, }

 = generated

  #[automatically_derived] impl < 'a > MinimalLifetime < 'a >
  {
      #[doc =
      r" Provides a mechanism to initiate the formation process with a default completion behavior."]
      #[inline(always)] pub fn former() -> MinimalLifetimeFormer < 'a,
      MinimalLifetimeFormerDefinition < 'a, (), MinimalLifetime < 'a > , former
      :: ReturnPreformed > >
      { MinimalLifetimeFormer :: begin(None, None, former :: ReturnPreformed) }
  } impl < 'a, Definition > former :: EntityToFormer < Definition > for
  MinimalLifetime < 'a > where Definition : former :: FormerDefinition < Storage
  = MinimalLifetimeFormerStorage < 'a > > ,
  { type Former = MinimalLifetimeFormer < 'a, Definition > ; } impl < 'a >
  former :: EntityToStorage for MinimalLifetime < 'a >
  { type Storage = MinimalLifetimeFormerStorage < 'a > ; } impl < 'a, __Context,
  __Formed, __End > former :: EntityToDefinition < __Context, __Formed, __End >
  for MinimalLifetime < 'a > where __End : former :: FormingEnd <
  MinimalLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > > ,
  {
      type Definition = MinimalLifetimeFormerDefinition < 'a, __Context,
      __Formed, __End > ; type Types = MinimalLifetimeFormerDefinitionTypes <
      'a, __Context, __Formed > ;
  } impl < 'a, __Context, __Formed > former :: EntityToDefinitionTypes <
  __Context, __Formed > for MinimalLifetime < 'a >
  {
      type Types = MinimalLifetimeFormerDefinitionTypes < 'a, __Context,
      __Formed > ;
  }
  #[doc =
  r" Defines the generic parameters for formation behavior including context, form, and end conditions."]
  #[derive(Debug)] pub struct MinimalLifetimeFormerDefinitionTypes < 'a,
  __Context = (), __Formed = MinimalLifetime < 'a > , >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed) > ,
  } impl < 'a, __Context, __Formed > :: core :: default :: Default for
  MinimalLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed > former :: FormerDefinitionTypes for
  MinimalLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      type Storage = MinimalLifetimeFormerStorage < 'a > ; type Formed =
      __Formed; type Context = __Context;
  } impl < 'a, __Context, __Formed > former :: FormerMutator for
  MinimalLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > where {}
  #[doc = r" Holds the definition types used during the formation process."]
  #[derive(Debug)] pub struct MinimalLifetimeFormerDefinition < 'a, __Context =
  (), __Formed = MinimalLifetime < 'a > , __End = former :: ReturnPreformed, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed, * const __End) > ,
  } impl < 'a, __Context, __Formed, __End > :: core :: default :: Default for
  MinimalLifetimeFormerDefinition < 'a, __Context, __Formed, __End >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed, __End > former :: FormerDefinition for
  MinimalLifetimeFormerDefinition < 'a, __Context, __Formed, __End > where __End
  : former :: FormingEnd < MinimalLifetimeFormerDefinitionTypes < 'a, __Context,
  __Formed > >
  {
      type Types = MinimalLifetimeFormerDefinitionTypes < 'a, __Context,
      __Formed > ; type End = __End; type Storage = MinimalLifetimeFormerStorage
      < 'a > ; type Formed = __Formed; type Context = __Context;
  } #[doc = "Stores potential values for fields during the formation process."]
  #[allow(explicit_outlives_requirements)] pub struct
  MinimalLifetimeFormerStorage < 'a, >
  { #[doc = r" A field"] pub data : :: core :: option :: Option < & 'a str > , }
  impl < 'a > :: core :: default :: Default for MinimalLifetimeFormerStorage <
  'a >
  {
      #[inline(always)] fn default() -> Self
      { Self { data : :: core :: option :: Option :: None, } }
  } impl < 'a > former :: Storage for MinimalLifetimeFormerStorage < 'a >
  { type Preformed = MinimalLifetime < 'a > ; } impl < 'a > former ::
  StoragePreform for MinimalLifetimeFormerStorage < 'a >
  {
      fn preform(mut self) -> Self :: Preformed
      {
          let data = if self.data.is_some() { self.data.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'data' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData < & 'a str > =
                  :: core :: marker :: PhantomData; (& phantom).maybe_default()
              }
          }; let result = MinimalLifetime { data, }; return result;
      }
  }
  #[doc =
  "\nStructure to form [MinimalLifetime]. Represents a forming entity designed to construct objects through a builder pattern.\n\nThis structure holds temporary storage and context during the formation process and\nutilizes a defined end strategy to finalize the object creation.\n"]
  pub struct MinimalLifetimeFormer < 'a, Definition > where Definition : former
  :: FormerDefinition < Storage = MinimalLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Temporary storage for all fields during the formation process."] pub
      storage : Definition :: Storage, #[doc = r" Optional context."] pub
      context : :: core :: option :: Option < Definition :: Context > ,
      #[doc = r" Optional handler for the end of formation."] pub on_end : ::
      core :: option :: Option < Definition :: End > ,
  } #[automatically_derived] impl < 'a, Definition > MinimalLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  MinimalLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Initializes a former with an end condition and default storage."]
      #[inline(always)] pub fn new(on_end : Definition :: End) -> Self
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, on_end)
      } #[doc = r" Initializes a former with a coercible end condition."]
      #[inline(always)] pub fn new_coercing < IntoEnd > (end : IntoEnd) -> Self
      where IntoEnd : :: core :: convert :: Into < Definition :: End > ,
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, end,)
      }
      #[doc =
      r" Begins the formation process with specified context and termination logic."]
      #[inline(always)] pub fn
      begin(mut storage : :: core :: option :: Option < Definition :: Storage >
      , context : :: core :: option :: Option < Definition :: Context > , on_end
      : < Definition as former :: FormerDefinition > :: End,) -> Self
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option :: Some(on_end),
          }
      }
      #[doc =
      r" Starts the formation process with coercible end condition and optional initial values."]
      #[inline(always)] pub fn begin_coercing < IntoEnd >
      (mut storage : :: core :: option :: Option < Definition :: Storage > ,
      context : :: core :: option :: Option < Definition :: Context > , on_end :
      IntoEnd,) -> Self where IntoEnd : :: core :: convert :: Into < <
      Definition as former :: FormerDefinition > :: End > ,
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option ::
              Some(:: core :: convert :: Into :: into(on_end)),
          }
      }
      #[doc =
      r" Wrapper for `end` to align with common builder pattern terminologies."]
      #[inline(always)] pub fn form(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed { self.end() }
      #[doc = r" Completes the formation and returns the formed object."]
      #[inline(always)] pub fn end(mut self) -> < Definition :: Types as former
      :: FormerDefinitionTypes > :: Formed
      {
          let on_end = self.on_end.take().unwrap(); let mut context =
          self.context.take(); < Definition :: Types as former :: FormerMutator
          > :: form_mutation(& mut self.storage, & mut context); former ::
          FormingEnd :: < Definition :: Types > ::
          call(& on_end, self.storage, context)
      } #[doc = "Scalar setter for the 'data' field."] #[inline] pub fn
      data(mut self, src : & 'a str) -> Self
      {
          debug_assert! (self.storage.data.is_none()); self.storage.data = ::
          core :: option :: Option :: Some(src); self
      }
  } impl < 'a, Definition > MinimalLifetimeFormer < 'a, Definition > where
  Definition : former :: FormerDefinition < Storage =
  MinimalLifetimeFormerStorage < 'a > , Formed = MinimalLifetime < 'a > > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  MinimalLifetimeFormerStorage < 'a > , Formed = MinimalLifetime < 'a > > ,
  Definition : former :: FormerDefinition < Storage =
  MinimalLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Executes the transformation from the former's storage state to the preformed object."]
      pub fn preform(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed
      { former :: StoragePreform :: preform(self.storage) }
  } #[automatically_derived] impl < 'a, Definition > MinimalLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  MinimalLifetimeFormerStorage < 'a > , Formed = MinimalLifetime < 'a > > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  MinimalLifetimeFormerStorage < 'a > , Formed = MinimalLifetime < 'a > > ,
  {
      #[doc = r" Finish setting options and call perform on formed entity."]
      #[inline(always)] pub fn perform(self) -> Definition :: Formed
      { let result = self.form(); return result; }
  } impl < 'a, Definition > former :: FormerBegin < 'a, Definition > for
  MinimalLifetimeFormer < 'a, Definition > where Definition : former ::
  FormerDefinition < Storage = MinimalLifetimeFormerStorage < 'a > > ,
  Definition :: Storage : 'a, Definition :: Context : 'a, Definition :: End :
  'a,
  {
      #[inline(always)] fn
      former_begin(storage : :: core :: option :: Option < Definition :: Storage
      > , context : :: core :: option :: Option < Definition :: Context > ,
      on_end : Definition :: End,) -> Self
      { Self :: begin(:: core :: option :: Option :: None, context, on_end) }
  }
  #[doc =
  r" Provides a specialized former for structure using predefined settings for superformer and end conditions."]
  pub type MinimalLifetimeAsSubformer < 'a, __Superformer, __End > =
  MinimalLifetimeFormer < 'a, MinimalLifetimeFormerDefinition < 'a,
  __Superformer, __Superformer, __End > > ;
  #[doc =
  "\nRepresents an end condition for former of [`$MinimalLifetime`], tying the lifecycle of forming processes to a broader context.\n\nThis trait is intended for use with subformer alias, ensuring that end conditions are met according to the\nspecific needs of the broader forming context. It mandates the implementation of `former::FormingEnd`.\n    "]
  pub trait MinimalLifetimeAsSubformerEnd < 'a, SuperFormer > where Self :
  former :: FormingEnd < MinimalLifetimeFormerDefinitionTypes < 'a, SuperFormer,
  SuperFormer > > {} impl < 'a, SuperFormer, __T > MinimalLifetimeAsSubformerEnd
  < 'a, SuperFormer > for __T where Self : former :: FormingEnd <
  MinimalLifetimeFormerDefinitionTypes < 'a, SuperFormer, SuperFormer > > {}

Struct: SimpleLifetime
has_only_lifetimes: true
classification: GenericsClassification { lifetimes: [LifetimeParam { attrs: [], lifetime: Lifetime { apostrophe: #0 bytes(69369..69371), ident: Ident { ident: "a", span: #0 bytes(69369..69371) } }, colon_token: None, bounds: [] }], types: [], consts: [], has_only_lifetimes: true, has_only_types: false, has_only_consts: false, has_mixed: false, is_empty: false }

 = context

  derive : Former
  struct : SimpleLifetime

 = original

  #[debug] pub struct SimpleLifetime<'a> { data: &'a str, }

 = generated

  #[automatically_derived] impl < 'a > SimpleLifetime < 'a >
  {
      #[doc =
      r" Provides a mechanism to initiate the formation process with a default completion behavior."]
      #[inline(always)] pub fn former() -> SimpleLifetimeFormer < 'a,
      SimpleLifetimeFormerDefinition < 'a, (), SimpleLifetime < 'a > , former ::
      ReturnPreformed > >
      { SimpleLifetimeFormer :: begin(None, None, former :: ReturnPreformed) }
  } impl < 'a, Definition > former :: EntityToFormer < Definition > for
  SimpleLifetime < 'a > where Definition : former :: FormerDefinition < Storage
  = SimpleLifetimeFormerStorage < 'a > > ,
  { type Former = SimpleLifetimeFormer < 'a, Definition > ; } impl < 'a > former
  :: EntityToStorage for SimpleLifetime < 'a >
  { type Storage = SimpleLifetimeFormerStorage < 'a > ; } impl < 'a, __Context,
  __Formed, __End > former :: EntityToDefinition < __Context, __Formed, __End >
  for SimpleLifetime < 'a > where __End : former :: FormingEnd <
  SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > > ,
  {
      type Definition = SimpleLifetimeFormerDefinition < 'a, __Context,
      __Formed, __End > ; type Types = SimpleLifetimeFormerDefinitionTypes < 'a,
      __Context, __Formed > ;
  } impl < 'a, __Context, __Formed > former :: EntityToDefinitionTypes <
  __Context, __Formed > for SimpleLifetime < 'a >
  {
      type Types = SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed
      > ;
  }
  #[doc =
  r" Defines the generic parameters for formation behavior including context, form, and end conditions."]
  #[derive(Debug)] pub struct SimpleLifetimeFormerDefinitionTypes < 'a,
  __Context = (), __Formed = SimpleLifetime < 'a > , >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed) > ,
  } impl < 'a, __Context, __Formed > :: core :: default :: Default for
  SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed > former :: FormerDefinitionTypes for
  SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      type Storage = SimpleLifetimeFormerStorage < 'a > ; type Formed =
      __Formed; type Context = __Context;
  } impl < 'a, __Context, __Formed > former :: FormerMutator for
  SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > where {}
  #[doc = r" Holds the definition types used during the formation process."]
  #[derive(Debug)] pub struct SimpleLifetimeFormerDefinition < 'a, __Context =
  (), __Formed = SimpleLifetime < 'a > , __End = former :: ReturnPreformed, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed, * const __End) > ,
  } impl < 'a, __Context, __Formed, __End > :: core :: default :: Default for
  SimpleLifetimeFormerDefinition < 'a, __Context, __Formed, __End >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed, __End > former :: FormerDefinition for
  SimpleLifetimeFormerDefinition < 'a, __Context, __Formed, __End > where __End
  : former :: FormingEnd < SimpleLifetimeFormerDefinitionTypes < 'a, __Context,
  __Formed > >
  {
      type Types = SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed
      > ; type End = __End; type Storage = SimpleLifetimeFormerStorage < 'a > ;
      type Formed = __Formed; type Context = __Context;
  } #[doc = "Stores potential values for fields during the formation process."]
  #[allow(explicit_outlives_requirements)] pub struct
  SimpleLifetimeFormerStorage < 'a, >
  { #[doc = r" A field"] pub data : :: core :: option :: Option < & 'a str > , }
  impl < 'a > :: core :: default :: Default for SimpleLifetimeFormerStorage < 'a
  >
  {
      #[inline(always)] fn default() -> Self
      { Self { data : :: core :: option :: Option :: None, } }
  } impl < 'a > former :: Storage for SimpleLifetimeFormerStorage < 'a >
  { type Preformed = SimpleLifetime < 'a > ; } impl < 'a > former ::
  StoragePreform for SimpleLifetimeFormerStorage < 'a >
  {
      fn preform(mut self) -> Self :: Preformed
      {
          let data = if self.data.is_some() { self.data.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'data' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData < & 'a str > =
                  :: core :: marker :: PhantomData; (& phantom).maybe_default()
              }
          }; let result = SimpleLifetime { data, }; return result;
      }
  }
  #[doc =
  "\nStructure to form [SimpleLifetime]. Represents a forming entity designed to construct objects through a builder pattern.\n\nThis structure holds temporary storage and context during the formation process and\nutilizes a defined end strategy to finalize the object creation.\n"]
  pub struct SimpleLifetimeFormer < 'a, Definition > where Definition : former
  :: FormerDefinition < Storage = SimpleLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Temporary storage for all fields during the formation process."] pub
      storage : Definition :: Storage, #[doc = r" Optional context."] pub
      context : :: core :: option :: Option < Definition :: Context > ,
      #[doc = r" Optional handler for the end of formation."] pub on_end : ::
      core :: option :: Option < Definition :: End > ,
  } #[automatically_derived] impl < 'a, Definition > SimpleLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  SimpleLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Initializes a former with an end condition and default storage."]
      #[inline(always)] pub fn new(on_end : Definition :: End) -> Self
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, on_end)
      } #[doc = r" Initializes a former with a coercible end condition."]
      #[inline(always)] pub fn new_coercing < IntoEnd > (end : IntoEnd) -> Self
      where IntoEnd : :: core :: convert :: Into < Definition :: End > ,
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, end,)
      }
      #[doc =
      r" Begins the formation process with specified context and termination logic."]
      #[inline(always)] pub fn
      begin(mut storage : :: core :: option :: Option < Definition :: Storage >
      , context : :: core :: option :: Option < Definition :: Context > , on_end
      : < Definition as former :: FormerDefinition > :: End,) -> Self
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option :: Some(on_end),
          }
      }
      #[doc =
      r" Starts the formation process with coercible end condition and optional initial values."]
      #[inline(always)] pub fn begin_coercing < IntoEnd >
      (mut storage : :: core :: option :: Option < Definition :: Storage > ,
      context : :: core :: option :: Option < Definition :: Context > , on_end :
      IntoEnd,) -> Self where IntoEnd : :: core :: convert :: Into < <
      Definition as former :: FormerDefinition > :: End > ,
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option ::
              Some(:: core :: convert :: Into :: into(on_end)),
          }
      }
      #[doc =
      r" Wrapper for `end` to align with common builder pattern terminologies."]
      #[inline(always)] pub fn form(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed { self.end() }
      #[doc = r" Completes the formation and returns the formed object."]
      #[inline(always)] pub fn end(mut self) -> < Definition :: Types as former
      :: FormerDefinitionTypes > :: Formed
      {
          let on_end = self.on_end.take().unwrap(); let mut context =
          self.context.take(); < Definition :: Types as former :: FormerMutator
          > :: form_mutation(& mut self.storage, & mut context); former ::
          FormingEnd :: < Definition :: Types > ::
          call(& on_end, self.storage, context)
      } #[doc = "Scalar setter for the 'data' field."] #[inline] pub fn
      data(mut self, src : & 'a str) -> Self
      {
          debug_assert! (self.storage.data.is_none()); self.storage.data = ::
          core :: option :: Option :: Some(src); self
      }
  } impl < 'a, Definition > SimpleLifetimeFormer < 'a, Definition > where
  Definition : former :: FormerDefinition < Storage =
  SimpleLifetimeFormerStorage < 'a > , Formed = SimpleLifetime < 'a > > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  SimpleLifetimeFormerStorage < 'a > , Formed = SimpleLifetime < 'a > > ,
  Definition : former :: FormerDefinition < Storage =
  SimpleLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Executes the transformation from the former's storage state to the preformed object."]
      pub fn preform(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed
      { former :: StoragePreform :: preform(self.storage) }
  } #[automatically_derived] impl < 'a, Definition > SimpleLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  SimpleLifetimeFormerStorage < 'a > , Formed = SimpleLifetime < 'a > > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  SimpleLifetimeFormerStorage < 'a > , Formed = SimpleLifetime < 'a > > ,
  {
      #[doc = r" Finish setting options and call perform on formed entity."]
      #[inline(always)] pub fn perform(self) -> Definition :: Formed
      { let result = self.form(); return result; }
  } impl < 'a, Definition > former :: FormerBegin < 'a, Definition > for
  SimpleLifetimeFormer < 'a, Definition > where Definition : former ::
  FormerDefinition < Storage = SimpleLifetimeFormerStorage < 'a > > , Definition
  :: Storage : 'a, Definition :: Context : 'a, Definition :: End : 'a,
  {
      #[inline(always)] fn
      former_begin(storage : :: core :: option :: Option < Definition :: Storage
      > , context : :: core :: option :: Option < Definition :: Context > ,
      on_end : Definition :: End,) -> Self
      { Self :: begin(:: core :: option :: Option :: None, context, on_end) }
  }
  #[doc =
  r" Provides a specialized former for structure using predefined settings for superformer and end conditions."]
  pub type SimpleLifetimeAsSubformer < 'a, __Superformer, __End > =
  SimpleLifetimeFormer < 'a, SimpleLifetimeFormerDefinition < 'a, __Superformer,
  __Superformer, __End > > ;
  #[doc =
  "\nRepresents an end condition for former of [`$SimpleLifetime`], tying the lifecycle of forming processes to a broader context.\n\nThis trait is intended for use with subformer alias, ensuring that end conditions are met according to the\nspecific needs of the broader forming context. It mandates the implementation of `former::FormingEnd`.\n    "]
  pub trait SimpleLifetimeAsSubformerEnd < 'a, SuperFormer > where Self : former
  :: FormingEnd < SimpleLifetimeFormerDefinitionTypes < 'a, SuperFormer,
  SuperFormer > > {} impl < 'a, SuperFormer, __T > SimpleLifetimeAsSubformerEnd
  < 'a, SuperFormer > for __T where Self : former :: FormingEnd <
  SimpleLifetimeFormerDefinitionTypes < 'a, SuperFormer, SuperFormer > > {}


 = context

  derive : Former
  structure : SimpleLifetime

 = original

  #[debug] pub struct SimpleLifetime<'a> { data: &'a str, }

 = generated

  #[automatically_derived] impl < 'a > SimpleLifetime < 'a >
  {
      #[doc =
      r" Provides a mechanism to initiate the formation process with a default completion behavior."]
      #[inline(always)] pub fn former() -> SimpleLifetimeFormer < 'a,
      SimpleLifetimeFormerDefinition < 'a, (), SimpleLifetime < 'a > , former ::
      ReturnPreformed > >
      { SimpleLifetimeFormer :: begin(None, None, former :: ReturnPreformed) }
  } impl < 'a, Definition > former :: EntityToFormer < Definition > for
  SimpleLifetime < 'a > where Definition : former :: FormerDefinition < Storage
  = SimpleLifetimeFormerStorage < 'a > > ,
  { type Former = SimpleLifetimeFormer < 'a, Definition > ; } impl < 'a > former
  :: EntityToStorage for SimpleLifetime < 'a >
  { type Storage = SimpleLifetimeFormerStorage < 'a > ; } impl < 'a, __Context,
  __Formed, __End > former :: EntityToDefinition < __Context, __Formed, __End >
  for SimpleLifetime < 'a > where __End : former :: FormingEnd <
  SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > > ,
  {
      type Definition = SimpleLifetimeFormerDefinition < 'a, __Context,
      __Formed, __End > ; type Types = SimpleLifetimeFormerDefinitionTypes < 'a,
      __Context, __Formed > ;
  } impl < 'a, __Context, __Formed > former :: EntityToDefinitionTypes <
  __Context, __Formed > for SimpleLifetime < 'a >
  {
      type Types = SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed
      > ;
  }
  #[doc =
  r" Defines the generic parameters for formation behavior including context, form, and end conditions."]
  #[derive(Debug)] pub struct SimpleLifetimeFormerDefinitionTypes < 'a,
  __Context = (), __Formed = SimpleLifetime < 'a > , >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed) > ,
  } impl < 'a, __Context, __Formed > :: core :: default :: Default for
  SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed > former :: FormerDefinitionTypes for
  SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed >
  {
      type Storage = SimpleLifetimeFormerStorage < 'a > ; type Formed =
      __Formed; type Context = __Context;
  } impl < 'a, __Context, __Formed > former :: FormerMutator for
  SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed > where {}
  #[doc = r" Holds the definition types used during the formation process."]
  #[derive(Debug)] pub struct SimpleLifetimeFormerDefinition < 'a, __Context =
  (), __Formed = SimpleLifetime < 'a > , __End = former :: ReturnPreformed, >
  {
      _phantom : :: core :: marker :: PhantomData <
      (& 'a (), * const __Context, * const __Formed, * const __End) > ,
  } impl < 'a, __Context, __Formed, __End > :: core :: default :: Default for
  SimpleLifetimeFormerDefinition < 'a, __Context, __Formed, __End >
  {
      fn default() -> Self
      { Self { _phantom : :: core :: marker :: PhantomData, } }
  } impl < 'a, __Context, __Formed, __End > former :: FormerDefinition for
  SimpleLifetimeFormerDefinition < 'a, __Context, __Formed, __End > where __End
  : former :: FormingEnd < SimpleLifetimeFormerDefinitionTypes < 'a, __Context,
  __Formed > >
  {
      type Types = SimpleLifetimeFormerDefinitionTypes < 'a, __Context, __Formed
      > ; type End = __End; type Storage = SimpleLifetimeFormerStorage < 'a > ;
      type Formed = __Formed; type Context = __Context;
  } #[doc = "Stores potential values for fields during the formation process."]
  #[allow(explicit_outlives_requirements)] pub struct
  SimpleLifetimeFormerStorage < 'a, >
  { #[doc = r" A field"] pub data : :: core :: option :: Option < & 'a str > , }
  impl < 'a > :: core :: default :: Default for SimpleLifetimeFormerStorage < 'a
  >
  {
      #[inline(always)] fn default() -> Self
      { Self { data : :: core :: option :: Option :: None, } }
  } impl < 'a > former :: Storage for SimpleLifetimeFormerStorage < 'a >
  { type Preformed = SimpleLifetime < 'a > ; } impl < 'a > former ::
  StoragePreform for SimpleLifetimeFormerStorage < 'a >
  {
      fn preform(mut self) -> Self :: Preformed
      {
          let data = if self.data.is_some() { self.data.take().unwrap() } else
          {
              {
                  trait MaybeDefault < T >
                  {
                      fn maybe_default(self : & Self) -> T
                      { panic! ("Field 'data' isn't initialized") }
                  } impl < T > MaybeDefault < T > for & :: core :: marker ::
                  PhantomData < T > {} impl < T > MaybeDefault < T > for :: core
                  :: marker :: PhantomData < T > where T : :: core :: default ::
                  Default,
                  { fn maybe_default(self : & Self) -> T { T :: default() } }
                  let phantom : :: core :: marker :: PhantomData < & 'a str > =
                  :: core :: marker :: PhantomData; (& phantom).maybe_default()
              }
          }; let result = SimpleLifetime { data, }; return result;
      }
  }
  #[doc =
  "\nStructure to form [SimpleLifetime]. Represents a forming entity designed to construct objects through a builder pattern.\n\nThis structure holds temporary storage and context during the formation process and\nutilizes a defined end strategy to finalize the object creation.\n"]
  pub struct SimpleLifetimeFormer < 'a, Definition > where Definition : former
  :: FormerDefinition < Storage = SimpleLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Temporary storage for all fields during the formation process."] pub
      storage : Definition :: Storage, #[doc = r" Optional context."] pub
      context : :: core :: option :: Option < Definition :: Context > ,
      #[doc = r" Optional handler for the end of formation."] pub on_end : ::
      core :: option :: Option < Definition :: End > ,
  } #[automatically_derived] impl < 'a, Definition > SimpleLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  SimpleLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Initializes a former with an end condition and default storage."]
      #[inline(always)] pub fn new(on_end : Definition :: End) -> Self
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, on_end)
      } #[doc = r" Initializes a former with a coercible end condition."]
      #[inline(always)] pub fn new_coercing < IntoEnd > (end : IntoEnd) -> Self
      where IntoEnd : :: core :: convert :: Into < Definition :: End > ,
      {
          Self ::
          begin_coercing(:: core :: option :: Option :: None, :: core :: option
          :: Option :: None, end,)
      }
      #[doc =
      r" Begins the formation process with specified context and termination logic."]
      #[inline(always)] pub fn
      begin(mut storage : :: core :: option :: Option < Definition :: Storage >
      , context : :: core :: option :: Option < Definition :: Context > , on_end
      : < Definition as former :: FormerDefinition > :: End,) -> Self
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option :: Some(on_end),
          }
      }
      #[doc =
      r" Starts the formation process with coercible end condition and optional initial values."]
      #[inline(always)] pub fn begin_coercing < IntoEnd >
      (mut storage : :: core :: option :: Option < Definition :: Storage > ,
      context : :: core :: option :: Option < Definition :: Context > , on_end :
      IntoEnd,) -> Self where IntoEnd : :: core :: convert :: Into < <
      Definition as former :: FormerDefinition > :: End > ,
      {
          if storage.is_none()
          {
              storage = :: core :: option :: Option ::
              Some(:: core :: default :: Default :: default());
          } Self
          {
              storage : storage.unwrap(), context : context, on_end : :: core ::
              option :: Option ::
              Some(:: core :: convert :: Into :: into(on_end)),
          }
      }
      #[doc =
      r" Wrapper for `end` to align with common builder pattern terminologies."]
      #[inline(always)] pub fn form(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed { self.end() }
      #[doc = r" Completes the formation and returns the formed object."]
      #[inline(always)] pub fn end(mut self) -> < Definition :: Types as former
      :: FormerDefinitionTypes > :: Formed
      {
          let on_end = self.on_end.take().unwrap(); let mut context =
          self.context.take(); < Definition :: Types as former :: FormerMutator
          > :: form_mutation(& mut self.storage, & mut context); former ::
          FormingEnd :: < Definition :: Types > ::
          call(& on_end, self.storage, context)
      } #[doc = "Scalar setter for the 'data' field."] #[inline] pub fn
      data(mut self, src : & 'a str) -> Self
      {
          debug_assert! (self.storage.data.is_none()); self.storage.data = ::
          core :: option :: Option :: Some(src); self
      }
  } impl < 'a, Definition > SimpleLifetimeFormer < 'a, Definition > where
  Definition : former :: FormerDefinition < Storage =
  SimpleLifetimeFormerStorage < 'a > , Formed = SimpleLifetime < 'a > > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  SimpleLifetimeFormerStorage < 'a > , Formed = SimpleLifetime < 'a > > ,
  Definition : former :: FormerDefinition < Storage =
  SimpleLifetimeFormerStorage < 'a > >
  {
      #[doc =
      r" Executes the transformation from the former's storage state to the preformed object."]
      pub fn preform(self) -> < Definition :: Types as former ::
      FormerDefinitionTypes > :: Formed
      { former :: StoragePreform :: preform(self.storage) }
  } #[automatically_derived] impl < 'a, Definition > SimpleLifetimeFormer < 'a,
  Definition > where Definition : former :: FormerDefinition < Storage =
  SimpleLifetimeFormerStorage < 'a > , Formed = SimpleLifetime < 'a > > ,
  Definition :: Types : former :: FormerDefinitionTypes < Storage =
  SimpleLifetimeFormerStorage < 'a > , Formed = SimpleLifetime < 'a > > ,
  {
      #[doc = r" Finish setting options and call perform on formed entity."]
      #[inline(always)] pub fn perform(self) -> Definition :: Formed
      { let result = self.form(); return result; }
  } impl < 'a, Definition > former :: FormerBegin < 'a, Definition > for
  SimpleLifetimeFormer < 'a, Definition > where Definition : former ::
  FormerDefinition < Storage = SimpleLifetimeFormerStorage < 'a > > , Definition
  :: Storage : 'a, Definition :: Context : 'a, Definition :: End : 'a,
  {
      #[inline(always)] fn
      former_begin(storage : :: core :: option :: Option < Definition :: Storage
      > , context : :: core :: option :: Option < Definition :: Context > ,
      on_end : Definition :: End,) -> Self
      { Self :: begin(:: core :: option :: Option :: None, context, on_end) }
  }
  #[doc =
  r" Provides a specialized former for structure using predefined settings for superformer and end conditions."]
  pub type SimpleLifetimeAsSubformer < 'a, __Superformer, __End > =
  SimpleLifetimeFormer < 'a, SimpleLifetimeFormerDefinition < 'a, __Superformer,
  __Superformer, __End > > ;
  #[doc =
  "\nRepresents an end condition for former of [`$SimpleLifetime`], tying the lifecycle of forming processes to a broader context.\n\nThis trait is intended for use with subformer alias, ensuring that end conditions are met according to the\nspecific needs of the broader forming context. It mandates the implementation of `former::FormingEnd`.\n    "]
  pub trait SimpleLifetimeAsSubformerEnd < 'a, SuperFormer > where Self : former
  :: FormingEnd < SimpleLifetimeFormerDefinitionTypes < 'a, SuperFormer,
  SuperFormer > > {} impl < 'a, SuperFormer, __T > SimpleLifetimeAsSubformerEnd
  < 'a, SuperFormer > for __T where Self : former :: FormingEnd <
  SimpleLifetimeFormerDefinitionTypes < 'a, SuperFormer, SuperFormer > > {}

error[E0412]: cannot find type `K` in this scope
  --> module/core/former/tests/inc/struct_tests/parametrized_struct_imm.rs:29:18
   |
29 | pub struct Child<K: core::hash::Hash + core::cmp::Eq> {
   |                  ^ not found in this scope

error[E0412]: cannot find type `K` in this scope
  --> module/core/former/tests/inc/struct_tests/parametrized_struct_imm.rs:32:45
   |
32 |   pub properties: collection_tools::HashMap<K, Property<K>>,
   |                                             ^ not found in this scope

error[E0412]: cannot find type `K` in this scope
  --> module/core/former/tests/inc/struct_tests/parametrized_struct_imm.rs:32:57
   |
32 |   pub properties: collection_tools::HashMap<K, Property<K>>,
   |                                                         ^ not found in this scope

error[E0277]: the trait bound `K: Hash` is not satisfied
  --> module/core/former/tests/inc/struct_tests/parametrized_struct_imm.rs:26:28
   |
26 | #[derive(Debug, PartialEq, the_module::Former)]
   |                            ^^^^^^^^^^^^^^^^^^ the trait `Hash` is not implemented for `K`
   |
note: required for `parametrized_struct_imm::ChildFormerDefinitionTypes<K, SuperFormer, SuperFormer>` to implement `FormerDefinitionTypes`
  --> module/core/former/tests/inc/struct_tests/parametrized_struct_imm.rs:26:28
   |
26 | #[derive(Debug, PartialEq, the_module::Former)]
   |                            ^^^^^^^^^^^^^^^^^^
...
29 | pub struct Child<K: core::hash::Hash + core::cmp::Eq> {
   |                     ---------------- unsatisfied trait bound introduced in this `derive` macro
note: required by a bound in `FormingEnd`
  --> /home/user1/pro/lib/wTools/module/core/former_types/src/forming.rs:59:36
   |
59 | pub trait FormingEnd< Definition : crate::FormerDefinitionTypes >
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `FormingEnd`
   = note: this error originates in the derive macro `the_module::Former` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `K: std::cmp::Eq` is not satisfied
  --> module/core/former/tests/inc/struct_tests/parametrized_struct_imm.rs:26:28
   |
26 | #[derive(Debug, PartialEq, the_module::Former)]
   |                            ^^^^^^^^^^^^^^^^^^ the trait `std::cmp::Eq` is not implemented for `K`
   |
note: required for `parametrized_struct_imm::ChildFormerDefinitionTypes<K, SuperFormer, SuperFormer>` to implement `FormerDefinitionTypes`
  --> module/core/former/tests/inc/struct_tests/parametrized_struct_imm.rs:26:28
   |
26 | #[derive(Debug, PartialEq, the_module::Former)]
   |                            ^^^^^^^^^^^^^^^^^^
...
29 | pub struct Child<K: core::hash::Hash + core::cmp::Eq> {
   |                                        ------------- unsatisfied trait bound introduced in this `derive` macro
note: required by a bound in `FormingEnd`
  --> /home/user1/pro/lib/wTools/module/core/former_types/src/forming.rs:59:36
   |
59 | pub trait FormingEnd< Definition : crate::FormerDefinitionTypes >
   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `FormingEnd`
   = note: this error originates in the derive macro `the_module::Former` (in Nightly builds, run with -Z macro-backtrace for more info)

Some errors have detailed explanations: E0277, E0412.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `former` (test "tests") due to 5 previous errors
