#[ allow( unused_imports ) ]
use super::*;

#[ derive( Debug, PartialEq ) ]
pub struct Struct1
{
  pub int_1 : i32,
  string_1 : String,
  int_optional_1 : core::option::Option< i32 >,
  string_optional_1 : Option< String >,
}

//

// generated by former
impl Struct1
{
  pub fn former() -> Struct1Former< Struct1, the_module::ReturnStorage >
  {
    Struct1Former::< Struct1, the_module::ReturnStorage >::new()
  }
}

//

// generated by former
pub struct Struct1FormerStorage
{
  pub int_1 : core::option::Option< i32 >,
  pub string_1 : core::option::Option< String >,
  pub int_optional_1 :  core::option::Option< i32 >,
  pub string_optional_1 : core::option::Option< String >,
}

impl Default for Struct1FormerStorage
{

  #[ inline( always ) ]
  fn default() -> Self
  {
    Self
    {
      int_1 : core::option::Option::None,
      string_1 : core::option::Option::None,
      int_optional_1 : core::option::Option::None,
      string_optional_1 : core::option::Option::None,
    }
  }

}

//

pub struct Struct1Former
<
  __FormerContext = Struct1,
  __FormerEnd = the_module::ReturnStorage,
>
where
  __FormerEnd : the_module::FormingEnd< Struct1, __FormerContext >,
{
  storage : Struct1FormerStorage,
  context : core::option::Option< __FormerContext >,
  on_end : core::option::Option< __FormerEnd >,
}

impl< __FormerContext, __FormerEnd > Struct1Former< __FormerContext, __FormerEnd >
where
  __FormerEnd: the_module::FormingEnd<Struct1, __FormerContext>,
{

  fn form( mut self ) -> Struct1
  {

    let int_1 = if self.storage.int_1.is_some()
    {
      self.storage.int_1.take().unwrap()
    }
    else
    {
      let val : i32 = Default::default();
      val
    };

    let string_1 = if self.storage.string_1.is_some()
    {
      self.storage.string_1.take().unwrap()
    }
    else
    {
      let val : String = Default::default();
      val
    };

    let int_optional_1 = if self.storage.int_optional_1.is_some()
    {
      Some( self.storage.int_optional_1.take().unwrap() )
    }
    else
    {
      None
    };

    let string_optional_1 = if self.storage.string_optional_1.is_some()
    {
      Some( self.storage.string_optional_1.take().unwrap() )
    }
    else
    {
      None
    };

    Struct1
    {
      int_1,
      string_1,
      int_optional_1,
      string_optional_1,
    }

  }

  #[ inline( always ) ]
  pub fn perform(self) -> Struct1
  {
    let result = self.form();
    return result;
  }

  #[ inline( always ) ]
  pub fn new() -> Struct1Former<Struct1, the_module::ReturnStorage>
  {
    Struct1Former::
    <
      Struct1,
      the_module::ReturnStorage,
    >::begin(None, the_module::ReturnStorage)
  }

  #[ inline( always ) ]
  pub fn begin
  (
    context : core::option::Option< __FormerContext >,
    on_end : __FormerEnd,
  ) -> Self
  {
    Self
    {
      storage : core::default::Default::default(),
      context : context,
      on_end : ::core::option::Option::Some( on_end ),
    }
  }

  #[ inline( always ) ]
  pub fn end( mut self ) -> __FormerContext
  {
    let on_end = self.on_end.take().unwrap();
    let context = self.context.take();
    let formed = self.form();
    on_end.call( formed, context )
  }

  pub fn int_1< Src >( mut self, src : Src ) -> Self
  where Src : core::convert::Into< i32 >,
  {
    debug_assert!( self.storage.int_1.is_none() );
    self.storage.int_1 = Some( src.into() );
    self
  }

  pub fn string_1< Src >( mut self, src : Src ) -> Self
  where Src : core::convert::Into< String >,
  {
    debug_assert!( self.storage.string_1.is_none() );
    self.storage.string_1 = Some( src.into() );
    self
  }

  pub fn string_optional_1< Src >( mut self, src : Src ) -> Self
  where Src : core::convert::Into< String >
  {
    debug_assert!( self.storage.string_optional_1.is_none() );
    self.storage.string_optional_1 = Some( src.into() );
    self
  }

}

//

include!( "../only_test/primitives.rs" );
