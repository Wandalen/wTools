#![ allow( dead_code ) ]
#[ allow( unused_imports ) ]
use super::*;

#[ derive( Debug, PartialEq, Default ) ]
pub struct Property< Name >
{
  name : Name,
  code : isize,
}

/// generated by new
impl< Name > Property< Name >
{
  #[ inline ]
  pub fn new< Code >( name : Name, code : Code ) -> Self
  where
    Name : core::convert::Into< Name >,
    Code : core::convert::Into< isize >,
  {
    Self { name : name.into(), code : code.into() }
  }
}

// #[ derive( Debug, PartialEq, the_module::Former ) ]
// #[ derive( Debug, PartialEq, the_module::Former ) ] #[ debug ]
#[ derive( Debug, PartialEq ) ]
pub struct Child< K >
where
  K : core::hash::Hash + core::cmp::Eq,
{
  pub name : String,
  // #[ subform_collection( definition = former::HashMapDefinition ) ]
  pub properties : collection_tools::HashMap< K, Property< K > >,
}

// == begin_coercing of generated

#[ automatically_derived ]
impl< K, > Child< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{



  #[ inline( always ) ]
  pub fn former() -> ChildFormer< K, ChildFormerDefinition< K, (), Child< K, >, former :: ReturnPreformed > >
  {
    ChildFormer
    ::
    < K, ChildFormerDefinition< K, (), Child< K, >, former :: ReturnPreformed > >
    :: new( former :: ReturnPreformed )
  }
}

#[ derive( Debug ) ]
pub struct ChildFormerDefinitionTypes< K, __Context = (), __Formed = Child< K, >, >
where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  _phantom : core :: marker :: PhantomData< ( K, __Context, __Formed ) >,
}

impl< K, __Context, __Formed, > :: core :: default :: Default
for ChildFormerDefinitionTypes< K, __Context, __Formed, >
where
  K : core :: hash :: Hash + std :: cmp :: Eq,
{
  fn default() -> Self
  {
    Self
    {
      _phantom : core :: marker :: PhantomData,
    }
  }
}

impl< K, __Context, __Formed, > former :: FormerDefinitionTypes
for ChildFormerDefinitionTypes< K, __Context, __Formed, >
where
  K : core :: hash :: Hash + std :: cmp :: Eq,
{
  type Storage = ChildFormerStorage< K, >;
  type Formed = __Formed;
  type Context = __Context;
}

impl< K, Context, Formed > former::FormerMutator
for ChildFormerDefinitionTypes< K, Context, Formed >
where
  K : core :: hash :: Hash + std :: cmp :: Eq,
{
}

#[ derive( Debug ) ]
pub struct ChildFormerDefinition
< K, __Context = (), __Formed = Child< K, >, __End = former :: ReturnPreformed, >
where
  K : core :: hash :: Hash + std :: cmp :: Eq,
{
  _phantom : core :: marker :: PhantomData< ( K, __Context, __Formed, __End ) >,
}

impl< K, __Context, __Formed, __End, > :: core :: default :: Default
for ChildFormerDefinition< K, __Context, __Formed, __End, >
where
  K : core :: hash :: Hash + std :: cmp :: Eq,
{
  fn default() -> Self
  {
    Self
    {
      _phantom : core :: marker :: PhantomData,
    }
  }
}

impl< K, __Context, __Formed, __End, > former :: FormerDefinition
for ChildFormerDefinition< K, __Context, __Formed, __End, >
where
  __End : former :: FormingEnd< ChildFormerDefinitionTypes< K, __Context, __Formed, > >,
  K : core :: hash :: Hash + std :: cmp :: Eq,
{
  type Types = ChildFormerDefinitionTypes< K, __Context, __Formed, >;
  type End = __End;
  type Storage = ChildFormerStorage< K, >;
  type Formed = __Formed;
  type Context = __Context;
}

// pub type ChildFormerWithClosure< K, __Context, __Formed, > = ChildFormerDefinition< K, __Context, __Formed, former :: FormingEndClosure< ChildFormerDefinitionTypes< K, __Context, __Formed, > > >;

pub struct ChildFormerStorage< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{

  pub name : :: core :: option :: Option< String >,

  pub properties : :: core :: option :: Option< collection_tools :: HashMap< K, Property< K > > >,
}

impl< K, > :: core :: default :: Default for ChildFormerStorage< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  #[ inline( always ) ]
  fn default() -> Self
  {
    Self
    {
      name : :: core :: option :: Option :: None,
      properties : :: core :: option :: Option :: None,
    }
  }
}

impl< K, > former :: Storage for ChildFormerStorage< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  type Preformed = Child< K, >;
}

impl< K, > former :: StoragePreform for ChildFormerStorage< K, > where K : core :: hash :: Hash + std :: cmp :: Eq,
{
  // type Preformed = Child< K, >;

  fn preform( mut self ) -> Self::Preformed
  // fn preform( mut self ) -> < Self as former :: Storage > :: Formed
  {
    let name = if self.name.is_some()
    {
      self.name.take().unwrap()
    }
    else
    {
      {
        trait MaybeDefault< T >
        {
          fn maybe_default( self : & Self ) -> T
          {
            panic!( "Field 'name' isn't initialized" )
          }
        }
        impl< T > MaybeDefault< T > for & :: core :: marker :: PhantomData< T > {}
        impl< T > MaybeDefault< T > for :: core :: marker :: PhantomData< T > where T : :: core :: default :: Default,
        {
          fn maybe_default( self : & Self ) -> T { T :: default() }
        }
        ( & :: core :: marker :: PhantomData :: < String > ).maybe_default()
      }
    };

    let properties = if self.properties.is_some()
    {
      self.properties.take().unwrap()
    }
    else
    {
      {
        trait MaybeDefault< T >
        {
          fn maybe_default( self : & Self ) -> T
          {
            panic!( "Field 'properties' isn't initialized" )
          }
        }
        impl< T > MaybeDefault< T > for & :: core :: marker :: PhantomData< T > {}
        impl< T > MaybeDefault< T > for :: core :: marker :: PhantomData< T > where T : :: core :: default :: Default,
        {
          fn maybe_default( self : & Self ) -> T { T :: default() }
        }
        ( & :: core :: marker :: PhantomData :: < collection_tools :: HashMap< K, Property< K > > > ).maybe_default()
      }
    };

    let result = Child :: < K, > { name, properties, };
    return result;
  }
}

pub struct ChildFormer< K, Definition = ChildFormerDefinition< K, (), Child< K, >, former::ReturnPreformed >, >
where
  K : core::hash::Hash + core::cmp::Eq,
  Definition : former::FormerDefinition< Storage = ChildFormerStorage< K, > >,
  // Definition::Types : former::FormerDefinitionTypes< Storage = ChildFormerStorage< K, > >
{
  storage : Definition::Storage,
  context : core::option::Option< Definition::Context >,
  on_end : core::option::Option< Definition::End >,
}

#[ automatically_derived ]
impl< K, Definition, > ChildFormer< K, Definition, >
where
  K : core::hash::Hash + core::cmp::Eq,
  Definition : former::FormerDefinition< Storage = ChildFormerStorage< K, > >
  // Definition::Types : former::FormerDefinitionTypes< Storage = ChildFormerStorage< K, > >,
{

  #[ inline( always ) ]
  pub fn perform( self ) -> < Definition::Types as former::FormerDefinitionTypes >::Formed
  {
    let result = self.form();
    return result;
  }

  #[ inline( always ) ]
  pub fn new( on_end : Definition::End ) -> Self
  {
    Self::begin_coercing( None, None, on_end )
  }

  #[ inline( always ) ]
  pub fn new_coercing< IntoEnd >( end : IntoEnd ) -> Self
  where IntoEnd : Into< Definition::End >
  {
    Self::begin_coercing( None, None, end )
  }

  #[ inline( always ) ]
  pub fn begin( mut storage : core::option::Option< Definition::Storage >, context : core::option::Option< Definition::Context >, on_end : < Definition as former::FormerDefinition >::End, ) -> Self
  {
    if storage.is_none()
    {
      storage = Some( ::core::default::Default::default() );
    }
    Self
    {
      storage : storage.unwrap(),
      context : context,
      on_end : ::core::option::Option::Some( on_end ),
    }
  }

  #[ inline( always ) ]
  pub fn begin_coercing< IntoEnd >
  (
    mut storage : core::option::Option< Definition::Storage >, context : core::option::Option< Definition::Context >, on_end : IntoEnd,
  )
  -> Self
  where
    IntoEnd : ::core::convert::Into< < Definition as former::FormerDefinition >::End >
  {
    if storage.is_none()
    {
      storage = Some( ::core::default::Default::default() );
    }
    Self
    {
      storage : storage.unwrap(),
      context : context,
      on_end : ::core::option::Option::Some( ::core::convert::Into::into( on_end ) ),
    }
  }

  #[ inline( always ) ]
  pub fn form( self ) -> < Definition::Types as former::FormerDefinitionTypes >::Formed
  {
    self.end()
  }

  #[ inline( always ) ]
  pub fn end( mut self ) -> < Definition::Types as former::FormerDefinitionTypes >::Formed
  {
    let on_end = self.on_end.take().unwrap();
    let context = self.context.take();
    former::FormingEnd::< Definition::Types >::call( &on_end, self.storage, context )
  }

  #[ inline ]
  pub fn name< Src >( mut self, src : Src ) -> Self
  where Src : ::core::convert::Into< String >
  {
    debug_assert!( self.storage.name.is_none() );
    self.storage.name = ::core::option::Option::Some( ::core::convert::Into::into( src ) );
    self
  }

  #[ inline( always ) ]
  pub fn properties_set< Former2 >( self ) -> Former2
  where Former2 : former::FormerBegin< former::HashMapDefinition< K, Property< K >, Self, Self, ChildFormerPropertiesEnd, > >
  {
    Former2::former_begin( None, Some( self ), ChildFormerPropertiesEnd )
  }

  #[ inline( always ) ]
  pub fn properties( self ) -> former::CollectionFormer::< ( K, Property< K >, ), former::HashMapDefinition< K, Property< K >, Self, Self, ChildFormerPropertiesEnd > >
  {
    self.properties_set::< former::CollectionFormer::< ( K, Property< K >, ), former::HashMapDefinition< K, Property< K >, Self, Self, ChildFormerPropertiesEnd > >>()
  }
}

//

impl< K, Definition, > ChildFormer< K, Definition, >
where
  K : core::hash::Hash + core::cmp::Eq,
  Definition : former::FormerDefinition< Storage = ChildFormerStorage< K, >, Formed = Child< K, > >,
  // Definition::Types : former::FormerDefinitionTypes< Storage = ChildFormerStorage< K, >, Formed = Child< K, > >,
  Definition::Storage : former::StoragePreform< Preformed = Child< K, > >
{
  pub fn preform( self ) -> < Definition::Types as former::FormerDefinitionTypes >::Formed
  {
    former::StoragePreform::preform( self.storage )
  }
}

#[ allow( non_camel_case_types ) ]
pub struct ChildFormerPropertiesEnd;

#[ automatically_derived ]
impl< K, Definition, > former::FormingEnd< former::HashMapDefinitionTypes< K, Property< K >, ChildFormer< K, Definition, >, ChildFormer< K, Definition, > >, >
for ChildFormerPropertiesEnd
where
  K : core::hash::Hash + core::cmp::Eq,
  Definition : former::FormerDefinition< Storage = ChildFormerStorage< K, > >,
  // Definition::Types : former::FormerDefinitionTypes< Storage = ChildFormerStorage< K, > >,
{
  #[ inline( always ) ]
  fn call( &self, storage : collection_tools::HashMap< K, Property< K > >, super_former : Option< ChildFormer< K, Definition, > >, ) -> ChildFormer< K, Definition, >
  {
    let mut super_former = super_former.unwrap();
    if let Some( ref mut field ) = super_former.storage.properties
    {
      former::CollectionAssign::assign( field, storage );
    }
    else
    {
      super_former.storage.properties = Some( storage );
    }
    super_former
  }
}

// == end of generated

include!( "./only_test/parametrized_struct.rs" );
