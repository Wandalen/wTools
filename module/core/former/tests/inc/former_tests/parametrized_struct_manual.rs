#![ allow( dead_code ) ]
#[ allow( unused_imports ) ]
use super::*;

#[ derive( Debug, PartialEq, Default ) ]
pub struct Property< Name >
{
  name : Name,
  code : isize,
}

/// generated by new
impl< Name > Property< Name >
{
  #[ inline ]
  pub fn new< Code >( name : Name, code : Code ) -> Self
  where
    Name : core::convert::Into< Name >,
    Code : core::convert::Into< isize >,
  {
    Self { name : name.into(), code : code.into() }
  }
}

#[ derive( Debug, PartialEq ) ]
pub struct Command< K >
where
  K : core::hash::Hash + std::cmp::Eq,
{
  pub name : String,
  pub properties : collection_tools::HashMap< K, Property< K > >,
}

// generated by former
impl< K > Command< K >
where
  K : core::hash::Hash + std::cmp::Eq,
{

  #[ inline( always ) ]
  pub fn former() -> CommandFormer< K >
  {
    CommandFormer::< K >::new()
  }

}

// generated by former
pub struct CommandFormerStorage< K >
where
  K : core::hash::Hash + std::cmp::Eq,
{
  name : core::option::Option< String >,
  properties : core::option::Option< collection_tools::HashMap< K, Property< K > > >,
}

impl< K > Default for CommandFormerStorage< K >
where
  K : core::hash::Hash + std::cmp::Eq,
{

  #[ inline( always ) ]
  fn default() -> Self
  {
    Self
    {
      name : None,
      properties : None,
    }
  }

}

// generated by former
// #[ derive( Debug, Default ) ]
pub struct CommandFormer< K, Context = Command< K >, End = the_module::ReturnStorage >
where
  K : core::hash::Hash + std::cmp::Eq,
  End : the_module::FormingEnd< Command< K >, Context >,
{
  storage : CommandFormerStorage< K >,
  context : core::option::Option< Context >,
  on_end : core::option::Option< End >,
}

// generated by former
impl< K, Context, End >
CommandFormer< K, Context, End >
where
  K : core::hash::Hash + std::cmp::Eq,
  End : the_module::FormingEnd< Command< K >, Context >,
{

  #[ inline( always ) ]
  fn form( mut self ) -> Command< K >
  {

    let name = if self.storage.name.is_some()
    {
      self.storage.name.take().unwrap()
    }
    else
    {
      let val = Default::default();
      val
    };

    let properties = if self.storage.properties.is_some()
    {
      self.storage.properties.take().unwrap()
    }
    else
    {
      let val = Default::default();
      val
    };

    Command
    {
      name,
      properties,
    }
  }

  #[ inline( always ) ]
  pub fn perform( self ) -> Command< K >
  {
    self.form()
  }

  #[ inline( always ) ]
  pub fn new() -> CommandFormer< K >
  {
    CommandFormer::< K >::begin
    (
      None,
      None,
      the_module::ReturnStorage,
    )
  }

  #[ inline( always ) ]
  pub fn begin
  (
    storage : core::option::Option< CommandFormerStorage< K > >,
    context : core::option::Option< Context >,
    on_end : End,
  ) -> Self
  {
    // xxx : fix
    debug_assert!( storage.is_none() );
    Self
    {
      storage : Default::default(),
      context : context,
      on_end : Some( on_end ),
    }
  }

  /// Return former of your struct moving container there. Should be called after configuring the container.
  #[ inline( always ) ]
  pub fn end( mut self ) -> Formed
  {
    let on_end = self.on_end.take().unwrap();
    let context = self.context.take();
    let formed = self.form();
    on_end.call( formed, context )
  }

  #[ inline( always ) ]
  pub fn name< Src >( mut self, src : Src ) -> Self
  where Src : core::convert::Into< String >,
  {
    debug_assert!( self.storage.name.is_none() );
    self.storage.name = Some( src.into() );
    self
  }

  #[ inline( always ) ]
  pub fn properties( mut self ) -> the_module::HashMapSubformer
  <
    K,
    Property< K >,
    collection_tools::HashMap< K, Property< K > >,
    CommandFormer< K, Context, End >,
    impl the_module::FormingEnd< collection_tools::HashMap< K, Property< K > >, Self >,
  >
  {
    let formed = self.storage.properties.take();
    let on_end = | formed : collection_tools::HashMap< K, Property< K > >, super_former : core::option::Option< Self > | -> Self
    {
      let mut super_former = super_former.unwrap();
      super_former.storage.properties = Some( formed );
      super_former
    };
    the_module::HashMapSubformer::begin( formed, Some( self ), on_end )
  }

}

// ==

include!( "../only_test/parametrized_struct.rs" );
