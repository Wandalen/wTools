#![allow(clippy::used_underscore_binding, clippy::all, warnings, missing_docs)]
#![allow(dead_code)]
#[ allow( unused_imports ) ]
use super::*;
#[ allow( unused_imports ) ]
use test_tools::a_id;

#[ derive( Debug, PartialEq, Default ) ]
pub struct Property<Name> {
  name: Name,
  code: isize,
}

/// generated by new
impl<Name> Property<Name> {
  #[ inline ]
  pub fn new<Code>(name: Name, code: Code) -> Self
  where
    Name: core::convert::Into<Name>,
    Code: core::convert::Into<isize>,
  {
    Self {
      name,
      code: code.into(),
    }
  }
}


// #[ derive( Debug, PartialEq, the_module::Former ) ]
// #[ derive( Debug, PartialEq, the_module::Former ) ] #[ debug ]
#[ derive( Debug, PartialEq ) ]
pub struct Child<K>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  pub name: String,
  // #[ subform_collection( definition = former::HashMapDefinition ) ]
  pub properties: collection_tools::HashMap<K, Property<K>>,
}

// == begin_coercing of generated

#[ automatically_derived ]
impl<K> Child<K>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  #[ inline( always ) ]
  pub fn former() -> ChildFormer<K, ChildFormerDefinition<K, (), Child<K>, former::ReturnPreformed>> {
    ChildFormer::<K, ChildFormerDefinition<K, (), Child<K>, former::ReturnPreformed>>::new(former::ReturnPreformed)
  }
}

#[ derive( Debug ) ]
pub struct ChildFormerDefinitionTypes<K, __Context = (), __Formed = Child<K>>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  _phantom: core::marker::PhantomData<(K, __Context, __Formed)>,
}

impl<K, __Context, __Formed> ::core::default::Default for ChildFormerDefinitionTypes<K, __Context, __Formed>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  fn default() -> Self {
    Self {
      _phantom: core::marker::PhantomData,
    }
  }
}

impl<K, __Context, __Formed> former::FormerDefinitionTypes for ChildFormerDefinitionTypes<K, __Context, __Formed>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  type Storage = ChildFormerStorage<K>;
  type Formed = __Formed;
  type Context = __Context;
}

impl<K, Context, Formed> former::FormerMutator for ChildFormerDefinitionTypes<K, Context, Formed> where
  K: core::hash::Hash + core::cmp::Eq
{
}

#[ derive( Debug ) ]
pub struct ChildFormerDefinition<K, __Context = (), __Formed = Child<K>, __End = former::ReturnPreformed>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  _phantom: core::marker::PhantomData<(K, __Context, __Formed, __End)>,
}

impl<K, __Context, __Formed, __End> ::core::default::Default for ChildFormerDefinition<K, __Context, __Formed, __End>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  fn default() -> Self {
    Self {
      _phantom: core::marker::PhantomData,
    }
  }
}

impl<K, __Context, __Formed, __End> former::FormerDefinition for ChildFormerDefinition<K, __Context, __Formed, __End>
where
  __End: former::FormingEnd<ChildFormerDefinitionTypes<K, __Context, __Formed>>,
  K: core::hash::Hash + core::cmp::Eq,
{
  type Types = ChildFormerDefinitionTypes<K, __Context, __Formed>;
  type End = __End;
  type Storage = ChildFormerStorage<K>;
  type Formed = __Formed;
  type Context = __Context;
}

// pub type ChildFormerWithClosure< K, __Context, __Formed, > = ChildFormerDefinition< K, __Context, __Formed, former :: FormingEndClosure< ChildFormerDefinitionTypes< K, __Context, __Formed, > > >;

pub struct ChildFormerStorage<K>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  pub name: ::core::option::Option<String>,

  pub properties: ::core::option::Option<collection_tools::HashMap<K, Property<K>>>,
}

impl<K> ::core::default::Default for ChildFormerStorage<K>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  #[ inline( always ) ]
  fn default() -> Self {
    Self {
      name: ::core::option::Option::None,
      properties: ::core::option::Option::None,
    }
  }
}

impl<K> former::Storage for ChildFormerStorage<K>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  type Preformed = Child<K>;
}

impl<K> former::StoragePreform for ChildFormerStorage<K>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  // type Preformed = Child< K, >;

  fn preform(mut self) -> Self::Preformed
// fn preform( mut self ) -> < Self as former :: Storage > :: Formed
  {
    let name = if self.name.is_some() {
      self.name.take().unwrap()
    } else {
      {
        trait MaybeDefault<T> {
          fn maybe_default(&self) -> T {
            panic!("Field 'name' isn't initialized")
          }
        }
        impl<T> MaybeDefault<T> for &::core::marker::PhantomData<T> {}
        impl<T> MaybeDefault<T> for ::core::marker::PhantomData<T>
        where
          T: ::core::default::Default,
        {
          fn maybe_default(&self) -> T {
            T::default()
          }
        }
        ::core::marker::PhantomData::<String>.maybe_default()
      }
    };

    let properties = if self.properties.is_some() {
      self.properties.take().unwrap()
    } else {
      {
        trait MaybeDefault<T> {
          fn maybe_default(&self) -> T {
            panic!("Field 'properties' isn't initialized")
          }
        }
        impl<T> MaybeDefault<T> for &::core::marker::PhantomData<T> {}
        impl<T> MaybeDefault<T> for ::core::marker::PhantomData<T>
        where
          T: ::core::default::Default,
        {
          fn maybe_default(&self) -> T {
            T::default()
          }
        }
        ::core::marker::PhantomData::<collection_tools::HashMap<K, Property<K>>>.maybe_default()
      }
    };

    
    Child::<K> { name, properties }
  }
}

pub struct ChildFormer<K, Definition = ChildFormerDefinition<K, (), Child<K>, former::ReturnPreformed>>
where
  K: core::hash::Hash + core::cmp::Eq,
  Definition: former::FormerDefinition<Storage = ChildFormerStorage<K>>,
  // Definition::Types : former::FormerDefinitionTypes< Storage = ChildFormerStorage< K, > >
{
  storage: Definition::Storage,
  context: core::option::Option<Definition::Context>,
  on_end: core::option::Option<Definition::End>,
}

#[ automatically_derived ]
impl<K, Definition> ChildFormer<K, Definition>
where
  K: core::hash::Hash + core::cmp::Eq,
  Definition: former::FormerDefinition<Storage = ChildFormerStorage<K>>, // Definition::Types : former::FormerDefinitionTypes< Storage = ChildFormerStorage< K, > >,
{
  #[ inline( always ) ]
  pub fn perform(self) -> <Definition::Types as former::FormerDefinitionTypes>::Formed {
    
    self.form()
  }

  #[ inline( always ) ]
  pub fn new(on_end: Definition::End) -> Self {
    Self::begin_coercing(None, None, on_end)
  }

  #[ inline( always ) ]
  pub fn new_coercing<IntoEnd>(end: IntoEnd) -> Self
  where
    IntoEnd: Into<Definition::End>,
  {
    Self::begin_coercing(None, None, end)
  }

  #[ inline( always ) ]
  pub fn begin(
    mut storage: core::option::Option<Definition::Storage>,
    context: core::option::Option<Definition::Context>,
    on_end: <Definition as former::FormerDefinition>::End,
  ) -> Self {
    if storage.is_none() {
      storage = Some(::core::default::Default::default());
    }
    Self {
      storage: storage.unwrap(),
      context,
      on_end: ::core::option::Option::Some(on_end),
    }
  }

  #[ inline( always ) ]
  pub fn begin_coercing<IntoEnd>(
    mut storage: core::option::Option<Definition::Storage>,
    context: core::option::Option<Definition::Context>,
    on_end: IntoEnd,
  ) -> Self
  where
    IntoEnd: ::core::convert::Into<<Definition as former::FormerDefinition>::End>,
  {
    if storage.is_none() {
      storage = Some(::core::default::Default::default());
    }
    Self {
      storage: storage.unwrap(),
      context,
      on_end: ::core::option::Option::Some(::core::convert::Into::into(on_end)),
    }
  }

  #[ inline( always ) ]
  pub fn form(self) -> <Definition::Types as former::FormerDefinitionTypes>::Formed {
    self.end()
  }

  #[ inline( always ) ]
  pub fn end(mut self) -> <Definition::Types as former::FormerDefinitionTypes>::Formed {
    let on_end = self.on_end.take().unwrap();
    let mut context = self.context.take();
    <Definition::Types as former::FormerMutator>::form_mutation(&mut self.storage, &mut context);
    former::FormingEnd::<Definition::Types>::call(&on_end, self.storage, context)
  }

  #[ inline ]
  pub fn name<Src>(mut self, src: Src) -> Self
  where
    Src: ::core::convert::Into<String>,
  {
    debug_assert!(self.storage.name.is_none());
    self.storage.name = ::core::option::Option::Some(::core::convert::Into::into(src));
    self
  }

  #[ inline( always ) ]
  pub fn _properties_assign<'a, Former2>(self) -> Former2
  where
    K: 'a,
    Definition: 'a,
    Former2: former::FormerBegin<'a, former::HashMapDefinition<K, Property<K>, Self, Self, ChildFormerPropertiesEnd<Definition>>>,
    former::HashMapDefinition<K, Property<K>, Self, Self, ChildFormerPropertiesEnd<Definition>>: former::FormerDefinition<
      Storage = collection_tools::HashMap<K, Property<K>>,
      Context = ChildFormer<K, Definition>,
      End = ChildFormerPropertiesEnd<Definition>,
    >,
    ChildFormerPropertiesEnd<Definition>:
      former::FormingEnd<<collection_tools::HashMap<K, Property<K>> as former::EntityToDefinitionTypes<Self, Self>>::Types>,
  {
    Former2::former_begin(None, Some(self), ChildFormerPropertiesEnd::<Definition>::default())
  }

  #[ inline( always ) ]
  pub fn properties<'a>(
    self,
  ) -> former::CollectionFormer<
    (K, Property<K>),
    former::HashMapDefinition<K, Property<K>, Self, Self, ChildFormerPropertiesEnd<Definition>>,
  >
  where
    K: 'a,
    Definition: 'a,
    former::HashMapDefinition<K, Property<K>, Self, Self, ChildFormerPropertiesEnd<Definition>>: former::FormerDefinition<
      Storage = collection_tools::HashMap<K, Property<K>>,
      Context = ChildFormer<K, Definition>,
      End = ChildFormerPropertiesEnd<Definition>,
    >,
    ChildFormerPropertiesEnd<Definition>:
      former::FormingEnd<<collection_tools::HashMap<K, Property<K>> as former::EntityToDefinitionTypes<Self, Self>>::Types>,
  {
    self._properties_assign::<'a, former::CollectionFormer<
      (K, Property<K>),
      former::HashMapDefinition<K, Property<K>, Self, Self, ChildFormerPropertiesEnd<Definition>>,
    >>()
  }
}

//

impl<K, Definition> ChildFormer<K, Definition>
where
  K: core::hash::Hash + core::cmp::Eq,
  Definition: former::FormerDefinition<Storage = ChildFormerStorage<K>, Formed = Child<K>>,
  // Definition::Types : former::FormerDefinitionTypes< Storage = ChildFormerStorage< K, >, Formed = Child< K, > >,
  Definition::Storage: former::StoragePreform<Preformed = Child<K>>,
{
  pub fn preform(self) -> <Definition::Types as former::FormerDefinitionTypes>::Formed {
    former::StoragePreform::preform(self.storage)
  }
}

pub struct ChildFormerPropertiesEnd<Definition> {
  _phantom: core::marker::PhantomData<(Definition,)>,
}

impl<Definition> Default for ChildFormerPropertiesEnd<Definition> {
  fn default() -> Self {
    Self {
      _phantom: core::marker::PhantomData,
    }
  }
}

impl<K, Definition>
  former::FormingEnd<former::HashMapDefinitionTypes<K, Property<K>, ChildFormer<K, Definition>, ChildFormer<K, Definition>>>
  for ChildFormerPropertiesEnd<Definition>
where
  K: core::hash::Hash + core::cmp::Eq,
  Definition: former::FormerDefinition<Storage = ChildFormerStorage<K>>,
  Definition::Types: former::FormerDefinitionTypes<Storage = ChildFormerStorage<K>>,
{
  #[ inline( always ) ]
  fn call(
    &self,
    storage: collection_tools::HashMap<K, Property<K>>,
    super_former: Option<ChildFormer<K, Definition>>,
  ) -> ChildFormer<K, Definition> {
    let mut super_former = super_former.unwrap();
    if let Some(ref mut field) = super_former.storage.properties {
      former::CollectionAssign::assign(field, storage);
    } else {
      super_former.storage.properties = Some(storage);
    }
    super_former
  }
}

impl<'a, K, Definition> former::FormerBegin<'a, Definition> for ChildFormer<K, Definition>
where
  K: core::hash::Hash + core::cmp::Eq + 'a,
  Definition: former::FormerDefinition<Storage = ChildFormerStorage<K>>,
  Definition::Context: 'a,
  Definition::End: 'a,
{
  #[ inline( always ) ]
  fn former_begin(
    storage: ::core::option::Option<Definition::Storage>,
    context: ::core::option::Option<Definition::Context>,
    on_end: Definition::End,
  ) -> Self {
    debug_assert!(storage.is_none());
    Self::begin(None, context, on_end)
  }
}

// == end of generated

include!("./only_test/parametrized_struct.rs");
