#![allow(dead_code)]
#[ allow( unused_imports ) ]
use super::*;

#[ derive( Debug, PartialEq, Default ) ]
pub struct Property<Name> {
  name: Name,
  code: isize,
}

/// generated by new
impl<Name> Property<Name> {
  #[ inline ]
  pub fn new<Code>(name: Name, code: Code) -> Self
  where
    Name: core::convert::Into<Name>,
    Code: core::convert::Into<isize>,
  {
    Self {
      name,
      code: code.into(),
    }
  }
}

// TODO: Investigate "cannot find type K in this scope" error
// This appears to be a macro hygiene issue where the type parameter K
// is not properly scoped in the generated code. The error occurs at
// the struct definition line itself, suggesting interference from the
// derive macro expansion.
#[ derive( Debug, PartialEq, the_module::Former ) ]
// #[ debug ] // Commented out - debug attribute only for temporary debugging
pub struct Child<T> where T: core::hash::Hash + core::cmp::Eq {
  pub name: String,
  // #[ subform_collection( definition = former::HashMapDefinition ) ]
  pub properties: collection_tools::HashMap<T, Property<T>>,
}

// == begin_coercing of generated

// == end of generated

// DISABLED: Tests disabled until parametrized struct Former derive is fixed
// include!("./only_test/parametrized_struct.rs");
