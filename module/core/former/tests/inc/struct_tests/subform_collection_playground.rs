#![allow(clippy::used_underscore_binding, clippy::all, warnings, missing_docs)]
#![deny(missing_docs)]
#![allow(dead_code)]
use super::*;
use collection_tools::HashMap;

//
// this should work
//
// let ca = Parent::former()
// .parameter1( "val" )
// .command( "echo" )
//   .name( "prints all subjects and properties" )
//   .subject( "Subject", wca::Type::String, true )
//   .property( "property", "simple property", wca::Type::String, true )
//   .routine( f1 )
//   .end()
// .command( "exit" )
//   .name( "just exit" )
//   .routine( || exit() )
//   .end()
// .perform()
// ;
// ca.execute( input ).unwrap();

// == property

#[ derive( Debug, PartialEq, Default ) ]
pub struct Property<Name> {
  name: Name,
  description: String,
  code: isize,
}

// zzz : implement derive new
/// generated by new
impl<Name> Property<Name> {
  #[ inline ]
  pub fn new<Description, Code>(name: Name, description: Description, code: Code) -> Self
  where
    Name: core::convert::Into<Name>,
    Description: core::convert::Into<String>,
    Code: core::convert::Into<isize>,
  {
    Self {
      name,
      description: description.into(),
      code: code.into(),
    }
  }
}

// == command

// xxx : Re-enable when trailing comma issue is fully fixed in macro_tools::generic_params::decompose

#[ derive( Debug, PartialEq, the_module::Former ) ]
pub struct Child<K>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  pub name: String,
  pub subject: String,
  // #[ subform_collection( definition = former::HashMapDefinition ) ]
  pub properties: collection_tools::HashMap<K, Property<K>>,
}

// manual
impl<K, Definition> ChildFormer<K, Definition>
where
  K: core::hash::Hash + core::cmp::Eq,
  Definition: former::FormerDefinition<Storage = ChildFormerStorage<K>>,
  Definition::Storage: former::StoragePreform,
{
  /// Inserts a key-value pair into the map. Make a new collection if it was not made so far.
  #[ inline( always ) ]
  pub fn property<Name, Description, Code>(mut self, name: Name, description: Description, code: Code) -> Self
  where
    Name: core::convert::Into<K> + Clone,
    Description: core::convert::Into<String>,
    Code: core::convert::Into<isize>,
  {
    if self.storage.properties.is_none() {
      self.storage.properties = core::option::Option::Some(HashMap::default());
    }
    if let core::option::Option::Some(ref mut properties) = self.storage.properties {
      let property = Property {
        name: name.clone().into(),
        description: description.into(),
        code: code.into(),
      };
      properties.insert(name.into(), property);
    }
    self
  }
}

// == aggregator

// xxx : Re-enable when trailing comma issue is fully fixed in macro_tools::generic_params::decompose

#[ derive( Debug, PartialEq, the_module::Former ) ]
pub struct Parent<K>
where
  K: core::hash::Hash + core::cmp::Eq,
{
  pub parameter1: String,
  // #[ subform_collection( definition = former::HashMapDefinition ) ]
  pub commands: collection_tools::HashMap<String, Child<K>>,
}

// ==

#[ test ]
fn test_playground_basic() {
  // Simple test to verify module is being included
  assert_eq!(1, 1);
}

include!("./only_test/subform_basic.rs");
