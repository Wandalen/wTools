//! Purpose: Tests the `#[derive(Former)]` macro's generation of constructors for tuple variants
//! containing generic types and bounds. This file focuses on verifying the derive-based implementation
//! for single-field and multi-field tuple variants, particularly how it handles the presence or
//! absence of the `#[scalar]` attribute in conjunction with generics.
//!
//! Coverage:
//! - Rule 3d (Tuple + Single-Field + Default): Verifies subformer generation for a single-field tuple variant with generics when `#[scalar]` is absent (default behavior).
//! - Rule 3f (Tuple + Multi-Field + Default): Verifies subformer generation for a multi-field tuple variant with generics when `#[scalar]` is absent (default behavior). Note: This test/manual implementation currently tests subformer behavior for multi-field tuple variants, which contradicts the documented Rule 3f stating default for multi-field tuple is scalar. The documentation here reflects the current test behavior.
//! - Rule 1d (Tuple + Single-Field + `#[scalar]`): Relevant to the scenario where `#[scalar]` is applied to a single-field tuple variant with generics. (Note: `#[scalar]` is commented out in this file, so default behavior is expected and tested).
//! - Rule 1f (Tuple + Multi-Field + `#[scalar]`): Relevant to the scenario where `#[scalar]` is applied to a multi-field tuple variant with generics. (Note: `#[scalar]` is commented out in this file, so default behavior is expected and tested).
//! - Rule 4b (Option 2 Logic): Relevant to the subformer mechanism used for `Variant2` in the test logic/manual implementation.
//!
//! Test Relevance/Acceptance Criteria:
//! - Defines a generic enum `EnumScalarGeneric<T: Bound>` with single-field (`Variant1`) and multi-field (`Variant2`) tuple variants, both containing generic types and bounds.
//! - Applies `#[derive(Former)]` to the enum.
//! - The `#[scalar]` attribute is commented out on both variants, ensuring default behavior is tested.
//! - Includes shared test logic from `scalar_generic_tuple_only_test.rs`.
//! - The tests in the included file call the static methods `variant_1()` and `variant_2()` (generated by the derive macro).
//! - For `variant_1()`, the test expects a direct scalar return and uses `.into()`, verifying Rule 3d (default for single-field).
//! - For `variant_2()`, the test expects a former builder return, uses setters `._0()` and `._1()`, and calls `.form()`, verifying the current test/manual behavior for multi-field default (which is subformer, contradicting Rule 3f).
//! - Asserts that the resulting enum instances match manually constructed expected values.
//! - This file relies on `#[derive(Former)]` for code generation and includes shared test logic via `include!("scalar_generic_tuple_only_test.rs")`.

// File: module/core/former/tests/inc/former_enum_tests/scalar_generic_tuple_derive.rs

use super::*; // Imports testing infrastructure and potentially other common items

// --- Bound, Types, and Inner Struct ---
// Are defined in the included _only_test.rs file

// --- Enum Definition with Bounds and #[scalar] Variants ---
// Apply Former derive here. This is what we are testing.
#[ derive( Debug, PartialEq, Clone, former::Former ) ]
// #[ debug ] // Uncomment to see generated code later
pub enum EnumScalarGeneric< T : Bound > // Enum bound
{
  // #[ scalar ] // Removed #[scalar] for default behavior test
  Variant1( InnerScalar< T > ), // Tuple variant with one generic field

  // qqq : xxx : attribute 'scalar ' is for direct constructor EnumScalarGeneric::variant2( a, b ) or simply variant2( a, b )
  // attribute 'subformer_scalar' it's actually below, so we have a rpoblem in proc macro
  // check readme.md and advanced.md for more information on disinction
  // #[ scalar ] // Removed #[scalar] and Variant2 for single-field test
  Variant2( InnerScalar< T >, bool ), // Tuple variant with generic and non-generic fields
}

// --- Include the Test Logic ---
// This file contains the actual #[ test ] functions.
include!( "scalar_generic_tuple_only_test.rs" );