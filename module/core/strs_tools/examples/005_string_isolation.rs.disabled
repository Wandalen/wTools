//! String isolation and extraction examples.
//!
//! This example demonstrates basic string parsing and extraction techniques
//! using standard library methods for structured text processing.
//! This shows common patterns for parsing configuration files and data extraction.

// Note: This example uses standard library string methods since the 
// strs_tools isolate API is still under development
use strs_tools::*;

fn main()
{
  println!( "=== String Isolation Examples ===" );
  
  basic_isolation();
  delimiter_based_extraction();
  positional_isolation();
  real_world_parsing_examples();
}

/// Demonstrates basic string isolation functionality.
///
/// Shows how to extract substrings from the left or right side
/// based on delimiter positions.
fn basic_isolation()
{
  println!( "\n--- Basic String Isolation ---" );
  
  #[ cfg( all( feature = "string_isolate", not( feature = "no_std" ) ) ) ]
  {
    let sample_text = "user@domain.com:8080/path/to/resource";
    
    println!( "Working with: '{}'", sample_text );
    
    // Extract everything before the first '@' (username)
    if let Some( at_pos ) = sample_text.find( '@' )
    {
      let username = &sample_text[ ..at_pos ];
      println!( "Username (before '@'): '{}'", username );
      assert_eq!( username, "user" );
    }
    else
    {
      println!( "No '@' delimiter found" );
    }
    
    // Extract everything after the last '/' (resource name)
    match string::isolate::isolate_right( sample_text, "/" )
    {
      Some( resource ) =>
      {
        println!( "Resource (after last '/'): '{}'", resource );
        assert_eq!( resource, "resource" );
      },
      None =>
      {
        println!( "No '/' delimiter found" );
      }
    }
    
    // Extract domain part (between @ and :)
    let after_at = string::isolate::isolate_right( sample_text, "@" ).unwrap_or( "" );
    match string::isolate::isolate_left( after_at, ":" )
    {
      Some( domain ) =>
      {
        println!( "Domain (between '@' and ':'): '{}'", domain );
        assert_eq!( domain, "domain.com" );
      },
      None =>
      {
        println!( "Could not extract domain" );
      }
    }
    
    println!( "✓ Basic isolation operations completed" );
  }
}

/// Demonstrates delimiter-based text extraction.
///
/// Shows how to systematically extract different components
/// from structured text formats using various delimiter strategies.
fn delimiter_based_extraction()
{
  println!( "\n--- Delimiter-Based Extraction ---" );
  
  #[ cfg( all( feature = "string_isolate", not( feature = "no_std" ) ) ) ]
  {
    let structured_data = vec![
      "name=John Doe;age=30;city=New York",
      "HTTP/1.1 200 OK\nContent-Type: application/json\nContent-Length: 1234",
      "package.json -> dist/bundle.js (webpack)",
      "2024-08-07T10:30:45Z [INFO] Server started on port 8080",
    ];
    
    println!( "Processing structured data formats:" );
    
    for ( i, data ) in structured_data.iter().enumerate()
    {
      println!( "\n{}. {}", i + 1, data );
      
      match i
      {
        0 => // Key-value pairs separated by semicolons
        {
          println!( "  Extracting key-value pairs:" );
          let parts : Vec< &str > = data.split( ';' ).collect();
          
          for part in parts
          {
            if let Some( key ) = string::isolate::isolate_left( part, "=" )
            {
              if let Some( value ) = string::isolate::isolate_right( part, "=" )
              {
                println!( "    {} = '{}'", key, value );
              }
            }
          }
        },
        
        1 => // HTTP headers
        {
          println!( "  Parsing HTTP response:" );
          let lines : Vec< &str > = data.lines().collect();
          
          // Extract status from first line
          if let Some( status_line ) = lines.get( 0 )
          {
            if let Some( status ) = string::isolate::isolate_right( status_line, " " )
            {
              println!( "    Status: {}", status );
            }
          }
          
          // Extract headers
          for line in lines.iter().skip( 1 )
          {
            if let Some( header_name ) = string::isolate::isolate_left( line, ":" )
            {
              if let Some( header_value ) = string::isolate::isolate_right( line, ": " )
              {
                println!( "    Header: {} = {}", header_name, header_value );
              }
            }
          }
        },
        
        2 => // Build pipeline notation
        {
          println!( "  Parsing build pipeline:" );
          if let Some( source ) = string::isolate::isolate_left( data, " -> " )
          {
            println!( "    Source: {}", source );
          }
          
          if let Some( rest ) = string::isolate::isolate_right( data, " -> " )
          {
            if let Some( target ) = string::isolate::isolate_left( rest, " (" )
            {
              println!( "    Target: {}", target );
            }
            
            if let Some( tool_part ) = string::isolate::isolate_right( rest, "(" )
            {
              if let Some( tool ) = string::isolate::isolate_left( tool_part, ")" )
              {
                println!( "    Tool: {}", tool );
              }
            }
          }
        },
        
        3 => // Log entry
        {
          println!( "  Parsing log entry:" );
          if let Some( timestamp ) = string::isolate::isolate_left( data, " [" )
          {
            println!( "    Timestamp: {}", timestamp );
          }
          
          if let Some( level_part ) = string::isolate::isolate_right( data, "[" )
          {
            if let Some( level ) = string::isolate::isolate_left( level_part, "]" )
            {
              println!( "    Level: {}", level );
            }
          }
          
          if let Some( message ) = string::isolate::isolate_right( data, "] " )
          {
            println!( "    Message: {}", message );
          }
        },
        
        _ => {}
      }
      
      println!( "    ✓ Extraction completed" );
    }
  }
}

/// Demonstrates positional string isolation.
///
/// Shows how to extract text based on position, length,
/// and relative positioning from delimiters.
fn positional_isolation()
{
  println!( "\n--- Positional String Isolation ---" );
  
  #[ cfg( all( feature = "string_isolate", not( feature = "no_std" ) ) ) ]
  {
    let text_samples = vec![
      "README.md",
      "/usr/local/bin/program.exe",
      "https://example.com/api/v1/users/123?format=json",
      "function_name_with_underscores(param1, param2)",
    ];
    
    println!( "Extracting components by position:" );
    
    for ( i, sample ) in text_samples.iter().enumerate()
    {
      println!( "\n{}. {}", i + 1, sample );
      
      match i
      {
        0 => // File name and extension
        {
          if let Some( name ) = string::isolate::isolate_left( sample, "." )
          {
            println!( "    Filename: {}", name );
          }
          
          if let Some( ext ) = string::isolate::isolate_right( sample, "." )
          {
            println!( "    Extension: {}", ext );
          }
        },
        
        1 => // Path components
        {
          // Extract directory path
          if let Some( dir ) = string::isolate::isolate_left( sample, "/program.exe" )
          {
            println!( "    Directory: {}", dir );
          }
          
          // Extract just the filename
          if let Some( filename ) = string::isolate::isolate_right( sample, "/" )
          {
            println!( "    Filename: {}", filename );
            
            // Further extract name and extension
            if let Some( name ) = string::isolate::isolate_left( filename, "." )
            {
              println!( "      Name: {}", name );
            }
            if let Some( ext ) = string::isolate::isolate_right( filename, "." )
            {
              println!( "      Extension: {}", ext );
            }
          }
        },
        
        2 => // URL components
        {
          // Extract protocol
          if let Some( protocol ) = string::isolate::isolate_left( sample, "://" )
          {
            println!( "    Protocol: {}", protocol );
          }
          
          // Extract domain
          let after_protocol = string::isolate::isolate_right( sample, "://" ).unwrap_or( "" );
          if let Some( domain ) = string::isolate::isolate_left( after_protocol, "/" )
          {
            println!( "    Domain: {}", domain );
          }
          
          // Extract path
          let domain_and_path = string::isolate::isolate_right( sample, "://" ).unwrap_or( "" );
          if let Some( path_with_query ) = string::isolate::isolate_right( domain_and_path, "/" )
          {
            if let Some( path ) = string::isolate::isolate_left( path_with_query, "?" )
            {
              println!( "    Path: /{}", path );
            }
            
            // Extract query parameters
            if let Some( query ) = string::isolate::isolate_right( path_with_query, "?" )
            {
              println!( "    Query: {}", query );
            }
          }
        },
        
        3 => // Function signature
        {
          // Extract function name
          if let Some( func_name ) = string::isolate::isolate_left( sample, "(" )
          {
            println!( "    Function: {}", func_name );
          }
          
          // Extract parameters
          if let Some( params_part ) = string::isolate::isolate_right( sample, "(" )
          {
            if let Some( params ) = string::isolate::isolate_left( params_part, ")" )
            {
              println!( "    Parameters: {}", params );
              
              // Split individual parameters
              if !params.is_empty()
              {
                let param_list : Vec< &str > = params.split( ", " ).collect();
                for ( idx, param ) in param_list.iter().enumerate()
                {
                  println!( "      Param {}: {}", idx + 1, param.trim() );
                }
              }
            }
          }
        },
        
        _ => {}
      }
    }
    
    println!( "\n✓ Positional isolation examples completed" );
  }
}

/// Demonstrates real-world parsing examples.
///
/// Shows practical applications of string isolation for
/// common text processing tasks like configuration parsing,
/// log analysis, and data extraction.
fn real_world_parsing_examples()
{
  println!( "\n--- Real-World Parsing Examples ---" );
  
  #[ cfg( all( feature = "string_isolate", not( feature = "no_std" ) ) ) ]
  {
    // Example 1: Configuration file parsing
    let config_lines = vec![
      "# Database configuration",
      "db_host=localhost",
      "db_port=5432", 
      "db_name=myapp",
      "",
      "# Server settings",
      "server_port=8080",
      "server_threads=4",
    ];
    
    println!( "1. Configuration file parsing:" );
    
    for line in config_lines
    {
      // Skip comments and empty lines
      if line.starts_with( '#' ) || line.trim().is_empty()
      {
        if line.starts_with( '#' )
        {
          println!( "    Comment: {}", line );
        }
        continue;
      }
      
      // Parse key=value pairs
      if let Some( key ) = string::isolate::isolate_left( line, "=" )
      {
        if let Some( value ) = string::isolate::isolate_right( line, "=" )
        {
          // Type inference based on value pattern
          if value.chars().all( char::is_numeric )
          {
            println!( "    Config (number): {} = {}", key, value );
          }
          else
          {
            println!( "    Config (string): {} = '{}'", key, value );
          }
        }
      }
    }
    
    // Example 2: Email address validation and parsing
    let email_addresses = vec![
      "user@domain.com",
      "first.last+tag@subdomain.example.org",
      "invalid@",
      "nametag@domain",
      "complex.email+tag@sub.domain.co.uk",
    ];
    
    println!( "\n2. Email address parsing:" );
    
    for email in email_addresses
    {
      println!( "    Email: '{}'", email );
      
      // Basic validation - must contain exactly one @
      let at_count = email.matches( '@' ).count();
      if at_count != 1
      {
        println!( "      ✗ Invalid: wrong number of @ symbols" );
        continue;
      }
      
      // Extract local and domain parts
      if let Some( local_part ) = string::isolate::isolate_left( email, "@" )
      {
        if let Some( domain_part ) = string::isolate::isolate_right( email, "@" )
        {
          println!( "      Local part: '{}'", local_part );
          println!( "      Domain part: '{}'", domain_part );
          
          // Further analyze local part for tags
          if local_part.contains( '+' )
          {
            if let Some( username ) = string::isolate::isolate_left( local_part, "+" )
            {
              if let Some( tag ) = string::isolate::isolate_right( local_part, "+" )
              {
                println!( "        Username: '{}'", username );
                println!( "        Tag: '{}'", tag );
              }
            }
          }
          
          // Check domain validity (must contain at least one dot)
          if domain_part.contains( '.' )
          {
            println!( "      ✓ Domain appears valid" );
          }
          else
          {
            println!( "      ⚠ Domain may be incomplete" );
          }
        }
      }
    }
    
    // Example 3: Log file analysis
    let log_entries = vec![
      "2024-08-07 14:30:25 [INFO] Application started",
      "2024-08-07 14:30:26 [DEBUG] Loading configuration from config.json",  
      "2024-08-07 14:30:27 [ERROR] Failed to connect to database: timeout",
      "2024-08-07 14:30:28 [WARN] Retrying database connection (attempt 1/3)",
    ];
    
    println!( "\n3. Log file analysis:" );
    
    for entry in log_entries
    {
      // Parse timestamp (everything before first bracket)
      if let Some( timestamp ) = string::isolate::isolate_left( entry, " [" )
      {
        // Extract log level (between brackets)
        if let Some( level_part ) = string::isolate::isolate_right( entry, "[" )
        {
          if let Some( level ) = string::isolate::isolate_left( level_part, "]" )
          {
            // Extract message (everything after "] ")
            if let Some( message ) = string::isolate::isolate_right( entry, "] " )
            {
              let priority = match level
              {
                "ERROR" => "🔴",
                "WARN" => "🟡", 
                "INFO" => "🔵",
                "DEBUG" => "⚪",
                _ => "❓",
              };
              
              println!( "    {} [{}] {} | {}", priority, timestamp, level, message );
              
              // Special handling for errors
              if level == "ERROR" && message.contains( ":" )
              {
                if let Some( error_type ) = string::isolate::isolate_left( message, ":" )
                {
                  if let Some( error_detail ) = string::isolate::isolate_right( message, ": " )
                  {
                    println!( "      Error type: {}", error_type );
                    println!( "      Error detail: {}", error_detail );
                  }
                }
              }
            }
          }
        }
      }
    }
    
    println!( "\n✓ Real-world parsing examples completed successfully" );
  }
}