// module/move/willbe/src/action/crate_doc.rs
mod private
{
  #[ allow( clippy::wildcard_imports ) ]
  use crate::*;

  use process_tools::process;
  use error::
  {
    untyped::Context,
    typed::Error,
    ErrWith,
  };
  use core::fmt;
  use std::
  {
    ffi::OsString,
    fs,
    path::PathBuf,
  };
  use collection_tools::HashMap;
  use toml_edit::Document;
  use rustdoc_md::rustdoc_json_types::Crate as RustdocCrate;
  use rustdoc_md::rustdoc_json_to_markdown;

  /// Represents errors specific to the crate documentation generation process.
  #[ derive( Debug, Error ) ]
  pub enum CrateDocError
  {
    /// Error related to file system operations (reading/writing files).
    #[ error( "I/O error: {0}" ) ]
    Io( #[ from ] std::io::Error ),
    /// Error encountered while parsing the Cargo.toml file.
    #[ error( "Failed to parse Cargo.toml: {0}" ) ]
    Toml( #[ from ] toml_edit::TomlError ),
    /// Error occurred during the execution of the `cargo doc` command.
    #[ error( "Failed to execute cargo doc command: {0}" ) ]
    Command( String ),
    /// Error encountered while deserializing the JSON output from `cargo doc`.
    #[ error( "Failed to deserialize rustdoc JSON: {0}" ) ]
    Json( #[ from ] serde_json::Error ),
    /// Error occurred during the conversion from JSON to Markdown.
    #[ error( "Failed to render Markdown: {0}" ) ]
    MarkdownRender( String ),
    /// The package name could not be found within the Cargo.toml file.
    #[ error( "Missing package name in Cargo.toml at {0}" ) ]
    MissingPackageName( PathBuf ),
    /// The JSON documentation file generated by `cargo doc` was not found.
    #[ error( "Generated JSON documentation file not found at {0}" ) ]
    JsonFileNotFound( PathBuf ),
    /// Error related to path manipulation or validation.
    #[ error( "Path error: {0}" ) ]
    Path( #[ from ] PathError ),
    /// A general, untyped error occurred.
    #[ error( "Untyped error: {0}" ) ]
    Untyped( #[ from ] error::untyped::Error ),
  }

  /// Report detailing the outcome of the documentation generation.
  #[ derive( Debug, Default, Clone ) ]
  pub struct CrateDocReport
  {
    /// The directory of the crate processed.
    pub crate_dir : Option< CrateDir >,
    /// The path where the Markdown file was (or was attempted to be) written.
    pub output_path : Option< PathBuf >,
    /// A summary status message of the operation.
    pub status : String,
    /// Output of the cargo doc command, if executed.
    pub cargo_doc_report : Option< process::Report >,
  }

  impl fmt::Display for CrateDocReport
  {
    fn fmt( &self, f : &mut fmt::Formatter< '_ > ) -> fmt::Result
    {
      // Status is the primary message
      writeln!( f, "{}", self.status )?;
      // Add crate and output path details for context
      if let Some( crate_dir ) = &self.crate_dir
      {
        writeln!( f, "  Crate: {}", crate_dir.as_ref().display() )?;
      }
      if let Some( output_path ) = &self.output_path
      {
        writeln!( f, "  Output: {}", output_path.display() )?;
      }
      Ok( () )
    }
  }

  ///
  /// Generate documentation for a crate in a single Markdown file.
  /// Executes `cargo doc` to generate JSON output, reads the JSON,
  /// uses `rustdoc-md` to convert it to Markdown, and saves the result.
  ///
  /// # Arguments
  /// * `workspace` - A reference to the workspace containing the crate.
  /// * `crate_dir` - The directory of the crate for which to generate documentation.
  /// * `output_path_req` - Optional path for the output Markdown file.
  ///
  /// # Returns
  /// Returns `Ok(CrateDocReport)` if successful, otherwise returns `Err((CrateDocReport, CrateDocError))`.
  /// 
  /// # Errors
  /// Returns an error if the command arguments are invalid, the workspace cannot be loaded
  #[ allow( clippy::too_many_lines, clippy::result_large_err ) ]
  pub fn doc
  (
    workspace : &Workspace,
    crate_dir : &CrateDir,
    output_path_req : Option< PathBuf >,
  ) -> ResultWithReport< CrateDocReport, CrateDocError >
  {
    let mut report = CrateDocReport 
    {
      crate_dir : Some( crate_dir.clone() ),
      status : format!( "Starting documentation generation for {}", crate_dir.as_ref().display() ),
      ..Default::default()
    };
  

    // --- Get crate name early for --package argument and file naming ---
    let manifest_path_for_name = crate_dir.as_ref().join( "Cargo.toml" );
    let manifest_content_for_name = fs::read_to_string( &manifest_path_for_name )
    .map_err( CrateDocError::Io )
    .context( format!( "Failed to read Cargo.toml at {}", manifest_path_for_name.display() ) )
    .err_with_report( &report )?;
    let manifest_toml_for_name = manifest_content_for_name.parse::< Document >()
    .map_err( CrateDocError::Toml )
    .context( format!( "Failed to parse Cargo.toml at {}", manifest_path_for_name.display() ) )
    .err_with_report( &report )?;
    let crate_name = manifest_toml_for_name[ "package" ][ "name" ]
    .as_str()
    .ok_or_else( || CrateDocError::MissingPackageName( manifest_path_for_name.clone() ) )
    .err_with_report( &report )?;
    // --- End get crate name early ---

    // Define the arguments for `cargo doc`
    let args: Vec< OsString > = vec!
    [
      "doc".into(),
      "--no-deps".into(),
      "--package".into(),
      crate_name.into(),
    ];

    // Define environment variables
    let envs: HashMap< String, String > =
    [
      ( "RUSTC_BOOTSTRAP".to_string(), "1".to_string() ),
      ( "RUSTDOCFLAGS".to_string(), "-Z unstable-options --output-format json".to_string() ),
    ].into();

    // Execute the command from the workspace root
    let cargo_report_result = process::Run::former()
    .bin_path( "cargo" )
    .args( args )
    .current_path( workspace.workspace_root().absolute_path() )
    .env_variable( envs )
    .run();

    // Store report regardless of outcome and update status if it failed
    match &cargo_report_result
    {
      Ok( r ) => report.cargo_doc_report = Some( r.clone() ),
      Err( r ) =>
      {
        report.cargo_doc_report = Some( r.clone() );
        report.status = format!( "Failed during `cargo doc` execution for `{crate_name}`." );
      }
    }

    // Handle potential command execution error using err_with_report
    let _cargo_report = cargo_report_result
      .map_err( | report | CrateDocError::Command( report.to_string() ) )
      .err_with_report( &report )?;

    // Construct path to the generated JSON file using workspace target dir
    let json_path = workspace
      .target_directory()
      .join( "doc" )
      .join( format!( "{crate_name}.json" ) );

    // Check if JSON file exists and read it
    if !json_path.exists()
    {
      report.status = format!( "Generated JSON documentation file not found at {}", json_path.display() );
      return Err(( report, CrateDocError::JsonFileNotFound( json_path ) ));
    }
    let json_content = fs::read_to_string( &json_path )
      .map_err( CrateDocError::Io )
      .context( format!( "Failed to read JSON documentation file at {}", json_path.display() ) )
      .err_with_report( &report )?;

    // Deserialize JSON content into RustdocCrate struct
    let rustdoc_crate: RustdocCrate = serde_json::from_str( &json_content )
      .map_err( CrateDocError::Json )
      .context( format!( "Failed to deserialize JSON from {}", json_path.display() ) )
      .err_with_report( &report )?;

    // Define output Markdown file path
    let output_md_abs_path = match output_path_req
    {
      // If a path was provided
      Some( req_path ) =>
      {
        if req_path.is_absolute()
        {
          // Use it directly if absolute
          req_path
        }
        else
        {
          // Resolve relative to CWD if relative
          std::env::current_dir()
            .map_err( CrateDocError::Io )
            .context( "Failed to get current directory to resolve output path" )
            .err_with_report( &report )?
            .join( req_path )
            // Removed canonicalize call here
        }
      }
      // If no path was provided, default to workspace target/doc directory
      None =>
      {
        workspace
          .target_directory()
          .join( "doc" )
          .join( format!( "{crate_name}_doc.md" ) )
      }
    };

    report.output_path = Some( output_md_abs_path.clone() );

    // Use rustdoc_json_to_markdown to convert the Crate struct to Markdown string
    let markdown_content = rustdoc_json_to_markdown( rustdoc_crate );

    // Write the Markdown string to the output file
    if let Some( parent_dir ) = output_md_abs_path.parent()
    {
      fs::create_dir_all( parent_dir )
        .map_err( CrateDocError::Io )
        .context( format!( "Failed to create output directory {}", parent_dir.display() ) )
        .err_with_report( &report )?;
    }
    fs::write( &output_md_abs_path, markdown_content )
      .map_err( CrateDocError::Io )
      .context( format!( "Failed to write Markdown documentation to {}", output_md_abs_path.display() ) )
      .err_with_report( &report )?;

    report.status = format!( "Markdown documentation generated successfully for `{crate_name}`" );

    Ok( report )
  }
}

crate::mod_interface!
{
  /// Generate documentation action.
  orphan use doc;
  /// Report for documentation generation.
  orphan use CrateDocReport;
  /// Error type for documentation generation.
  orphan use CrateDocError;
}