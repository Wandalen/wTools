//! Defines error types for the unilang instruction parser.
use std::fmt;

/// Represents the location of a parsing error.
#[derive(Debug, PartialEq, Clone)]
pub enum SourceLocation
{
  /// Location within a single string input.
  StrSpan
  {
    /// The starting byte index of the span in the original string.
    start : usize,
    /// The ending byte index (exclusive) of the span in the original string.
    end : usize,
  },
  /// Location within a segment of a slice input.
  SliceSegment
  {
    /// The index of the segment in the input slice.
    segment_index : usize,
    /// The starting byte index of the span within its segment.
    start_in_segment : usize,
    /// The ending byte index (exclusive) of the span within its segment.
    end_in_segment : usize,
  },
}

/// Specifies the kind of parsing error.
#[derive(Debug)]
pub enum ErrorKind
{
  // Note: Itemization errors are not directly wrapped from `strs_tools::string::split`
  // as `SplitIterator` does not return `Result`. Errors related to splitting/tokenizing
  // will be generated by the `unilang_instruction_parser`'s own logic if needed,
  // likely as `ErrorKind::Syntax`.
  /// General syntax error.
  Syntax(String),
  /// Unterminated quoted string.
  UnterminatedQuote,
  /// Invalid escape sequence within a string.
  InvalidEscapeSequence,
  // Future: Consider adding more specific syntax error kinds here as parser develops.
  // e.g., MissingNamedArgumentValue, UnexpectedToken, InvalidCommandPath, etc.
}

/// Represents an error encountered during parsing.
#[derive(Debug)]
pub struct ParseError
{
  /// The kind of error.
  pub kind : ErrorKind,
  /// The location of the error, if available.
  pub location : Option<SourceLocation>,
}

impl fmt::Display for ParseError
{
  fn fmt( &self, f : &mut fmt::Formatter<'_> ) -> fmt::Result
  {
    match &self.kind
    {
      ErrorKind::Syntax( msg ) => write!( f, "Syntax error: {}", msg )?,
      ErrorKind::UnterminatedQuote => write!( f, "Syntax error: Unterminated quote" )?,
      ErrorKind::InvalidEscapeSequence => write!( f, "Syntax error: Invalid escape sequence" )?,
    }
    if let Some( loc ) = &self.location
    {
      match loc
      {
        SourceLocation::StrSpan { start, end } =>
        {
          write!( f, " at bytes {}-{}", start, end )?;
        }
        SourceLocation::SliceSegment { segment_index, start_in_segment, end_in_segment } =>
        {
          write!( f, " in segment {} at bytes {}-{}", segment_index, start_in_segment, end_in_segment )?;
        }
      }
    }
    Ok( () )
  }
}

impl std::error::Error for ParseError
{
  fn source( &self ) -> Option< &( dyn std::error::Error + 'static ) >
  {
    // Currently, no wrapped errors are exposed as source.
    None
  }
}
// Removed: impl From<strs_tools::string::tokenizer_core::ParseError> for ParseError
// as strs_tools::string::split::SplitIterator does not return a compatible Result/Error.