# Task Plan: Implement `#[unilang::command]` Procedural Macro (Revised)

### Goal
*   To create a procedural attribute macro `#[unilang::command]` that simplifies the compile-time definition of `unilang` commands. The macro will parse attributes and an annotated Rust function to generate a `static unilang::data::CommandDefinition` and a **wrapper function**. This wrapper is critical as it bridges the gap between the user's simple function signature and the `unilang` interpreter's more complex, expected routine signature.

### Ubiquitous Language (Vocabulary)
*   **`unilang::command`**: The attribute macro to be implemented.
*   **`CommandDefinition`**: The target struct in the `unilang` crate that the macro will generate.
*   **`ArgumentDefinition`**: The struct representing a command's argument, which will be inferred from the annotated function's parameters.
*   **`User Function`**: The original Rust function annotated with `#[unilang::command]`.
*   **`Wrapper Function`**: A new function generated by the macro. It has the signature `fn(VerifiedCommand, ExecutionContext) -> Result<OutputData, ErrorData>` and contains the logic to call the `User Function`.
*   **`macro_tools`**: The primary dependency for implementing the procedural macro.
*   **`trybuild`**: The testing framework for verifying correct code generation and compile-time error reporting.

### Progress
*   **Roadmap Milestone:** M4.2: implement_extension_module_macros
*   **Primary Editable Crate:** `module/move/unilang_meta`
*   **Overall Progress:** 0/5 increments complete
*   **Increment Status:**
    *   ⚫ Increment 1: Project Setup and Basic Attribute Parsing
    *   ⚫ Increment 2: Infer `ArgumentDefinition`s from Function Parameters
    *   ⚫ Increment 3: Generate the Routine Wrapper Function
    *   ⚫ Increment 4: Generate Static `CommandDefinition`
    *   ⚫ Increment 5: Finalization and Advanced Features

### Permissions & Boundaries
*   **Mode:** code
*   **Run workspace-wise commands:** true
*   **Add transient comments:** true
*   **Additional Editable Crates:** None

### Relevant Context
*   Control Files to Reference:
    *   `module/move/unilang/spec.md` (Defines the structure of `CommandDefinition` and `ArgumentDefinition`)
*   Files to Include:
    *   `src/lib.rs` (The main file for the macro implementation)
    *   `Cargo.toml` (To manage dependencies)
    *   `tests/` (Directory for `trybuild` tests)
*   Crates for Documentation:
    *   `macro_tools`
    *   `unilang`

---

### API Guides for Dependencies

This section provides the necessary API information for dependencies, as direct access to their source code is unavailable.

#### 1. `unilang` Crate API Guide

The macro will generate instances of these `unilang` structs.

*   **`unilang::data::CommandDefinition`**:
    ```rust
    // The macro will generate a static instance of this struct.
    pub struct CommandDefinition 
{
        pub name: String,
        pub description: String,
        pub arguments: Vec<ArgumentDefinition>,
        pub routine_link: Option<String>, // For runtime, not used by this macro
        // The macro will also need to populate other fields like:
        // pub namespace: String,
        // pub hint: String,
        // pub permissions: Vec<String>,
        // pub status: Status, // An enum: Experimental, Stable, Deprecated
        // ... and others as per spec.md
    }
    ```

*   **`unilang::data::ArgumentDefinition`**:
    ```rust
    // The macro will generate a vector of these based on function parameters.
    pub struct ArgumentDefinition 
{
        pub name: String,
        pub description: String, // Can be populated from parameter attributes
        pub kind: Kind,
        pub optional: bool,
        pub multiple: bool,
        pub validation_rules: Vec<String>,
    }
    ```

*   **`unilang::data::Kind` Enum**:
    *   The macro must map Rust types to this enum.
    *   `String` -> `Kind::String`
    *   `i64`, `i32`, `usize` -> `Kind::Integer`
    *   `bool` -> `Kind::Boolean`
    *   `std::path::PathBuf` -> `Kind::Path`
    *   `Option<T>` -> The `Kind` for `T`, with `optional` set to `true` on the `ArgumentDefinition`.

*   **Expected Routine Signature**:
    *   The macro's generated **wrapper function** must have this exact signature to be callable by the `unilang` interpreter.
    ```rust
    fn(
        command: unilang::semantic::VerifiedCommand,
        context: unilang::interpreter::ExecutionContext
    ) -> Result<unilang::data::OutputData, unilang::data::ErrorData>
    ```

#### 2. `macro_tools` Crate API Guide

This is the primary toolkit for building the macro.

*   **Attribute Parsing**:
    *   Use `macro_tools::attr_prop::AttributePropertySyn` to parse key-value attributes like `name = "my_cmd"`.
    *   Define a struct to hold the parsed attributes and implement `syn::parse::Parse` for it.
    *   **Example Pattern:**
        ```rust
        // Define a marker for each property
        #[derive(Debug, Default, Clone, Copy)]
        pub struct NameMarker;
        impl macro_tools::attr_prop::AttributePropertyComponent for NameMarker 
{
            const KEYWORD: &'static str = "name";
        }
        // Create a type alias for the property
        pub type NameProperty = macro_tools::attr_prop::AttributePropertySyn<syn::LitStr, NameMarker>;

        // In your attribute parsing struct:
        // pub name: NameProperty,
        ```

*   **Code Analysis**:
    *   The main macro function receives `proc_macro::TokenStream`. Convert it to `proc_macro2::TokenStream`.
    *   Parse the item part into a `syn::ItemFn` using `syn::parse2(item_stream)`.
    *   Access function parameters via `item_fn.sig.inputs`. Each element is a `syn::FnArg`.

*   **Code Generation**:
    *   Use `macro_tools::quote::quote!` (or its alias `qt!`) to generate new `proc_macro2::TokenStream`.
    *   Use `#variable` to splice variables into the quoted code.
    *   Use `macro_tools::quote::format_ident!` to create new identifiers (e.g., for generated function names).

*   **Error Handling**:
    *   Use `macro_tools::diag::syn_err!(span, "message")` to create a `syn::Error`. The `span` should be taken from the relevant token to provide a helpful location for the error.
    *   Use `macro_tools::diag::return_syn_err!(...)` to exit the macro with a compile error immediately.

---

### Increments

##### Increment 1: Project Setup and Basic Attribute Parsing
*   **Goal:** Set up the proc-macro crate with necessary dependencies and implement parsing for the basic attributes of the `#[unilang::command]` macro.
*   **Steps:**
    1.  Modify `unilang_meta/Cargo.toml`:
        *   Add `unilang = { path = "../unilang" }` to `[dependencies]`.
        *   Add `trybuild = "1.0"` to `[dev-dependencies]`.
    2.  Create `tests/` directory and `tests/trybuild.rs` test harness.
    3.  In `src/lib.rs`, define the main proc-macro function `command(attr: TokenStream, item: TokenStream) -> TokenStream`.
    4.  Using the `macro_tools` API guide, define a struct `CommandAttributes` to parse `name = "..."`, `namespace = "..."`, and `hint = "..."`.
    5.  Implement the parsing logic. For this increment, the macro will only parse inputs and return the original function unmodified.
    6.  Create a `trybuild` test case (`tests/ui/01-basic-command-compiles.rs`) to verify the macro can be applied and parses correctly without errors.
*   **Increment Verification:**
    1.  Execute `timeout 90 cargo test -p unilang_meta` via `execute_command`. The `trybuild` test must pass.
*   **Commit Message:** "feat(meta): Initial setup for command macro and basic attribute parsing"

##### Increment 2: Infer `ArgumentDefinition`s from Function Parameters
*   **Goal:** Enhance the macro to inspect the parameters of the annotated function and generate the `quote!` block for a `Vec<unilang::data::ArgumentDefinition>`.
*   **Steps:**
    1.  In `src/lib.rs`, iterate over the `inputs` of the parsed `syn::ItemFn`.
    2.  For each `syn::FnArg`, extract the parameter name (`pat`) and type (`ty`).
    3.  Implement a helper function `fn map_type_to_kind(ty: &syn::Type) -> Result<(proc_macro2::TokenStream, bool), syn::Error>` which returns the `unilang::data::Kind` variant as a `TokenStream` and a boolean indicating if the type was an `Option`.
    4.  This function must handle `String`, `i64`, `bool`, `PathBuf`, and `Option<T>`. For `Option<T>`, it should recursively call itself on `T` and return `true` for the optional flag.
    5.  Generate the `quote!` block that constructs the `Vec<unilang::data::ArgumentDefinition>`.
    6.  Create a `trybuild` test (`tests/ui/02-argument-inference-compiles.rs`) that annotates a function with various parameter types. The test will use a `const` to hold a stringified version of the generated code, which can be asserted in a `.stdout` file.
*   **Increment Verification:**
    1.  Execute `timeout 90 cargo test -p unilang_meta` via `execute_command`. The new `trybuild` test must pass.
*   **Commit Message:** "feat(meta): Infer ArgumentDefinitions from function parameters"

##### Increment 3: Generate the Routine Wrapper Function
*   **Goal:** Generate the crucial wrapper function that translates from the `unilang` interpreter's call signature to the user's function signature.
*   **Steps:**
    1.  Use `format_ident!` to create a unique name for the wrapper, e.g., `__unilang_wrapper_{user_function_name}`.
    2.  Generate the wrapper function with the signature `fn(command: unilang::semantic::VerifiedCommand, context: unilang::interpreter::ExecutionContext) -> Result<unilang::data::OutputData, unilang::data::ErrorData>`.
    3.  Inside the wrapper, generate the argument marshalling logic:
        *   For each parameter of the `User Function`, generate a `let` binding.
        *   This binding will get the value from `command.arguments.get("arg_name")`.
        *   It will then match on the `unilang::types::Value` enum (e.g., `Value::Integer(i)`) to extract the raw Rust type.
        *   Handle `Option` types by checking if the argument exists in the map.
        *   If a required argument is missing or has the wrong type, return an `Err(ErrorData { ... })`.
    4.  Generate the call to the original `User Function` using the now-bound local variables.
    5.  Wrap the return value of the `User Function` in `Ok(OutputData { payload: result.to_string(), ... })`.
    6.  Create a `trybuild` test (`tests/ui/03-wrapper-generation-compiles.rs`) to ensure this complex generation results in valid, compilable code.
*   **Increment Verification:**
    1.  Execute `timeout 90 cargo test -p unilang_meta` via `execute_command`. The new `trybuild` test must pass.
*   **Commit Message:** "feat(meta): Generate routine wrapper function for signature translation"

##### Increment 4: Generate Static `CommandDefinition`
*   **Goal:** Generate the final `static CommandDefinition` instance and a unique registration function that ties everything together.
*   **Steps:**
    1.  Use `format_ident!` to create a unique name for the static definition, e.g., `__UNILANG_DEF_MY_COMMAND`.
    2.  Generate the `static` item, populating its fields with the parsed attributes (Increment 1) and the generated `Vec<ArgumentDefinition>` (Increment 2).
    3.  Set the `routine` field to be a function pointer to the **wrapper function** generated in Increment 3.
    4.  Generate a public registration function (e.g., `pub fn __unilang_register_my_command() -> &'static CommandDefinition`) that returns a reference to the static definition.
    5.  The macro will now output the original user function, the wrapper function, the static definition, and the registration function.
    6.  Create a `trybuild` test (`tests/ui/04-generates-full-definition.rs`) that calls the registration function and asserts that the fields of the returned `CommandDefinition` are correct.
*   **Increment Verification:**
    1.  Execute `timeout 90 cargo test -p unilang_meta` via `execute_command`. The new `trybuild` test must pass.
*   **Commit Message:** "feat(meta): Generate static CommandDefinition pointing to wrapper routine"

##### Increment 5: Finalization and Advanced Features
*   **Goal:** Add support for more complex attributes, improve error handling, and finalize the implementation.
*   **Steps:**
    1.  Extend the attribute parser to handle more `CommandDefinition` fields (`status`, `permissions`, etc.).
    2.  Enhance argument inference to allow overrides via an attribute on the function parameter itself, e.g., `#[unilang::arg(hint = "...", multiple = true)] src: String`.
    3.  Implement robust error handling using `macro_tools::diag::syn_err!` for invalid usage.
    4.  Add `trybuild` tests for all new features and, crucially, add failing test cases (`.rs` files that are expected to produce a specific `.stderr` output) to verify the error messages.
    5.  Add documentation to `src/lib.rs` explaining how to use the macro.
    6.  Perform the final Crate Conformance Check.
*   **Increment Verification:**
    1.  Execute `timeout 90 cargo test -p unilang_meta --all-targets`. All tests must pass.
    2.  Execute `timeout 90 cargo clippy -p unilang_meta -- -D warnings`. No warnings should be present.
*   **Commit Message:** "feat(meta): Add advanced attributes and robust error handling"

### Changelog
*   [Initial] Plan created to implement the `#[unilang::command]` procedural macro with a focus on generating a routine wrapper.