//! # Static Command Registry - Basic Compile-Time Example
//!
//! **This is the RECOMMENDED pattern for production applications.**
//!
//! This example demonstrates the proper way to use compile-time command registration:
//! Define commands in YAML, let the build system generate optimized static maps,
//! and include the generated code. No manual PHF construction needed!
//!
//! ## What You'll Learn
//!
//! - How to define commands in YAML format
//! - How the build system automatically generates static registries
//! - How to use `StaticCommandRegistry` for zero-overhead lookups
//! - Why this approach is 50x faster than runtime registration
//!
//! ## Prerequisites
//!
//! This example requires the `approach_yaml_single_build` or `approach_yaml_multi_build` feature.
//! The default configuration already enables multi-YAML build-time loading.
//!
//! ## Step 1: Create Command Definition YAML
//!
//! Create `static_01_commands.yaml` in your project root:
//!
//! ```yaml
//! - name: ".greet"
//!   namespace: ""
//!   description: "Greet someone by name"
//!   hint: "Greeting command"
//!   status: "stable"
//!   version: "1.0.0"
//!   arguments:
//!     - name: "name"
//!       kind: "String"
//!       description: "Person to greet"
//!       hint: "Name"
//!       attributes:
//!         optional: true
//!         default: "World"
//! ```
//!
//! ## Step 2: Build System Handles the Rest
//!
//! With `approach_yaml_single_build` or `approach_yaml_multi_build` enabled,
//! the build system automatically:
//! 1. Discovers your YAML files
//! 2. Generates optimized static command maps using Perfect Hash Functions
//! 3. Creates `static_commands.rs` in `OUT_DIR`
//!
//! No build.rs configuration needed for multi-YAML (default)!
//!
//! ## Performance Characteristics
//!
//! - **Lookup time**: ~80-100ns (O(1) with PHF)
//! - **Memory overhead**: Zero (compile-time only)
//! - **Binary size**: Minimal (static data section)
//! - **vs Runtime**: 50x faster than `HashMap` lookups (~4,000ns)

fn main()
{
  println!( "ğŸš€ Static Command Registry - Basic Compile-Time Example" );
  println!( "=======================================================" );
  println!();
  println!( "This example demonstrates the RECOMMENDED pattern:" );
  println!( "  1. Define commands in YAML" );
  println!( "  2. Build system generates static registry" );
  println!( "  3. Use StaticCommandRegistry for zero-overhead lookups" );
  println!();

  // Step 3: Include the generated static commands
  // The build system creates this file automatically from your YAML definitions
  println!( "âš ï¸  NOTE: This example requires static command generation." );
  println!( "    In a real project, you would have:" );
  println!( "    include!(concat!(env!(\"OUT_DIR\"), \"/static_commands.rs\"));" );
  println!();
  println!( "    This provides a `STATIC_COMMANDS` constant containing" );
  println!( "    all commands from your YAML files compiled into an" );
  println!( "    optimized static map." );
  println!();

  // For demonstration purposes, we'll show what the usage would look like:
  println!( "ğŸ“ Example Usage (pseudo-code):" );
  println!( "  ```rust" );
  println!( "  use unilang::prelude::*;" );
  println!();
  println!( "  // Generated by build system from YAML" );
  println!( "  include!(concat!(env!(\"OUT_DIR\"), \"/static_commands.rs\"));" );
  println!();
  println!( "  fn main() -> Result<(), unilang::Error> {{" );
  println!( "    // Create static registry (zero overhead)" );
  println!( "    let registry = StaticCommandRegistry::from_commands(&STATIC_COMMANDS);" );
  println!( "    let pipeline = Pipeline::new(registry);" );
  println!();
  println!( "    // Execute command (O(1) lookup, ~80ns)" );
  println!( "    let result = pipeline.process_command_simple(\".greet name::Alice\");" );
  println!( "    println!(\"Output: {{}}\", result.outputs[0].content);" );
  println!();
  println!( "    Ok(())" );
  println!( "  }}" );
  println!( "  ```" );
  println!();

  // Performance comparison
  println!( "âš¡ Performance Comparison:" );
  println!( "  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”" );
  println!( "  â”‚ Approach                â”‚ Lookup Time  â”‚ Memory Cost   â”‚" );
  println!( "  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤" );
  println!( "  â”‚ Static (compile-time)   â”‚ ~80-100ns    â”‚ Zero (static) â”‚" );
  println!( "  â”‚ Runtime (HashMap)       â”‚ ~4,000ns     â”‚ Heap allocs   â”‚" );
  println!( "  â”‚ Performance gain        â”‚ 50x faster   â”‚ -             â”‚" );
  println!( "  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" );
  println!();

  // Key benefits
  println!( "âœ… Key Benefits of Compile-Time Registration:" );
  println!( "  â€¢ 50x faster command lookups (80ns vs 4,000ns)" );
  println!( "  â€¢ Zero runtime memory allocations" );
  println!( "  â€¢ Compile-time validation catches errors early" );
  println!( "  â€¢ Smaller binary through dead code elimination" );
  println!( "  â€¢ No runtime dependency on YAML/JSON parsers" );
  println!();

  // How to actually use this
  println!( "ğŸ“š To Use This Pattern in Your Project:" );
  println!();
  println!( "  1. Add to Cargo.toml:" );
  println!( "     [dependencies]" );
  println!( "     unilang = \"0.28\"  # Multi-YAML enabled by default" );
  println!();
  println!( "  2. Create `unilang.commands.yaml` with your commands" );
  println!();
  println!( "  3. In main.rs:" );
  println!( "     include!(concat!(env!(\"OUT_DIR\"), \"/static_commands.rs\"));" );
  println!( "     let registry = StaticCommandRegistry::from_commands(&STATIC_COMMANDS);" );
  println!();
  println!( "  4. Build and run - the system handles everything else!" );
  println!();

  // Next steps
  println!( "ğŸ“ Next Examples to Explore:" );
  println!( "  â€¢ static_02_yaml_build_integration.rs - Multi-YAML file aggregation" );
  println!( "  â€¢ static_03_performance_comparison.rs - Detailed benchmarks" );
  println!( "  â€¢ static_04_multi_module_aggregation.rs - Module organization" );
  println!();

  println!( "âœ… Example explanation completed successfully" );
  println!();
  println!( "âš ï¸  Remember: NEVER manually construct PHF maps!" );
  println!( "    Always use YAML + build system for production code." );
}
