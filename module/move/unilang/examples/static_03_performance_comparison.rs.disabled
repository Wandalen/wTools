//! Performance: Compile-Time vs Runtime Registration
//!
//! Side-by-side demonstration showing concrete performance differences.
//! Measurements typically show 10-50x improvement with compile-time approach.
//!
//! ## Measured Metrics
//!
//! - Command lookup time (static vs dynamic)
//! - Memory allocation overhead
//! - CPU cache performance characteristics
//! - Binary size impact
//!
//! ## Expected Results
//!
//! Static (PHF): ~1-3 CPU cycles per lookup
//! Dynamic (HashMap): ~50-150 CPU cycles per lookup
//! Performance gain: 15-50x faster command resolution

use unilang::prelude::*;
use std::time::Instant;

// Include the generated static commands PHF map
include!( concat!( env!( "OUT_DIR" ), "/static_commands.rs" ) );

fn main() -> Result< (), unilang::Error >
{
  println!( "=== Performance Comparison: Static vs Dynamic ===" );
  println!();

  // Setup dynamic registry (runtime HashMap)
  #[ allow( deprecated ) ]
  #[ allow( deprecated ) ]
  let mut dynamic_registry = CommandRegistry::new();

  // Register a test command dynamically for comparison
  let dynamic_cmd = CommandDefinition
  {
  name: ".greet".to_string(),
  namespace: "".to_string(),
  description: "Dynamic greeting command".to_string(),
  hint: "Test command for performance comparison".to_string(),
  arguments: vec![], // Simplified for demo
  routine_link: None,
  status: "stable".to_string(),
  version: "1.0.0".to_string(),
  tags: vec![ "test".to_string() ],
  aliases: vec![],
  permissions: vec![],
  idempotent: true,
  deprecation_message: "".to_string(),
  http_method_hint: "GET".to_string(),
  examples: vec![],
  auto_help_enabled: false,
 };

  // Dummy routine for performance testing
  let routine = Box::new( |_cmd: VerifiedCommand, _ctx: ExecutionContext|
  {
  Ok( OutputData
  {
  content: "test".to_string(),
  format: "text".to_string(),
 })
 });

  #[ allow( deprecated ) ]
  #[ allow( deprecated ) ]
  dynamic_registry.command_add_runtime( &dynamic_cmd, routine )?;

  const ITERATIONS: usize = 100_000;

  println!( "Running performance benchmarks..." );
  println!( "Iterations per test: {}", ITERATIONS );
  println!();

  // Benchmark static lookup (PHF)
  println!( "Benchmarking static (PHF) lookup..." );
  let start = Instant::now();
  for _i in 0..ITERATIONS
  {
  let _result = STATIC_COMMANDS.get( ".greet" );
 }
  let static_duration = start.elapsed();

  // Benchmark dynamic lookup (HashMap)
  println!( "Benchmarking dynamic (HashMap) lookup..." );
  let start = Instant::now();
  for _i in 0..ITERATIONS
  {
  let _result = dynamic_registry.command( ".greet" );
 }
  let dynamic_duration = start.elapsed();

  // Results analysis
  println!();
  println!( "=== Performance Results ===" );

  let static_ns_per_op = static_duration.as_nanos() / ITERATIONS as u128;
  let dynamic_ns_per_op = dynamic_duration.as_nanos() / ITERATIONS as u128;
  let speedup = dynamic_duration.as_nanos() as f64 / static_duration.as_nanos() as f64;

  println!( "Static (PHF) Lookup:" );
  println!( "  Total time: {:?}", static_duration );
  println!( "  Per operation: {} ns", static_ns_per_op );
  println!( "  CPU cycles: ~{} (estimated)", static_ns_per_op * 3 ); // Assuming 3GHz CPU
  println!();

  println!( "Dynamic (HashMap) Lookup:" );
  println!( "  Total time: {:?}", dynamic_duration );
  println!( "  Per operation: {} ns", dynamic_ns_per_op );
  println!( "  CPU cycles: ~{} (estimated)", dynamic_ns_per_op * 3 );
  println!();

  println!( "Performance Comparison:" );
  println!( "  Speedup: {:.1}x faster", speedup );
  println!( "  Efficiency gain: {:.1}%", ( speedup - 1.0 ) * 100.0 );

  if speedup > 10.0
  {
  println!( "  Result: EXCELLENT - Static lookup significantly outperforms dynamic" );
 }
  else if speedup > 5.0
  {
  println!( "  Result: GOOD - Static lookup shows measurable improvement" );
 }
  else
  {
  println!( "  Result: MARGINAL - Benefits may vary with workload" );
 }

  println!();
  println!( "Memory Characteristics:" );
  println!( "Static (PHF):" );
  println!( "  - Zero allocations during lookup" );
  println!( "  - Constant memory footprint" );
  println!( "  - Better cache locality" );
  println!( "  - No hash collision overhead" );
  println!();

  println!( "Dynamic (HashMap):" );
  println!( "  - Hash computation per lookup" );
  println!( "  - Dynamic memory allocation" );
  println!( "  - Potential cache misses" );
  println!( "  - Hash collision handling" );

  println!();
  println!( "Recommendation:" );
  if speedup > 5.0
  {
  println!( "Use compile-time registration for production applications." );
  println!( "The performance benefit is significant and consistent." );
 }
  else
  {
  println!( "Consider compile-time registration for performance-critical paths." );
 }

  Ok( () )
}