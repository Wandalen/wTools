//! WebAssembly tests for UniLang REPL
//!
//! These tests verify that the WebAssembly bridge works correctly and can execute
//! commands in a browser-like environment.

#![cfg(target_arch = "wasm32")]

use wasm_bindgen_test::*;
use unilang_wasm_repl::{UniLangWasmRepl, log};

wasm_bindgen_test_configure!(run_in_browser);

/// Test basic REPL instantiation
#[wasm_bindgen_test]
fn test_repl_creation() {
  let repl = UniLangWasmRepl::new();
  
  // Should not panic and should create a valid instance
  // This test passes if the constructor completes without errors
  drop(repl);
}

/// Test help command execution
#[wasm_bindgen_test]
fn test_help_command() {
  let repl = UniLangWasmRepl::new();
  
  let result = repl.get_help();
  
  // Help should return some content (not empty)
  assert!(!result.is_empty(), "Help should return non-empty content");
  assert!(!result.contains("‚ùå"), "Help should not contain error markers");
}

/// Test basic command execution
#[wasm_bindgen_test]
fn test_command_execution() {
  let repl = UniLangWasmRepl::new();
  
  // Test the demo echo command
  let result = repl.execute_command(".demo.echo hello");
  
  // Should execute successfully
  assert!(!result.contains("‚ùå"), "Command should execute without errors");
  assert!(result.contains("‚úÖ"), "Command should indicate success");
}

/// Test invalid command handling
#[wasm_bindgen_test]
fn test_invalid_command() {
  let repl = UniLangWasmRepl::new();
  
  // Test an invalid command
  let result = repl.execute_command(".invalid.command");
  
  // Should return an error message
  assert!(result.contains("‚ùå"), "Invalid command should return error");
}

/// Test empty command handling
#[wasm_bindgen_test]
fn test_empty_command() {
  let repl = UniLangWasmRepl::new();
  
  // Test empty command
  let result = repl.execute_command("");
  
  // Should handle gracefully (either success or error, but no panic)
  assert!(!result.is_empty(), "Empty command should return some response");
}

/// Test calculator command
#[wasm_bindgen_test]
fn test_calculator_command() {
  let repl = UniLangWasmRepl::new();
  
  // Test the calc add command
  let result = repl.execute_command(".calc.add 5 3");
  
  // Should execute successfully
  assert!(!result.contains("‚ùå"), "Calc command should execute without errors");
  assert!(result.contains("‚úÖ"), "Calc command should indicate success");
}

/// Test JSON command loading functionality
#[wasm_bindgen_test]
fn test_json_command_loading() {
  let repl = UniLangWasmRepl::new();
  
  // Test JSON loading (even though it's not fully implemented)
  let result = repl.load_commands_json("{}");
  
  // Should return a response (even if not implemented)
  assert!(!result.is_empty(), "JSON loading should return a response");
  assert!(result.contains("‚úÖ"), "JSON loading should indicate some form of success");
}

/// Test utility logging function
#[wasm_bindgen_test]
fn test_log_function() {
  // This should not panic
  log("Test log message");
  
  // Test with empty string
  log("");
  
  // Test with special characters
  log("Test with üöÄ emojis and special chars: <>\"'&");
}

/// Test multiple command executions
#[wasm_bindgen_test]
fn test_multiple_commands() {
  let repl = UniLangWasmRepl::new();
  
  // Execute multiple commands in sequence
  let commands = vec![
    ".help",
    ".demo.echo test1",
    ".calc.add 1 2",
    ".demo.echo test2",
  ];
  
  for command in commands {
    let result = repl.execute_command(command);
    assert!(!result.is_empty(), "Command {} should return non-empty result", command);
  }
}

/// Test error handling with malformed commands
#[wasm_bindgen_test]
fn test_malformed_commands() {
  let repl = UniLangWasmRepl::new();
  
  let malformed_commands = vec![
    "no.dot.prefix",  // Missing leading dot
    "..",             // Only dots
    ".",              // Single dot
    ".demo.",         // Incomplete
    ".demo.echo.too.many.parts",
  ];
  
  for command in malformed_commands {
    let result = repl.execute_command(command);
    // Should handle gracefully without panicking
    assert!(!result.is_empty(), "Malformed command {} should return some response", command);
  }
}

/// Performance test for rapid command execution
#[wasm_bindgen_test]
fn test_performance_rapid_commands() {
  let repl = UniLangWasmRepl::new();
  
  // Execute the same command multiple times rapidly
  for i in 0..50 {
    let result = repl.execute_command(".demo.echo test");
    assert!(!result.is_empty(), "Rapid command {} should return result", i);
  }
}

/// Test WebAssembly-specific functionality
#[wasm_bindgen_test]
fn test_wasm_specific_features() {
  let repl = UniLangWasmRepl::new();
  
  // Test that filesystem commands are properly disabled/handled
  // These should either be rejected or handled gracefully
  let fs_commands = vec![
    ".file.read ./test.txt",
    ".dir.list /",
  ];
  
  for command in fs_commands {
    let result = repl.execute_command(command);
    // Should not panic - either error or graceful handling
    assert!(!result.is_empty(), "FS command {} should be handled", command);
  }
}