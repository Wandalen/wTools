//!
//! Pipeline utilities for common Unilang workflows.
//!
//! This module provides convenient helper functions that combine multiple
//! Unilang components to handle common use cases, making it easier to
//! integrate Unilang into applications.
//!
//! # REPL Implementation Insights
//!
//! The Pipeline is specifically designed for REPL (Read-Eval-Print Loop) applications:
//!
//! ## Stateless Operation
//! - **Critical**: All components (Parser, `SemanticAnalyzer`, Interpreter) are completely stateless
//! - Each `process_command` call is independent - no state accumulation between calls
//! - Memory usage remains constant regardless of session length
//! - Safe for long-running REPL sessions without memory leaks
//!
//! ## Performance Characteristics  
//! - Component reuse provides 20-50% performance improvement over creating new instances
//! - Static command registry lookups via PHF are zero-cost even with millions of commands
//! - Parsing overhead is minimal and constant-time for typical command lengths
//!
//! ## Error Isolation
//! - Command failures are isolated - one failed command doesn't affect subsequent commands
//! - Parse errors, semantic errors, and execution errors are all safely contained
//! - REPL sessions can continue indefinitely even with frequent command failures
//!
//! ## Interactive Argument Handling
//! - The `UNILANG_ARGUMENT_INTERACTIVE_REQUIRED` error is designed to be caught by REPL loops
//! - Interactive prompts should be handled at the REPL level, not within the pipeline
//! - Secure input (passwords, API keys) should never be logged or stored in pipeline state

/// Internal namespace.
mod private
{
  use crate::data::OutputData;
  use crate::error::Error;
  use crate::interpreter::{ ExecutionContext, Interpreter };
  use crate::registry::CommandRegistry;
  use crate::semantic::SemanticAnalyzer;
  use unilang_parser::{ Parser, UnilangParserOptions };

  ///
  /// Structured error types for better API consistency and error handling.
  ///
  /// This enum replaces string matching for common error patterns and provides
  /// type-safe access to error information for REPL applications and CLI tools.
  #[ derive( Debug, Clone, PartialEq ) ]
  #[allow(dead_code)]
  pub enum UnilangError
  {
    /// Command was not found, with optional suggestions for similar commands.
    CommandNotFound 
    { 
      /// The command that was not found
      command: String, 
      /// Suggested similar commands
      suggestions: Vec<String> 
    },
    /// An interactive argument is required and must be prompted from the user.
    InteractiveArgumentRequired 
    { 
      /// The argument name that requires interactive input
      argument: String, 
      /// The command that requires the interactive argument
      command: String 
    },
    /// A static command was called but has no executable routine.
    StaticCommandNoRoutine 
    { 
      /// The static command name
      command: String 
    },
    /// Command arguments are invalid.
    InvalidArguments 
    { 
      /// Error message describing the invalid arguments
      message: String 
    },
    /// Command execution failed.
    ExecutionFailure 
    { 
      /// Error message describing the execution failure
      message: String 
    },
    /// Help request (e.g., user typed '.' or command with '?').
    HelpRequest 
    { 
      /// List of available commands to show in help
      commands: Vec<String> 
    },
    /// Parse error occurred.
    ParseError 
    { 
      /// Error message describing the parse error
      message: String 
    },
    /// Semantic analysis error occurred.
    SemanticError 
    { 
      /// Error message describing the semantic analysis error
      message: String 
    },
    /// Generic error that doesn't fit other categories.
    Other 
    { 
      /// The error message
      message: String 
    },
  }

///
/// Result of processing a single command through the pipeline.
///
#[ derive( Debug, Clone ) ]
pub struct CommandResult
{
  /// The original command string that was processed.
  pub command : String,
  /// The outputs generated by the command execution.
  pub outputs : Vec< OutputData >,
  /// Whether the command succeeded.
  pub success : bool,
  /// Error message if the command failed.
  pub error : Option< String >,
}

impl CommandResult
{
  /// Returns true if command executed successfully.
  /// 
  /// This method provides a clear, single source of truth for success detection,
  /// eliminating the confusion between checking `success` field and `error` field.
  #[ must_use ]
  pub fn is_success( &self ) -> bool
  {
    self.error.is_none() && self.success
  }

  /// Returns true if command failed.
  /// 
  /// This is the logical complement of `is_success()`.
  #[ must_use ]
  pub fn is_error( &self ) -> bool
  {
    !self.is_success()
  }

  /// Returns error message if any.
  /// 
  /// Provides convenient access to error message without repeated Option handling.
  #[ must_use ]
  pub fn error_message( &self ) -> Option< &str >
  {
    self.error.as_deref()
  }

  /// Returns outputs if command succeeded, empty slice otherwise.
  /// 
  /// This prevents accessing potentially invalid outputs when command failed.
  #[ must_use ]
  pub fn outputs_or_empty( &self ) -> &[ OutputData ]
  {
    if self.is_success()
    {
      &self.outputs
    }
    else
    {
      &[]
    }
  }

  /// Parses the error message into a structured `UnilangError` type.
  /// 
  /// This enables type-safe error handling instead of fragile string matching.
  /// Returns None if the command succeeded.
  #[ must_use ]
  pub fn error_type( &self ) -> Option< UnilangError >
  {
    let error_msg = self.error.as_ref()?;
    
    // Parse interactive argument errors - handle both old and new formats
    if error_msg.contains( "UNILANG_ARGUMENT_INTERACTIVE_REQUIRED" ) 
      || error_msg.contains( "Interactive Argument Required" )
    {
      // Extract argument name and command from error message
      let argument = extract_interactive_argument( error_msg ).unwrap_or( "unknown" ).to_string();
      let command = extract_command_from_error( error_msg ).unwrap_or( &self.command ).to_string();
      return Some( UnilangError::InteractiveArgumentRequired { argument, command } );
    }

    // Parse help requests (when user types '.' or similar)
    if error_msg.contains( "Available commands:" )
    {
      let commands = extract_available_commands( error_msg );
      return Some( UnilangError::HelpRequest { commands } );
    }

    // Parse static command errors
    if error_msg.contains( "static command without an executable routine" )
    {
      let command = extract_command_from_error( error_msg ).unwrap_or( &self.command ).to_string();
      return Some( UnilangError::StaticCommandNoRoutine { command } );
    }

    // Parse command not found errors
    if error_msg.contains( "Command not found" ) || error_msg.contains( "No such command" )
    {
      let command = self.command.clone();
      let suggestions = extract_command_suggestions( error_msg );
      return Some( UnilangError::CommandNotFound { command, suggestions } );
    }

    // Parse different error types based on pipeline stage
    if error_msg.contains( "Parse error:" )
    {
      return Some( UnilangError::ParseError { message: error_msg.clone() } );
    }

    if error_msg.contains( "Semantic analysis error:" )
    {
      return Some( UnilangError::SemanticError { message: error_msg.clone() } );
    }

    if error_msg.contains( "Execution error:" )
    {
      return Some( UnilangError::ExecutionFailure { message: error_msg.clone() } );
    }

    // Default to Other for unrecognized patterns
    Some( UnilangError::Other { message: error_msg.clone() } )
  }

  /// Returns true if error indicates interactive input is required.
  /// 
  /// This is a convenience method for the common pattern of checking for
  /// interactive argument requirements in REPL applications.
  /// 
  /// # REPL Integration Example
  /// ```rust,ignore
  /// use unilang::prelude::*;
  /// 
  /// let result = pipeline.process_command_simple(".login username::john");
  /// 
  /// if result.requires_interactive_input() {
  ///     if let Some(arg_name) = result.interactive_argument() {
  ///         // Enhanced REPL: Use secure input with masking
  ///         #[cfg(feature = "enhanced_repl")]
  ///         {
  ///             use rustyline::DefaultEditor;
  ///             let mut rl = DefaultEditor::new()?;
  ///             let value = rl.readline(&format!("Enter {}: ", arg_name))?;
  ///             // Re-run command with interactive argument
  ///             let retry_cmd = format!("{} {}::{}", original_cmd, arg_name, value);
  ///             let retry_result = pipeline.process_command_simple(&retry_cmd);
  ///         }
  ///         
  ///         // Basic REPL: Standard input (visible)
  ///         #[cfg(all(feature = "repl", not(feature = "enhanced_repl")))]
  ///         {
  ///             use std::io::{self, Write};
  ///             print!("Enter {}: ", arg_name);
  ///             io::stdout().flush()?;
  ///             // ... handle input
  ///         }
  ///     }
  /// }
  /// ```
  /// 
  /// # Security Notes
  /// - Always use secure input methods for interactive arguments
  /// - Never log or store sensitive interactive values
  /// - Clear sensitive data from memory after use
  #[ must_use ]
  pub fn requires_interactive_input( &self ) -> bool
  {
    matches!( self.error_type(), Some( UnilangError::InteractiveArgumentRequired { .. } ) )
  }

  /// Returns the argument name that requires interactive input.
  /// 
  /// Returns None if this is not an interactive argument error.
  #[ must_use ]
  pub fn interactive_argument( &self ) -> Option< String >
  {
    if let Some( UnilangError::InteractiveArgumentRequired { argument, .. } ) = self.error_type()
    {
      Some( argument )
    }
    else
    {
      None
    }
  }

  /// Returns true if error contains help information.
  /// 
  /// This is useful for detecting when the user requested help (e.g., typed '.')
  /// versus when a genuine error occurred.
  /// 
  /// # REPL Integration Example
  /// ```rust,ignore
  /// use unilang::prelude::*;
  /// 
  /// let result = pipeline.process_command_simple(".");  // List all commands
  /// 
  /// if result.is_help_response() {
  ///     println!("📖 Available Commands:");
  ///     
  ///     if let Some(help_text) = result.help_content() {
  ///         // Enhanced REPL: Rich formatting
  ///         #[cfg(feature = "enhanced_repl")]
  ///         println!("{}", help_text);
  ///         
  ///         // Basic REPL: Plain text
  ///         #[cfg(all(feature = "repl", not(feature = "enhanced_repl")))]
  ///         println!("{}", help_text);
  ///     } else {
  ///         // Fallback to raw error message
  ///         println!("{}", result.error_message().unwrap_or("Help not available"));
  ///     }
  /// } else {
  ///     // Handle as genuine error
  ///     println!("❌ Error: {}", result.error_message().unwrap_or("Unknown error"));
  /// }
  /// ```
  /// 
  /// # Common Help Triggers
  /// - Typing `.` alone lists all commands
  /// - Typing `.command ?` shows help for specific command
  /// - Empty namespaces (e.g., `.nonexistent.`) may trigger help
  #[ must_use ]
  pub fn is_help_response( &self ) -> bool
  {
    matches!( self.error_type(), Some( UnilangError::HelpRequest { .. } ) )
  }

  /// Extracts formatted help content from error message.
  /// 
  /// Returns None if this is not a help request error.
  #[ must_use ]
  pub fn help_content( &self ) -> Option< String >
  {
    if let Some( UnilangError::HelpRequest { commands } ) = self.error_type()
    {
      Some( format_help_content( &commands ) )
    }
    else
    {
      None
    }
  }
}

/// Helper function to extract interactive argument name from error message.
fn extract_interactive_argument( error_msg : &str ) -> Option< &str >
{
  // Look for patterns like "The argument 'arg_name' is marked as interactive"
  if let Some( start ) = error_msg.find( "The argument '" )
  {
    let after = &error_msg[ start + "The argument '".len().. ];
    if let Some( end ) = after.find( '\'' )
    {
      return Some( &after[ ..end ] );
    }
  }
  
  // Fallback: look for "Interactive Argument Required: <arg_name>"
  if let Some( start ) = error_msg.find( "Interactive Argument Required:" )
  {
    let after_prefix = &error_msg[ start + "Interactive Argument Required:".len().. ];
    if let Some( arg_start ) = after_prefix.find( |c: char| !c.is_whitespace() )
    {
      let arg_part = &after_prefix[ arg_start.. ];
      if let Some( arg_end ) = arg_part.find( |c: char| c.is_whitespace() )
      {
        return Some( &arg_part[ ..arg_end ] );
      }
      return Some( arg_part );
    }
  }
  
  // Another fallback: look for "argument '" pattern
  if let Some( start ) = error_msg.find( "argument '" )
  {
    let after = &error_msg[ start + "argument '".len().. ];
    if let Some( end ) = after.find( '\'' )
    {
      return Some( &after[ ..end ] );
    }
  }
  
  None
}

/// Helper function to extract command name from error message.
fn extract_command_from_error( error_msg : &str ) -> Option< &str >
{
  // Look for "for command <name>" pattern
  if let Some( start ) = error_msg.find( "for command " )
  {
    let after = &error_msg[ start + "for command ".len().. ];
    if let Some( end ) = after.find( |c: char| c.is_whitespace() )
    {
      return Some( &after[ ..end ] );
    }
    return Some( after );
  }
  
  // Look for "command '<name>'" pattern  
  if let Some( start ) = error_msg.find( "command '" )
  {
    let after = &error_msg[ start + "command '".len().. ];
    if let Some( end ) = after.find( '\'' )
    {
      return Some( &after[ ..end ] );
    }
  }
  
  None
}

/// Helper function to extract available commands from help error message.
fn extract_available_commands( error_msg : &str ) -> Vec< String >
{
  let mut commands = Vec::new();
  let mut in_commands_section = false;
  
  for line in error_msg.lines()
  {
    let line = line.trim();
    
    if line.contains( "Available commands:" )
    {
      in_commands_section = true;
      continue;
    }
    
    if in_commands_section
    {
      // Stop if we hit an empty line or different section
      if line.is_empty() || line.starts_with( "Use" ) || line.starts_with( "For" )
      {
        break;
      }
      
      // Extract command names - they typically start with '.' 
      // Handle various indentation patterns
      if let Some( stripped ) = line.strip_prefix( '.' )
      {
        // Direct command line
        if let Some( cmd_end ) = stripped.find( ' ' )
        {
          commands.push( stripped[ ..cmd_end ].to_string() );
        }
        else
        {
          commands.push( stripped.to_string() );
        }
      }
      else if line.contains( '.' )
      {
        // Find the first '.' in the line and extract command
        if let Some( dot_pos ) = line.find( '.' )
        {
          let after_dot = &line[ dot_pos + 1.. ];
          if let Some( cmd_end ) = after_dot.find( ' ' )
          {
            commands.push( after_dot[ ..cmd_end ].to_string() );
          }
          else
          {
            commands.push( after_dot.to_string() );
          }
        }
      }
    }
  }
  
  commands
}

/// Helper function to extract command suggestions from error message.
fn extract_command_suggestions( error_msg : &str ) -> Vec< String >
{
  let mut suggestions = Vec::new();
  
  // Look for "Did you mean:" pattern
  if let Some( start ) = error_msg.find( "Did you mean:" )
  {
    let after = &error_msg[ start + "Did you mean:".len().. ];
    for word in after.split_whitespace()
    {
      if word.starts_with( '.' )
      {
        suggestions.push( word.trim_end_matches( ',' ).trim_end_matches( '?' ).to_string() );
      }
    }
  }
  
  suggestions
}

/// Helper function to format help content from command list.
fn format_help_content( commands : &[ String ] ) -> String
{
  if commands.is_empty()
  {
    "No commands available.".to_string()
  }
  else
  {
    let mut content = "Available commands:\n".to_string();
    for command in commands
    {
      content.push_str( &format!( "  .{}\n", command ) );
    }
    content
  }
}

///
/// Result of processing multiple commands through the pipeline.
///
#[ derive( Debug, Clone ) ]
pub struct BatchResult
{
  /// Results for each individual command.
  pub results : Vec< CommandResult >,
  /// Total number of commands processed.
  pub total_commands : usize,
  /// Number of commands that succeeded.
  pub successful_commands : usize,
  /// Number of commands that failed.
  pub failed_commands : usize,
}

impl BatchResult
{
  /// Returns true if all commands in the batch succeeded.
  #[ must_use ]
  pub fn all_succeeded( &self ) -> bool
  {
    self.failed_commands == 0
  }

  /// Returns true if any commands in the batch failed.
  #[ must_use ]
  pub fn any_failed( &self ) -> bool
  {
    self.failed_commands > 0
  }

  /// Returns the success rate as a percentage.
  #[ must_use ]
  pub fn success_rate( &self ) -> f64
  {
    if self.total_commands == 0
    {
      0.0
    }
    else
    {
      ( self.successful_commands as f64 / self.total_commands as f64 ) * 100.0
    }
  }
}

///
/// A high-level pipeline processor that combines parsing, semantic analysis, and execution.
///
/// This struct provides convenient methods for processing commands through the
/// complete Unilang pipeline, handling common patterns and error scenarios.
#[ allow( missing_debug_implementations ) ]
pub struct Pipeline
{
  parser : Parser,
  registry : CommandRegistry,
}

impl Pipeline
{
  ///
  /// Creates a new pipeline with the given command registry.
  ///
  #[ must_use ]
  pub fn new( registry : CommandRegistry ) -> Self
  {
    Self
    {
      parser : Parser::new( UnilangParserOptions::default() ),
      registry,
    }
  }

  ///
  /// Creates a new pipeline with custom parser options.
  ///
  #[ must_use ]
  pub fn with_parser_options( registry : CommandRegistry, parser_options : UnilangParserOptions ) -> Self
  {
    Self
    {
      parser : Parser::new( parser_options ),
      registry,
    }
  }

  ///
  /// Gets a reference to the command registry.
  ///
  #[ must_use ]
  pub fn registry( &self ) -> &CommandRegistry
  {
    &self.registry
  }

  ///
  /// Gets a mutable reference to the command registry.
  ///
  pub fn registry_mut( &mut self ) -> &mut CommandRegistry
  {
    &mut self.registry
  }

  ///
  /// Processes a single command string through the complete pipeline.
  ///
  /// This method handles parsing, semantic analysis, and execution in one call,
  /// returning a structured result with outputs or error information.
  ///
  /// # Arguments
  /// * `command_str` - The command string to process
  /// * `context` - The execution context (will be moved and consumed)
  ///
  /// # Examples
  /// ```rust
  /// use unilang::pipeline::Pipeline;
  /// use unilang::registry::CommandRegistry;
  /// use unilang::interpreter::ExecutionContext;
  ///
  /// let registry = CommandRegistry::new();
  /// let pipeline = Pipeline::new(registry);
  /// let context = ExecutionContext::default();
  ///
  /// let result = pipeline.process_command("help", context);
  /// ```
#[allow(clippy::needless_pass_by_value)]
  #[must_use] pub fn process_command( &self, command_str : &str, mut context : ExecutionContext ) -> CommandResult
  {
    let command = command_str.to_string();

    // Step 1: Parsing
    let instruction = match self.parser.parse_single_instruction( command_str )
    {
      Ok( instruction ) => instruction,
      Err( error ) =>
      {
        return CommandResult
        {
          command,
          outputs : vec![],
          success : false,
          error : Some( format!( "Parse error: {error}" ) ),
        };
      }
    };

    // Step 2: Semantic Analysis
    let instructions = [ instruction ];
    let analyzer = SemanticAnalyzer::new( &instructions, &self.registry );
    let verified_commands = match analyzer.analyze()
    {
      Ok( commands ) => commands,
      Err( error ) =>
      {
        return CommandResult
        {
          command,
          outputs : vec![],
          success : false,
          error : Some( format!( "Semantic analysis error: {error}" ) ),
        };
      }
    };

    // Step 3: Execution
    let interpreter = Interpreter::new( &verified_commands, &self.registry );
    match interpreter.run( &mut context )
    {
      Ok( outputs ) => CommandResult
      {
        command,
        outputs,
        success : true,
        error : None,
      },
      Err( error ) => CommandResult
      {
        command,
        outputs : vec![],
        success : false,
        error : Some( format!( "Execution error: {error}" ) ),
      },
    }
  }

  ///
  /// Processes a single command string with a default execution context.
  ///
  /// This is a convenience method that creates a default execution context
  /// for simple use cases.
  #[must_use] pub fn process_command_simple( &self, command_str : &str ) -> CommandResult
  {
    self.process_command( command_str, ExecutionContext::default() )
  }

  ///
  /// Processes multiple command strings as a batch.
  ///
  /// This method processes each command independently and returns a summary
  /// of the batch execution results. Commands are executed in order, and
  /// failure of one command does not stop execution of subsequent commands.
  ///
  /// # Arguments
  /// * `commands` - Slice of command strings to process
  /// * `context` - The execution context (will be cloned for each command)
  ///
  /// # Examples
  /// ```rust
  /// use unilang::pipeline::Pipeline;
  /// use unilang::registry::CommandRegistry;
  /// use unilang::interpreter::ExecutionContext;
  ///
  /// let registry = CommandRegistry::new();
  /// let pipeline = Pipeline::new(registry);
  /// let context = ExecutionContext::default();
  ///
  /// let commands = vec!["help", "echo hello", "invalid_command"];
  /// let batch_result = pipeline.process_batch(&commands, context);
  /// println!("Success rate: {:.1}%", batch_result.success_rate());
  /// ```
#[allow(clippy::needless_pass_by_value)]
  #[must_use] pub fn process_batch( &self, commands : &[ &str ], context : ExecutionContext ) -> BatchResult
  {
    let mut results = Vec::new();
    let mut successful = 0;
    let mut failed = 0;

    for &cmd_str in commands
    {
      let result = self.process_command( cmd_str, context.clone() );

      if result.success
      {
        successful += 1;
      }
      else
      {
        failed += 1;
      }

      results.push( result );
    }

    BatchResult
    {
      results,
      total_commands : commands.len(),
      successful_commands : successful,
      failed_commands : failed,
    }
  }

  ///
  /// Processes multiple command strings with early termination on failure.
  ///
  /// Unlike `process_batch`, this method stops processing commands as soon
  /// as one command fails, returning the results of commands processed up
  /// to that point.
  ///
  /// # Arguments
  /// * `commands` - Slice of command strings to process
  /// * `context` - The execution context (will be moved and mutated)
#[allow(clippy::needless_pass_by_value)]
  #[must_use] pub fn process_sequence( &self, commands : &[ &str ], context : ExecutionContext ) -> BatchResult
  {
    let mut results = Vec::new();
    let mut successful = 0;
    let mut failed = 0;

    for &cmd_str in commands
    {
      let result = self.process_command( cmd_str, context.clone() );

      if result.success
      {
        successful += 1;
      }
      else
      {
        failed += 1;
        results.push( result );
        break; // Stop on first failure
      }

      results.push( result );
    }

    BatchResult
    {
      results,
      total_commands : commands.len(),
      successful_commands : successful,
      failed_commands : failed,
    }
  }

  ///
  /// Validates a command string without executing it.
  ///
  /// This method runs the command through parsing and semantic analysis
  /// but does not execute it, useful for validation scenarios.
  ///
  /// # Returns
  /// - `Ok(())` if the command is valid and would be executable
  /// - `Err(Error)` if the command has syntax or semantic errors
  #[allow(clippy::missing_errors_doc)]
  pub fn validate_command( &self, command_str : &str ) -> Result< (), Error >
  {
    // Step 1: Parsing
    let instruction = self.parser.parse_single_instruction( command_str )?;

    // Step 2: Semantic Analysis
    let instructions = [ instruction ];
    let analyzer = SemanticAnalyzer::new( &instructions, &self.registry );
    analyzer.analyze()?;

    Ok(())
  }

  ///
  /// Validates multiple command strings without executing them.
  ///
  /// Returns a vector of validation results, one for each command.
  /// This is useful for batch validation scenarios.
  #[must_use] pub fn validate_batch( &self, commands : &[ &str ] ) -> Vec< Result< (), Error > >
  {
    commands.iter()
    .map( | &cmd_str | self.validate_command( cmd_str ) )
    .collect()
  }
}

///
/// Convenience function to process a single command with a registry.
///
/// This is a shorthand for creating a pipeline and processing one command.
/// Useful for simple scenarios where you don't need to reuse the pipeline.
/// Note: This creates a new parser each time, so it's less efficient than reusing a Pipeline.
///
/// # Examples
/// ```rust
/// use unilang::pipeline::process_single_command;
/// use unilang::registry::CommandRegistry;
/// use unilang::interpreter::ExecutionContext;
///
/// let registry = CommandRegistry::new();
/// let context = ExecutionContext::default();
/// let result = process_single_command("help", &registry, context);
/// ```
#[must_use] pub fn process_single_command
(
  command_str : &str,
  registry : &CommandRegistry,
  context : ExecutionContext,
)
->
CommandResult
{
  // Create parser and process command directly without Pipeline
  let parser = Parser::new( UnilangParserOptions::default() );
  let command = command_str.to_string();

  // Step 1: Parsing
  let instruction = match parser.parse_single_instruction( command_str )
  {
    Ok( instruction ) => instruction,
    Err( error ) =>
    {
      return CommandResult
      {
        command,
        outputs : vec![],
        success : false,
        error : Some( format!( "Parse error: {error}" ) ),
      };
    }
  };

  // Step 2: Semantic Analysis
  let instructions = [ instruction ];
  let analyzer = SemanticAnalyzer::new( &instructions, registry );
  let verified_commands = match analyzer.analyze()
  {
    Ok( commands ) => commands,
    Err( error ) =>
    {
      return CommandResult
      {
        command,
        outputs : vec![],
        success : false,
        error : Some( format!( "Semantic analysis error: {error}" ) ),
      };
    }
  };

  // Step 3: Execution
  let interpreter = Interpreter::new( &verified_commands, registry );
  let mut exec_context = context;
  match interpreter.run( &mut exec_context )
  {
    Ok( outputs ) => CommandResult
    {
      command,
      outputs,
      success : true,
      error : None,
    },
    Err( error ) => CommandResult
    {
      command,
      outputs : vec![],
      success : false,
      error : Some( format!( "Execution error: {error}" ) ),
    },
  }
}

///
/// Convenience function to validate a single command with a registry.
///
/// This is a shorthand for creating a pipeline and validating one command.
/// Note: This creates a new parser each time, so it's less efficient than reusing a Pipeline.
#[allow(clippy::missing_errors_doc)]
pub fn validate_single_command
(
  command_str : &str,
  registry : &CommandRegistry,
)
->
Result< (), Error >
{
  // Create parser and validate command directly without Pipeline
  let parser = Parser::new( UnilangParserOptions::default() );

  // Step 1: Parsing
  let instruction = parser.parse_single_instruction( command_str )?;

  // Step 2: Semantic Analysis
  let instructions = [ instruction ];
  let analyzer = SemanticAnalyzer::new( &instructions, registry );
  analyzer.analyze()?;

  Ok(())
}

}

mod_interface::mod_interface!
{
  exposed use private::UnilangError;
  exposed use private::CommandResult;
  exposed use private::BatchResult;
  exposed use private::Pipeline;
  exposed use private::process_single_command;
  exposed use private::validate_single_command;
  
  prelude use private::UnilangError;
  prelude use private::CommandResult;
  prelude use private::BatchResult;
  prelude use private::Pipeline;
  prelude use private::process_single_command;
}

#[ cfg( test ) ]
mod tests
{
  use super::*;
  use crate::data::{ ArgumentAttributes, ArgumentDefinition, CommandDefinition, Kind };
  use crate::types::Value;
  use crate::registry::CommandRegistry;
  use crate::interpreter::ExecutionContext;
  use crate::data::OutputData;

  fn create_test_registry() -> CommandRegistry
  {
    let mut registry = CommandRegistry::new();

    // Add a simple test command
    let test_command = CommandDefinition::former()
    .name( ".test" )
    .namespace( String::new() )
    .description( "Test command".to_string() )
    .hint( "Test command" )
    .status( "stable" )
    .version( "1.0.0" )
    .aliases( vec![] )
    .tags( vec![] )
    .permissions( vec![] )
    .idempotent( true )
    .deprecation_message( String::new() )
    .http_method_hint( "GET".to_string() )
    .examples( vec![] )
    .arguments( vec!
    [
      ArgumentDefinition::former()
      .name( "message" )
      .description( "Test message".to_string() )
      .kind( Kind::String )
      .hint( "Message to echo" )
      .attributes
      (
        ArgumentAttributes
        {
          optional: true,
          multiple: false,
          default: Some( "hello".to_string() ),
          sensitive: false,
          interactive: false,
        }
      )
      .validation_rules( vec![] )
      .aliases( vec![] )
      .tags( vec![] )
      .end()
    ])
    .end();

    let test_routine = Box::new( | cmd : crate::semantic::VerifiedCommand, _ctx |
    {
      let default_message = "hello".to_string();
      let message = cmd.arguments.get( "message" )
      .and_then( | v | if let Value::String( s ) = v { Some( s ) } else { None } )
      .unwrap_or( &default_message );

      Ok( OutputData
      {
        content : message.clone(),
        format : "text".to_string(),
      })
    });

    registry.command_add_runtime( &test_command, test_routine ).unwrap();
    registry
  }

  #[ test ]
  fn test_pipeline_process_command_success()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );
    let context = ExecutionContext::default();

    let result = pipeline.process_command( ".test world", context );

    assert!( result.success );
    assert!( result.error.is_none() );
    assert_eq!( result.outputs.len(), 1 );
    assert_eq!( result.outputs[ 0 ].content, "world" );
  }

  #[ test ]
  fn test_pipeline_process_command_parse_error()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );
    let context = ExecutionContext::default();

    // This should cause a parse error (invalid syntax)
    let result = pipeline.process_command( "invalid..syntax", context );

    assert!( !result.success );
    assert!( result.error.is_some() );
    assert!( result.error.as_ref().unwrap().contains( "Parse error" ) );
  }

  #[ test ]
  fn test_pipeline_process_command_semantic_error()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );
    let context = ExecutionContext::default();

    // This should cause a semantic error (command not found)
    let result = pipeline.process_command( "nonexistent_command", context );

    assert!( !result.success );
    assert!( result.error.is_some() );
    assert!( result.error.as_ref().unwrap().contains( "Semantic analysis error" ) );
  }

  #[ test ]
  fn test_pipeline_process_batch()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );
    let context = ExecutionContext::default();

    let commands = vec![ ".test hello", ".test world", "nonexistent" ];
    let batch_result = pipeline.process_batch( &commands, context );

    assert_eq!( batch_result.total_commands, 3 );
    assert_eq!( batch_result.successful_commands, 2 );
    assert_eq!( batch_result.failed_commands, 1 );
    assert!( !batch_result.all_succeeded() );
    assert!( batch_result.any_failed() );
    assert!( ( batch_result.success_rate() - 66.666_666 ).abs() < 0.001 );
  }

  #[ test ]
  fn test_pipeline_validate_command()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );

    // Valid command
    assert!( pipeline.validate_command( ".test hello" ).is_ok() );

    // Invalid command
    assert!( pipeline.validate_command( "nonexistent_command" ).is_err() );
  }

  #[ test ]
  fn test_convenience_functions()
  {
    let registry = create_test_registry();
    let context = ExecutionContext::default();

    // Test process_single_command
    let result = process_single_command( ".test hello", &registry, context );
    assert!( result.success );
    assert_eq!( result.outputs[ 0 ].content, "hello" );

    // Test validate_single_command
    assert!( validate_single_command( ".test hello", &registry ).is_ok() );
    assert!( validate_single_command( "nonexistent", &registry ).is_err() );
  }
}