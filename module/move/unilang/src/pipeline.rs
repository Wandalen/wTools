//!
//! Pipeline utilities for common Unilang workflows.
//!
//! This module provides convenient helper functions that combine multiple
//! Unilang components to handle common use cases, making it easier to
//! integrate Unilang into applications.
//!
//! # REPL Implementation Insights
//!
//! The Pipeline is specifically designed for REPL (Read-Eval-Print Loop) applications:
//!
//! ## Stateless Operation
//! - **Critical**: All components (Parser, SemanticAnalyzer, Interpreter) are completely stateless
//! - Each `process_command` call is independent - no state accumulation between calls
//! - Memory usage remains constant regardless of session length
//! - Safe for long-running REPL sessions without memory leaks
//!
//! ## Performance Characteristics  
//! - Component reuse provides 20-50% performance improvement over creating new instances
//! - Static command registry lookups via PHF are zero-cost even with millions of commands
//! - Parsing overhead is minimal and constant-time for typical command lengths
//!
//! ## Error Isolation
//! - Command failures are isolated - one failed command doesn't affect subsequent commands
//! - Parse errors, semantic errors, and execution errors are all safely contained
//! - REPL sessions can continue indefinitely even with frequent command failures
//!
//! ## Interactive Argument Handling
//! - The `UNILANG_ARGUMENT_INTERACTIVE_REQUIRED` error is designed to be caught by REPL loops
//! - Interactive prompts should be handled at the REPL level, not within the pipeline
//! - Secure input (passwords, API keys) should never be logged or stored in pipeline state

/// Internal namespace.
mod private
{
  use crate::data::OutputData;
  use crate::error::Error;
  use crate::interpreter::{ ExecutionContext, Interpreter };
  use crate::registry::CommandRegistry;
  use crate::semantic::SemanticAnalyzer;
  use unilang_parser::{ Parser, UnilangParserOptions };

///
/// Result of processing a single command through the pipeline.
///
#[ derive( Debug, Clone ) ]
pub struct CommandResult
{
  /// The original command string that was processed.
  pub command : String,
  /// The outputs generated by the command execution.
  pub outputs : Vec< OutputData >,
  /// Whether the command succeeded.
  pub success : bool,
  /// Error message if the command failed.
  pub error : Option< String >,
}

///
/// Result of processing multiple commands through the pipeline.
///
#[ derive( Debug, Clone ) ]
pub struct BatchResult
{
  /// Results for each individual command.
  pub results : Vec< CommandResult >,
  /// Total number of commands processed.
  pub total_commands : usize,
  /// Number of commands that succeeded.
  pub successful_commands : usize,
  /// Number of commands that failed.
  pub failed_commands : usize,
}

impl BatchResult
{
  /// Returns true if all commands in the batch succeeded.
  #[ must_use ]
  pub fn all_succeeded( &self ) -> bool
  {
    self.failed_commands == 0
  }

  /// Returns true if any commands in the batch failed.
  #[ must_use ]
  pub fn any_failed( &self ) -> bool
  {
    self.failed_commands > 0
  }

  /// Returns the success rate as a percentage.
  #[ must_use ]
  pub fn success_rate( &self ) -> f64
  {
    if self.total_commands == 0
    {
      0.0
    }
    else
    {
      ( self.successful_commands as f64 / self.total_commands as f64 ) * 100.0
    }
  }
}

///
/// A high-level pipeline processor that combines parsing, semantic analysis, and execution.
///
/// This struct provides convenient methods for processing commands through the
/// complete Unilang pipeline, handling common patterns and error scenarios.
#[ allow( missing_debug_implementations ) ]
pub struct Pipeline
{
  parser : Parser,
  registry : CommandRegistry,
}

impl Pipeline
{
  ///
  /// Creates a new pipeline with the given command registry.
  ///
  #[ must_use ]
  pub fn new( registry : CommandRegistry ) -> Self
  {
    Self
    {
      parser : Parser::new( UnilangParserOptions::default() ),
      registry,
    }
  }

  ///
  /// Creates a new pipeline with custom parser options.
  ///
  #[ must_use ]
  pub fn with_parser_options( registry : CommandRegistry, parser_options : UnilangParserOptions ) -> Self
  {
    Self
    {
      parser : Parser::new( parser_options ),
      registry,
    }
  }

  ///
  /// Gets a reference to the command registry.
  ///
  #[ must_use ]
  pub fn registry( &self ) -> &CommandRegistry
  {
    &self.registry
  }

  ///
  /// Gets a mutable reference to the command registry.
  ///
  pub fn registry_mut( &mut self ) -> &mut CommandRegistry
  {
    &mut self.registry
  }

  ///
  /// Processes a single command string through the complete pipeline.
  ///
  /// This method handles parsing, semantic analysis, and execution in one call,
  /// returning a structured result with outputs or error information.
  ///
  /// # Arguments
  /// * `command_str` - The command string to process
  /// * `context` - The execution context (will be moved and consumed)
  ///
  /// # Examples
  /// ```rust
  /// use unilang::pipeline::Pipeline;
  /// use unilang::registry::CommandRegistry;
  /// use unilang::interpreter::ExecutionContext;
  ///
  /// let registry = CommandRegistry::new();
  /// let pipeline = Pipeline::new(registry);
  /// let context = ExecutionContext::default();
  ///
  /// let result = pipeline.process_command("help", context);
  /// ```
  #[must_use] pub fn process_command( &self, command_str : &str, mut context : ExecutionContext ) -> CommandResult
  {
    let command = command_str.to_string();

    // Step 1: Parsing
    let instruction = match self.parser.parse_single_instruction( command_str )
    {
      Ok( instruction ) => instruction,
      Err( error ) =>
      {
        return CommandResult
        {
          command,
          outputs : vec![],
          success : false,
          error : Some( format!( "Parse error: {error}" ) ),
        };
      }
    };

    // Step 2: Semantic Analysis
    let instructions = [ instruction ];
    let analyzer = SemanticAnalyzer::new( &instructions, &self.registry );
    let verified_commands = match analyzer.analyze()
    {
      Ok( commands ) => commands,
      Err( error ) =>
      {
        return CommandResult
        {
          command,
          outputs : vec![],
          success : false,
          error : Some( format!( "Semantic analysis error: {error}" ) ),
        };
      }
    };

    // Step 3: Execution
    let interpreter = Interpreter::new( &verified_commands, &self.registry );
    match interpreter.run( &mut context )
    {
      Ok( outputs ) => CommandResult
      {
        command,
        outputs,
        success : true,
        error : None,
      },
      Err( error ) => CommandResult
      {
        command,
        outputs : vec![],
        success : false,
        error : Some( format!( "Execution error: {error}" ) ),
      },
    }
  }

  ///
  /// Processes a single command string with a default execution context.
  ///
  /// This is a convenience method that creates a default execution context
  /// for simple use cases.
  #[must_use] pub fn process_command_simple( &self, command_str : &str ) -> CommandResult
  {
    self.process_command( command_str, ExecutionContext::default() )
  }

  ///
  /// Processes multiple command strings as a batch.
  ///
  /// This method processes each command independently and returns a summary
  /// of the batch execution results. Commands are executed in order, and
  /// failure of one command does not stop execution of subsequent commands.
  ///
  /// # Arguments
  /// * `commands` - Slice of command strings to process
  /// * `context` - The execution context (will be cloned for each command)
  ///
  /// # Examples
  /// ```rust
  /// use unilang::pipeline::Pipeline;
  /// use unilang::registry::CommandRegistry;
  /// use unilang::interpreter::ExecutionContext;
  ///
  /// let registry = CommandRegistry::new();
  /// let pipeline = Pipeline::new(registry);
  /// let context = ExecutionContext::default();
  ///
  /// let commands = vec!["help", "echo hello", "invalid_command"];
  /// let batch_result = pipeline.process_batch(&commands, context);
  /// println!("Success rate: {:.1}%", batch_result.success_rate());
  /// ```
  #[must_use] pub fn process_batch( &self, commands : &[ &str ], context : ExecutionContext ) -> BatchResult
  {
    let mut results = Vec::new();
    let mut successful = 0;
    let mut failed = 0;

    for &cmd_str in commands
    {
      let result = self.process_command( cmd_str, context.clone() );

      if result.success
      {
        successful += 1;
      }
      else
      {
        failed += 1;
      }

      results.push( result );
    }

    BatchResult
    {
      results,
      total_commands : commands.len(),
      successful_commands : successful,
      failed_commands : failed,
    }
  }

  ///
  /// Processes multiple command strings with early termination on failure.
  ///
  /// Unlike `process_batch`, this method stops processing commands as soon
  /// as one command fails, returning the results of commands processed up
  /// to that point.
  ///
  /// # Arguments
  /// * `commands` - Slice of command strings to process
  /// * `context` - The execution context (will be moved and mutated)
  #[must_use] pub fn process_sequence( &self, commands : &[ &str ], context : ExecutionContext ) -> BatchResult
  {
    let mut results = Vec::new();
    let mut successful = 0;
    let mut failed = 0;

    for &cmd_str in commands
    {
      let result = self.process_command( cmd_str, context.clone() );

      if result.success
      {
        successful += 1;
      }
      else
      {
        failed += 1;
        results.push( result );
        break; // Stop on first failure
      }

      results.push( result );
    }

    BatchResult
    {
      results,
      total_commands : commands.len(),
      successful_commands : successful,
      failed_commands : failed,
    }
  }

  ///
  /// Validates a command string without executing it.
  ///
  /// This method runs the command through parsing and semantic analysis
  /// but does not execute it, useful for validation scenarios.
  ///
  /// # Returns
  /// - `Ok(())` if the command is valid and would be executable
  /// - `Err(Error)` if the command has syntax or semantic errors
  pub fn validate_command( &self, command_str : &str ) -> Result< (), Error >
  {
    // Step 1: Parsing
    let instruction = self.parser.parse_single_instruction( command_str )?;

    // Step 2: Semantic Analysis
    let instructions = [ instruction ];
    let analyzer = SemanticAnalyzer::new( &instructions, &self.registry );
    analyzer.analyze()?;

    Ok(())
  }

  ///
  /// Validates multiple command strings without executing them.
  ///
  /// Returns a vector of validation results, one for each command.
  /// This is useful for batch validation scenarios.
  #[must_use] pub fn validate_batch( &self, commands : &[ &str ] ) -> Vec< Result< (), Error > >
  {
    commands.iter()
    .map( | &cmd_str | self.validate_command( cmd_str ) )
    .collect()
  }
}

///
/// Convenience function to process a single command with a registry.
///
/// This is a shorthand for creating a pipeline and processing one command.
/// Useful for simple scenarios where you don't need to reuse the pipeline.
/// Note: This creates a new parser each time, so it's less efficient than reusing a Pipeline.
///
/// # Examples
/// ```rust
/// use unilang::pipeline::process_single_command;
/// use unilang::registry::CommandRegistry;
/// use unilang::interpreter::ExecutionContext;
///
/// let registry = CommandRegistry::new();
/// let context = ExecutionContext::default();
/// let result = process_single_command("help", &registry, context);
/// ```
#[must_use] pub fn process_single_command
(
  command_str : &str,
  registry : &CommandRegistry,
  context : ExecutionContext,
)
->
CommandResult
{
  // Create parser and process command directly without Pipeline
  let parser = Parser::new( UnilangParserOptions::default() );
  let command = command_str.to_string();

  // Step 1: Parsing
  let instruction = match parser.parse_single_instruction( command_str )
  {
    Ok( instruction ) => instruction,
    Err( error ) =>
    {
      return CommandResult
      {
        command,
        outputs : vec![],
        success : false,
        error : Some( format!( "Parse error: {error}" ) ),
      };
    }
  };

  // Step 2: Semantic Analysis
  let instructions = [ instruction ];
  let analyzer = SemanticAnalyzer::new( &instructions, registry );
  let verified_commands = match analyzer.analyze()
  {
    Ok( commands ) => commands,
    Err( error ) =>
    {
      return CommandResult
      {
        command,
        outputs : vec![],
        success : false,
        error : Some( format!( "Semantic analysis error: {error}" ) ),
      };
    }
  };

  // Step 3: Execution
  let interpreter = Interpreter::new( &verified_commands, registry );
  let mut exec_context = context;
  match interpreter.run( &mut exec_context )
  {
    Ok( outputs ) => CommandResult
    {
      command,
      outputs,
      success : true,
      error : None,
    },
    Err( error ) => CommandResult
    {
      command,
      outputs : vec![],
      success : false,
      error : Some( format!( "Execution error: {error}" ) ),
    },
  }
}

///
/// Convenience function to validate a single command with a registry.
///
/// This is a shorthand for creating a pipeline and validating one command.
/// Note: This creates a new parser each time, so it's less efficient than reusing a Pipeline.
pub fn validate_single_command
(
  command_str : &str,
  registry : &CommandRegistry,
)
->
Result< (), Error >
{
  // Create parser and validate command directly without Pipeline
  let parser = Parser::new( UnilangParserOptions::default() );

  // Step 1: Parsing
  let instruction = parser.parse_single_instruction( command_str )?;

  // Step 2: Semantic Analysis
  let instructions = [ instruction ];
  let analyzer = SemanticAnalyzer::new( &instructions, registry );
  analyzer.analyze()?;

  Ok(())
}

}

mod_interface::mod_interface!
{
  exposed use private::CommandResult;
  exposed use private::BatchResult;
  exposed use private::Pipeline;
  exposed use private::process_single_command;
  exposed use private::validate_single_command;
  
  prelude use private::CommandResult;
  prelude use private::BatchResult;
  prelude use private::Pipeline;
  prelude use private::process_single_command;
}

#[ cfg( test ) ]
mod tests
{
  use super::*;
  use crate::data::{ ArgumentAttributes, ArgumentDefinition, CommandDefinition, Kind };
  use crate::types::Value;
  use crate::registry::CommandRegistry;
  use crate::interpreter::ExecutionContext;
  use crate::data::OutputData;

  fn create_test_registry() -> CommandRegistry
  {
    let mut registry = CommandRegistry::new();

    // Add a simple test command
    let test_command = CommandDefinition::former()
    .name( "test" )
    .namespace( String::new() )
    .description( "Test command".to_string() )
    .hint( "Test command" )
    .status( "stable" )
    .version( "1.0.0" )
    .aliases( vec![] )
    .tags( vec![] )
    .permissions( vec![] )
    .idempotent( true )
    .deprecation_message( String::new() )
    .http_method_hint( "GET".to_string() )
    .examples( vec![] )
    .arguments( vec!
    [
      ArgumentDefinition::former()
      .name( "message" )
      .description( "Test message".to_string() )
      .kind( Kind::String )
      .hint( "Message to echo" )
      .attributes
      (
        ArgumentAttributes
        {
          optional: true,
          multiple: false,
          default: Some( "hello".to_string() ),
          sensitive: false,
          interactive: false,
        }
      )
      .validation_rules( vec![] )
      .aliases( vec![] )
      .tags( vec![] )
      .end()
    ])
    .end();

    let test_routine = Box::new( | cmd : crate::semantic::VerifiedCommand, _ctx |
    {
      let default_message = "hello".to_string();
      let message = cmd.arguments.get( "message" )
      .and_then( | v | if let Value::String( s ) = v { Some( s ) } else { None } )
      .unwrap_or( &default_message );

      Ok( OutputData
      {
        content : message.clone(),
        format : "text".to_string(),
      })
    });

    registry.command_add_runtime( &test_command, test_routine ).unwrap();
    registry
  }

  #[ test ]
  fn test_pipeline_process_command_success()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );
    let context = ExecutionContext::default();

    let result = pipeline.process_command( "test world", context );

    assert!( result.success );
    assert!( result.error.is_none() );
    assert_eq!( result.outputs.len(), 1 );
    assert_eq!( result.outputs[ 0 ].content, "world" );
  }

  #[ test ]
  fn test_pipeline_process_command_parse_error()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );
    let context = ExecutionContext::default();

    // This should cause a parse error (invalid syntax)
    let result = pipeline.process_command( "invalid..syntax", context );

    assert!( !result.success );
    assert!( result.error.is_some() );
    assert!( result.error.as_ref().unwrap().contains( "Parse error" ) );
  }

  #[ test ]
  fn test_pipeline_process_command_semantic_error()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );
    let context = ExecutionContext::default();

    // This should cause a semantic error (command not found)
    let result = pipeline.process_command( "nonexistent_command", context );

    assert!( !result.success );
    assert!( result.error.is_some() );
    assert!( result.error.as_ref().unwrap().contains( "Semantic analysis error" ) );
  }

  #[ test ]
  fn test_pipeline_process_batch()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );
    let context = ExecutionContext::default();

    let commands = vec![ "test hello", "test world", "nonexistent" ];
    let batch_result = pipeline.process_batch( &commands, context );

    assert_eq!( batch_result.total_commands, 3 );
    assert_eq!( batch_result.successful_commands, 2 );
    assert_eq!( batch_result.failed_commands, 1 );
    assert!( !batch_result.all_succeeded() );
    assert!( batch_result.any_failed() );
    assert!( ( batch_result.success_rate() - 66.666_666 ).abs() < 0.001 );
  }

  #[ test ]
  fn test_pipeline_validate_command()
  {
    let registry = create_test_registry();
    let pipeline = Pipeline::new( registry );

    // Valid command
    assert!( pipeline.validate_command( "test hello" ).is_ok() );

    // Invalid command
    assert!( pipeline.validate_command( "nonexistent_command" ).is_err() );
  }

  #[ test ]
  fn test_convenience_functions()
  {
    let registry = create_test_registry();
    let context = ExecutionContext::default();

    // Test process_single_command
    let result = process_single_command( "test hello", &registry, context );
    assert!( result.success );
    assert_eq!( result.outputs[ 0 ].content, "hello" );

    // Test validate_single_command
    assert!( validate_single_command( "test hello", &registry ).is_ok() );
    assert!( validate_single_command( "nonexistent", &registry ).is_err() );
  }
}