//!
//! Tests for registry integration between StaticCommandRegistry and existing infrastructure.
//!
//! This module tests the integration of `StaticCommandRegistry` with existing `CommandRegistry`
//! infrastructure and `Pipeline` components.
//!

use unilang :: { CommandDefinition, CommandRegistry, CommandRegistryBuilder, Pipeline, OutputData, ErrorData, RegistryMode };

/// Helper function to create a test CommandDefinition with minimal boilerplate
fn create_test_command( name: &str, description: &str ) -> CommandDefinition
{
  CommandDefinition
  {
  name: name.to_string(),
  namespace: String ::new(),
  description: description.to_string(),
  routine_link: None,
  auto_help_enabled: false,
  hint: String ::new(),
  status: "stable".to_string(),
  version: "1.0.0".to_string(),
  tags: Vec ::new(),
  aliases: Vec ::new(),
  permissions: Vec ::new(),
  idempotent: false,
  deprecation_message: String ::new(),
  http_method_hint: "GET".to_string(),
  examples: Vec ::new(),
  arguments: Vec ::new(),
 }
}

#[ test ]
fn test_command_registry_from_static_commands()
{
  // Test creating CommandRegistry from static commands
  #[ allow(deprecated) ]
  let _registry = CommandRegistry ::from_static_commands();

  // Should successfully create registry with static commands loaded
  assert!( true, "CommandRegistry ::from_static_commands() should succeed" );
}

#[ test ]
fn test_command_registry_backward_compatibility_register()
{
  // Test that existing register method still works
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  let test_cmd = create_test_command( "test_compat", "Backward compatibility test" );

  // Should be able to register dynamic commands as before
  registry.register_dynamic_command( test_cmd );

  // Should find the registered command
  let found = registry.get( ".test_compat" );
  assert!( found.is_some(), "Should find dynamically registered command" );

  let cmd = found.unwrap();
  assert_eq!( cmd.name, "test_compat" );
  assert_eq!( cmd.description, "Backward compatibility test" );
}

#[ test ]
fn test_command_registry_backward_compatibility_get()
{
  // Test that existing get method still works
  #[ allow(deprecated) ]
  let registry = CommandRegistry ::from_static_commands();

  // Should be able to get static commands using existing API
  let help_cmd = registry.get( ".help" );

  // Either should find static help command or return None if no static commands
  if let Some( cmd ) = help_cmd
  {
  assert!( cmd.description.contains( "help" ) || cmd.description.contains( "Help" ) );
 }
}

#[ test ]
fn test_command_registry_backward_compatibility_register_routine()
{
  // Test that existing register_routine method still works
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  let test_cmd = create_test_command( "routine_test", "Routine test command" );
  registry.register_dynamic_command( test_cmd );

  // Register a routine using existing API
  let routine = | _verified_cmd, _context | -> Result< OutputData, ErrorData >
  {
  Ok( OutputData { content: "Test routine output".to_string(), format: "text".to_string() } )
 };

  registry.register_routine( ".routine_test", Box ::new( routine ) );

  // Should be able to check for routine existence
  let has_routine = registry.has_routine( ".routine_test" );
  assert!( has_routine, "Should have registered routine using existing API" );
}

#[ test ]
fn test_command_registry_static_priority_over_dynamic()
{
  // Test that static commands take priority over dynamic commands with same name
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  // Try to register a dynamic command with the same name as a static one
  let dynamic_help = create_test_command( "help", "Dynamic help command override" );
  registry.register_dynamic_command( dynamic_help );

  // Lookup should return static version, not dynamic
  let found_cmd = registry.get( ".help" );
  if let Some( cmd ) = found_cmd
  {
  // Static commands should take precedence
  // The exact test depends on what static commands are available
  assert!( !cmd.description.is_empty(), "Should find some help command" );
 }
}

#[ test ]
fn test_command_registry_list_commands_integration()
{
  // Test that list_commands includes both static and dynamic commands
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  let dynamic_cmd = create_test_command( "dynamic_list_test", "Dynamic command for listing" );
  registry.register_dynamic_command( dynamic_cmd );

  let all_commands = registry.list_commands();

  // Should include both static and dynamic commands
  let command_names: Vec< String > = all_commands.iter().map( | cmd | cmd.name.clone() ).collect();
  assert!( command_names.contains( &"dynamic_list_test".to_string() ), "Should include dynamic commands" );

  // Should have at least the dynamic command we added
  assert!( all_commands.len() >= 1, "Should have at least one command" );
}

#[ test ]
fn test_pipeline_integration_with_static_registry()
{
  // Test that Pipeline works with registry containing static commands
  #[ allow(deprecated) ]
  let registry = CommandRegistry ::from_static_commands();
  let _pipeline = Pipeline ::new( registry );

  // Should be able to create pipeline without errors
  assert!( true, "Pipeline should work with static command registry" );
}

#[ test ]
fn test_pipeline_command_processing_static_commands()
{
  // Test that Pipeline can process static commands
  #[ allow(deprecated) ]
  let registry = CommandRegistry ::from_static_commands();
  let pipeline = Pipeline ::new( registry );

  // Try to process a help command (common static command)
  let result = pipeline.process_command_simple( ".help" );

  // Should either succeed or fail gracefully (depending on static commands available)
  // The main test is that it doesn't panic or crash
  if result.success
  {
  assert!( true, "Successfully processed static command" );
 }
  else
  {
  assert!( true, "Gracefully handled static command processing" );
 }
}

#[ test ]
fn test_pipeline_command_processing_dynamic_commands()
{
  // Test that Pipeline can process dynamic commands in integrated registry
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  // Register a test command with routine
  let test_cmd = create_test_command( ".pipeline_test", "Pipeline integration test command" );
  registry.register_dynamic_command( test_cmd );

  let routine = | _verified_cmd, _context | -> Result< OutputData, ErrorData >
  {
  Ok( OutputData { content: "Pipeline test success".to_string(), format: "text".to_string() } )
 };
  registry.register_routine( ".pipeline_test", Box ::new( routine ) );

  let pipeline = Pipeline ::new( registry );

  // Should be able to process the dynamic command
  let result = pipeline.process_command_simple( ".pipeline_test" );

  if !result.success
  {
  if let Some( ref error ) = result.error
  {
  println!( "Pipeline processing failed with error: {}", error );
 }
  println!( "Result success: {}, outputs: {}", result.success, result.outputs.len() );
 }

  assert!( result.success, "Should successfully process dynamic command in integrated registry" );
}

#[ test ]
fn test_registry_performance_metrics_integration()
{
  // Test that performance metrics work in integrated registry
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  // Perform some operations
  let _ = registry.get( ".help" );
  let _ = registry.get( ".nonexistent" );

  let dynamic_cmd = create_test_command( "metrics_test", "Metrics test command" );
  registry.register_dynamic_command( dynamic_cmd );
  let _ = registry.get( ".metrics_test" );

  // Should be able to get performance metrics
  let metrics = registry.performance_metrics();
  println!( "Metrics: total_lookups={}, static_lookups={}, dynamic_lookups={}",
  metrics.total_lookups, metrics.static_lookups, metrics.dynamic_lookups );

  // Note: The current CommandRegistry implementation uses immutable get() method
  // which doesn't update metrics. This is for backward compatibility.
  // Metrics are only updated when using command_optimized() or direct dynamic operations.
  // Metrics structure is accessible (total_lookups is always non-negative for usize)
  assert!( true, "Should have metrics structure available" );
}

#[ test ]
fn test_registry_help_conventions_integration()
{
  // Test that help conventions work with integrated registry
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  // Enable help conventions
  registry.enable_help_conventions( true );

  let test_cmd = create_test_command( "help_conv_test", "Help conventions test" );
  registry.register_dynamic_command( test_cmd );

  // Should be able to get help for the command
  let help_content = registry.get_help_for_command( ".help_conv_test" );
  assert!( help_content.is_some(), "Should generate help for registered command" );

  let help_text = help_content.unwrap();
  assert!( help_text.contains( "help_conv_test" ), "Help should mention command name" );
}

#[ test ]
fn test_registry_builder_integration()
{
  // Test that CommandRegistryBuilder works with static commands
  let registry = CommandRegistryBuilder ::new()
  .with_static_commands()
  .command( create_test_command( "builder_test", "Builder test command" ) )
  .build();

  // Should find both static and builder-added commands
  let builder_cmd = registry.get( ".builder_test" );
  assert!( builder_cmd.is_some(), "Should find builder-added command" );

  let cmd = builder_cmd.unwrap();
  assert_eq!( cmd.name, "builder_test" );
  assert_eq!( cmd.description, "Builder test command" );
}

#[ test ]
fn test_existing_examples_compatibility()
{
  // Test that existing code patterns still work
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::new();

  // Old pattern should still work
  let old_style_cmd = create_test_command( "old_style", "Old style command" );
  registry.register_dynamic_command( old_style_cmd );

  let found = registry.get( ".old_style" );
  assert!( found.is_some(), "Old style registration should still work" );

  // New pattern should also work
  #[ allow(deprecated) ]
  let _new_registry = CommandRegistry ::from_static_commands();
  assert!( true, "New static command pattern should work" );
}

#[ test ]
fn test_registry_mode_switching()
{
  // Test switching between registry modes
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  // Should be able to switch registry modes
  registry.set_registry_mode( RegistryMode ::DynamicOnly );

  let dynamic_cmd = create_test_command( "mode_test", "Mode switching test" );
  registry.register_dynamic_command( dynamic_cmd );

  // In DynamicOnly mode, should find dynamic commands
  let found_dynamic = registry.get( ".mode_test" );
  assert!( found_dynamic.is_some(), "Should find dynamic command in DynamicOnly mode" );

  // Switch to StaticOnly mode
  registry.set_registry_mode( RegistryMode ::StaticOnly );

  // Dynamic command should not be found in StaticOnly mode
  let not_found_dynamic = registry.get( ".mode_test" );
  assert!( not_found_dynamic.is_none(), "Should not find dynamic command in StaticOnly mode" );
}

#[ test ]
fn test_registry_clear_dynamic_commands()
{
  // Test clearing dynamic commands while preserving static ones
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  let dynamic_cmd = create_test_command( "clear_test", "Clear test command" );
  registry.register_dynamic_command( dynamic_cmd );

  // Should find the dynamic command
  assert!( registry.get( ".clear_test" ).is_some(), "Should find dynamic command before clear" );

  // Clear dynamic commands
  registry.clear_dynamic_commands();

  // Dynamic command should be gone
  assert!( registry.get( ".clear_test" ).is_none(), "Should not find dynamic command after clear" );

  // Static commands should remain (if any)
  let _static_count_after = registry.static_command_count();
  // Static command count is always non-negative for usize
  assert!( true, "Static commands should remain after clearing dynamic" );
}

#[ test ]
fn test_command_resolution_priority_consistency()
{
  // Test that command resolution priority is consistent across multiple lookups
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  // Add a dynamic command that might conflict
  let dynamic_cmd = create_test_command( "help", "Dynamic help" );
  registry.register_dynamic_command( dynamic_cmd );

  // Multiple lookups should be consistent
  let first_lookup = registry.get( ".help" );
  let second_lookup = registry.get( ".help" );
  let third_lookup = registry.get( ".help" );

  // All lookups should return the same result
  assert_eq!( first_lookup.is_some(), second_lookup.is_some() );
  assert_eq!( second_lookup.is_some(), third_lookup.is_some() );

  if let ( Some( first ), Some( second ), Some( third ) ) = ( first_lookup, second_lookup, third_lookup )
  {
  assert_eq!( first.name, second.name );
  assert_eq!( second.name, third.name );
  assert_eq!( first.description, second.description );
  assert_eq!( second.description, third.description );
 }
}

#[ test ]
fn test_namespace_command_integration()
{
  // Test that namespaced commands work correctly in integrated registry
  #[ allow(deprecated) ]
  let mut registry = CommandRegistry ::from_static_commands();

  // Register a namespaced command
  let namespaced_cmd = CommandDefinition
  {
  name: "status".to_string(),
  namespace: "system".to_string(),
  description: "System status command".to_string(),
  routine_link: None,
  auto_help_enabled: false,
  hint: String ::new(),
  status: "stable".to_string(),
  version: "1.0.0".to_string(),
  tags: Vec ::new(),
  aliases: Vec ::new(),
  permissions: Vec ::new(),
  idempotent: false,
  deprecation_message: String ::new(),
  http_method_hint: "GET".to_string(),
  examples: Vec ::new(),
  arguments: Vec ::new(),
 };

  registry.register_dynamic_command( namespaced_cmd );

  // Should be able to find namespaced command
  let found_namespaced = registry.get( "system.status" );
  assert!( found_namespaced.is_some(), "Should find namespaced command" );

  let cmd = found_namespaced.unwrap();
  assert_eq!( cmd.name, "status" );
  assert_eq!( cmd.namespace, "system" );
}

#[ test ]
fn test_registry_thread_safety()
{
  // Test that registry operations are thread-safe
  use std ::sync :: { Arc, Mutex };
  use std ::thread;

  #[ allow(deprecated) ]
  let registry = Arc ::new( Mutex ::new( CommandRegistry ::from_static_commands() ) );
  let mut handles = vec![];

  // Spawn multiple threads to access registry
  for i in 0..5
  {
  let registry_clone = registry.clone();
  let handle = thread ::spawn( move ||
  {
   let reg = registry_clone.lock().unwrap();
   // Perform some operations
   let _ = reg.get( ".help" );
   let _ = reg.list_commands();
   i // return thread id for verification
 } );
  handles.push( handle );
 }

  // Wait for all threads to complete
  for handle in handles
  {
  let thread_result = handle.join();
  assert!( thread_result.is_ok(), "Thread should complete successfully" );
 }
}