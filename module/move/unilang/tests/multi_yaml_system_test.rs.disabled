//!
//! Tests for multi-YAML aggregation system.
//!
//! This module tests the multi-YAML aggregation system that discovers and processes
//! multiple YAML command definition files for compile-time CLI aggregation.
//!

use unilang::{ MultiYamlAggregator, AggregationConfig, ConflictResolutionMode, YamlCommandSource, CommandDefinition };
use std::path::Path;

/// Helper function to create a basic YAML command source for testing
fn create_test_yaml_source( path: &str, content: &str ) -> YamlCommandSource
{
  YamlCommandSource
  {
    file_path: path.to_string(),
    yaml_content: content.to_string(),
    module_name: Path::new( path ).file_stem().unwrap().to_str().unwrap().to_string(),
    priority: 100,
  }
}

/// Helper function to create test aggregation config
fn create_test_config() -> AggregationConfig
{
  AggregationConfig
  {
    discovery_paths: vec![ "tests/fixtures/yaml".to_string(), "examples/yaml".to_string() ],
    conflict_resolution: ConflictResolutionMode::PrefixWithModuleName,
    output_module_name: "aggregated_commands".to_string(),
    enable_static_generation: true,
    enable_dynamic_fallback: true,
    performance_mode: true,
  }
}

#[ test ]
fn test_multi_yaml_aggregator_creation()
{
  // Test creating MultiYamlAggregator with basic configuration
  let config = create_test_config();
  let aggregator = MultiYamlAggregator::new( config );

  // Should successfully create aggregator
  assert!( true, "MultiYamlAggregator::new() should succeed" );
}

#[ test ]
fn test_yaml_file_discovery()
{
  // Test YAML file discovery across multiple directories
  let config = create_test_config();
  let aggregator = MultiYamlAggregator::new( config );

  // Discover YAML files in specified paths
  let discovered_files = aggregator.discover_yaml_files();

  // Should return list of discovered files
  assert!( discovered_files.len() >= 0, "Should discover YAML files or return empty list" );

  // Each discovered file should have valid path
  for file in discovered_files
  {
    assert!( !file.file_path.is_empty(), "Discovered file should have non-empty path" );
    assert!( file.file_path.ends_with( ".yaml" ) || file.file_path.ends_with( ".yml" ), "Should discover only YAML files" );
  }
}

#[ test ]
fn test_yaml_content_parsing()
{
  // Test parsing YAML content into command definitions
  let yaml_content = r#"
commands:
  - name: "test_command"
    description: "Test command from YAML"
    namespace: "test"
    arguments:
      - name: "input"
        type: "String"
        required: true
  - name: "another_command"
    description: "Another test command"
    namespace: "test"
"#;

  let source = create_test_yaml_source( "test_commands.yaml", yaml_content );
  let config = create_test_config();
  let aggregator = MultiYamlAggregator::new( config );

  // Parse YAML source into command definitions
  let commands = aggregator.parse_yaml_source( &source );

  // Should successfully parse commands
  assert!( commands.is_ok(), "Should successfully parse valid YAML content" );

  let parsed_commands = commands.unwrap();
  assert_eq!( parsed_commands.len(), 2, "Should parse 2 commands from YAML" );

  // Verify first command
  let first_cmd = &parsed_commands[ 0 ];
  assert_eq!( first_cmd.name, "test_command" );
  assert_eq!( first_cmd.description, "Test command from YAML" );
  assert_eq!( first_cmd.namespace, "test" );
  assert_eq!( first_cmd.arguments.len(), 1 );

  // Verify second command
  let second_cmd = &parsed_commands[ 1 ];
  assert_eq!( second_cmd.name, "another_command" );
  assert_eq!( second_cmd.description, "Another test command" );
  assert_eq!( second_cmd.namespace, "test" );
}

#[ test ]
fn test_yaml_parsing_error_handling()
{
  // Test error handling for invalid YAML content
  let invalid_yaml = "invalid: yaml: content: [unclosed";

  let source = create_test_yaml_source( "invalid.yaml", invalid_yaml );
  let config = create_test_config();
  let aggregator = MultiYamlAggregator::new( config );

  // Should handle parsing errors gracefully
  let result = aggregator.parse_yaml_source( &source );
  assert!( result.is_err(), "Should return error for invalid YAML" );
}

#[ test ]
fn test_command_conflict_detection()
{
  // Test detection of conflicting commands across YAML files
  let config = create_test_config();
  let mut aggregator = MultiYamlAggregator::new( config );

  // Add commands with same name from different sources
  let yaml1 = r#"
commands:
  - name: "shared_command"
    description: "Command from module1"
    namespace: ""
"#;
  let yaml2 = r#"
commands:
  - name: "shared_command"
    description: "Command from module2"
    namespace: ""
"#;

  let source1 = create_test_yaml_source( "module1.yaml", yaml1 );
  let source2 = create_test_yaml_source( "module2.yaml", yaml2 );

  aggregator.add_yaml_source( source1 );
  aggregator.add_yaml_source( source2 );

  // Should detect conflicts
  let conflicts = aggregator.detect_conflicts();
  assert!( conflicts.len() > 0, "Should detect command name conflicts" );

  let conflict = &conflicts[ 0 ];
  assert_eq!( conflict.command_name, "shared_command" );
  assert_eq!( conflict.conflicting_modules.len(), 2 );
  assert!( conflict.conflicting_modules.contains( &"module1".to_string() ) );
  assert!( conflict.conflicting_modules.contains( &"module2".to_string() ) );
}

#[ test ]
fn test_conflict_resolution_prefix_mode()
{
  // Test conflict resolution using prefix with module name
  let mut config = create_test_config();
  config.conflict_resolution = ConflictResolutionMode::PrefixWithModuleName;
  let mut aggregator = MultiYamlAggregator::new( config );

  // Add conflicting commands
  let yaml1 = r#"
commands:
  - name: "shared_command"
    description: "Command from module1"
"#;
  let yaml2 = r#"
commands:
  - name: "shared_command"
    description: "Command from module2"
"#;

  let source1 = create_test_yaml_source( "module1.yaml", yaml1 );
  let source2 = create_test_yaml_source( "module2.yaml", yaml2 );

  aggregator.add_yaml_source( source1 );
  aggregator.add_yaml_source( source2 );

  // Resolve conflicts
  let resolved_commands = aggregator.resolve_conflicts();

  // Should have prefixed command names
  let command_names: Vec< String > = resolved_commands.iter().map( | cmd | cmd.name.clone() ).collect();
  assert!( command_names.contains( &"module1_shared_command".to_string() ), "Should prefix with module1" );
  assert!( command_names.contains( &"module2_shared_command".to_string() ), "Should prefix with module2" );
}

#[ test ]
fn test_conflict_resolution_priority_mode()
{
  // Test conflict resolution using priority-based selection
  let mut config = create_test_config();
  config.conflict_resolution = ConflictResolutionMode::HighestPriority;
  let mut aggregator = MultiYamlAggregator::new( config );

  // Add conflicting commands with different priorities
  let yaml_high = r#"
commands:
  - name: "priority_command"
    description: "High priority command"
"#;
  let yaml_low = r#"
commands:
  - name: "priority_command"
    description: "Low priority command"
"#;

  let mut source_high = create_test_yaml_source( "high_priority.yaml", yaml_high );
  source_high.priority = 200;

  let mut source_low = create_test_yaml_source( "low_priority.yaml", yaml_low );
  source_low.priority = 50;

  aggregator.add_yaml_source( source_high );
  aggregator.add_yaml_source( source_low );

  // Resolve conflicts
  let resolved_commands = aggregator.resolve_conflicts();

  // Should keep only the high priority command
  let priority_commands: Vec< &CommandDefinition > = resolved_commands
    .iter()
    .filter( | cmd | cmd.name == "priority_command" )
    .collect();

  assert_eq!( priority_commands.len(), 1, "Should have only one priority_command after resolution" );
  assert_eq!( priority_commands[ 0 ].description, "High priority command" );
}

#[ test ]
fn test_aggregation_config_validation()
{
  // Test validation of aggregation configuration
  let mut config = AggregationConfig
  {
    discovery_paths: vec![],
    conflict_resolution: ConflictResolutionMode::PrefixWithModuleName,
    output_module_name: String::new(),
    enable_static_generation: true,
    enable_dynamic_fallback: false,
    performance_mode: true,
  };

  // Should detect invalid configuration
  let result = MultiYamlAggregator::validate_config( &config );
  assert!( result.is_err(), "Should reject config with empty discovery paths and output module name" );

  // Fix configuration
  config.discovery_paths = vec![ "valid/path".to_string() ];
  config.output_module_name = "valid_module".to_string();

  let result = MultiYamlAggregator::validate_config( &config );
  assert!( result.is_ok(), "Should accept valid configuration" );
}

#[ test ]
fn test_phf_map_generation()
{
  // Test generation of PHF map code for build.rs integration
  let config = create_test_config();
  let mut aggregator = MultiYamlAggregator::new( config );

  // Add test commands
  let yaml_content = r#"
commands:
  - name: "generate_test"
    description: "Test command for PHF generation"
    namespace: "test"
"#;

  let source = create_test_yaml_source( "generate_test.yaml", yaml_content );
  aggregator.add_yaml_source( source );

  let resolved_commands = aggregator.resolve_conflicts();

  // Generate PHF map code
  let phf_code = aggregator.generate_phf_map_code( &resolved_commands );

  // Should generate valid Rust code
  assert!( phf_code.contains( "static COMMAND_MAP" ), "Should generate static COMMAND_MAP" );
  assert!( phf_code.contains( "phf::Map" ), "Should use phf::Map" );
  assert!( phf_code.contains( "generate_test" ), "Should include test command name" );
  assert!( phf_code.contains( "Test command for PHF generation" ), "Should include command description" );
}

#[ test ]
fn test_build_rs_integration()
{
  // Test build.rs integration for compile-time aggregation
  let config = create_test_config();
  let aggregator = MultiYamlAggregator::new( config );

  // Should be able to generate build script code
  let build_code = aggregator.generate_build_script_code();

  // Should contain necessary build script elements
  assert!( build_code.contains( "fn main()" ), "Should generate main function for build.rs" );
  assert!( build_code.contains( "discover_yaml_files" ), "Should include YAML discovery" );
  assert!( build_code.contains( "generate_phf_map" ), "Should include PHF generation" );
  assert!( build_code.contains( "OUT_DIR" ), "Should use OUT_DIR for output" );
}

#[ test ]
fn test_module_name_extraction()
{
  // Test extraction of module names from file paths
  let aggregator = MultiYamlAggregator::new( create_test_config() );

  // Test various file path patterns
  let test_cases = vec![
    ( "commands.yaml", "commands" ),
    ( "module/user_commands.yaml", "user_commands" ),
    ( "/full/path/to/system_commands.yml", "system_commands" ),
    ( "nested/deep/path/admin.yaml", "admin" ),
  ];

  for ( file_path, expected_module ) in test_cases
  {
    let module_name = aggregator.extract_module_name( file_path );
    assert_eq!( module_name, expected_module, "Should extract correct module name from {}", file_path );
  }
}

#[ test ]
fn test_yaml_source_priority_ordering()
{
  // Test ordering of YAML sources by priority
  let config = create_test_config();
  let mut aggregator = MultiYamlAggregator::new( config );

  // Add sources with different priorities
  let mut source1 = create_test_yaml_source( "low.yaml", "commands: []" );
  source1.priority = 50;

  let mut source2 = create_test_yaml_source( "high.yaml", "commands: []" );
  source2.priority = 200;

  let mut source3 = create_test_yaml_source( "medium.yaml", "commands: []" );
  source3.priority = 100;

  aggregator.add_yaml_source( source1 );
  aggregator.add_yaml_source( source2 );
  aggregator.add_yaml_source( source3 );

  // Get sources ordered by priority
  let ordered_sources = aggregator.get_sources_by_priority();

  // Should be ordered from highest to lowest priority
  assert_eq!( ordered_sources[ 0 ].priority, 200 );
  assert_eq!( ordered_sources[ 1 ].priority, 100 );
  assert_eq!( ordered_sources[ 2 ].priority, 50 );

  assert_eq!( ordered_sources[ 0 ].module_name, "high" );
  assert_eq!( ordered_sources[ 1 ].module_name, "medium" );
  assert_eq!( ordered_sources[ 2 ].module_name, "low" );
}

#[ test ]
fn test_aggregated_command_count()
{
  // Test counting total aggregated commands
  let config = create_test_config();
  let mut aggregator = MultiYamlAggregator::new( config );

  // Add multiple sources with commands
  let yaml1 = r#"
commands:
  - name: "cmd1"
    description: "Command 1"
  - name: "cmd2"
    description: "Command 2"
"#;
  let yaml2 = r#"
commands:
  - name: "cmd3"
    description: "Command 3"
"#;

  let source1 = create_test_yaml_source( "module1.yaml", yaml1 );
  let source2 = create_test_yaml_source( "module2.yaml", yaml2 );

  aggregator.add_yaml_source( source1 );
  aggregator.add_yaml_source( source2 );

  let resolved_commands = aggregator.resolve_conflicts();

  // Should count all commands correctly
  assert_eq!( resolved_commands.len(), 3, "Should have 3 total commands" );
  assert_eq!( aggregator.total_command_count(), 3, "Should report correct total count" );
}

#[ test ]
fn test_namespace_preservation()
{
  // Test that command namespaces are preserved during aggregation
  let config = create_test_config();
  let mut aggregator = MultiYamlAggregator::new( config );

  let yaml_content = r#"
commands:
  - name: "status"
    description: "System status"
    namespace: "system"
  - name: "info"
    description: "User info"
    namespace: "user"
  - name: "global"
    description: "Global command"
    namespace: ""
"#;

  let source = create_test_yaml_source( "namespaced.yaml", yaml_content );
  aggregator.add_yaml_source( source );

  let resolved_commands = aggregator.resolve_conflicts();

  // Find commands and verify namespaces
  let system_cmd = resolved_commands.iter().find( | cmd | cmd.name == "status" );
  let user_cmd = resolved_commands.iter().find( | cmd | cmd.name == "info" );
  let global_cmd = resolved_commands.iter().find( | cmd | cmd.name == "global" );

  assert!( system_cmd.is_some(), "Should find system command" );
  assert_eq!( system_cmd.unwrap().namespace, "system" );

  assert!( user_cmd.is_some(), "Should find user command" );
  assert_eq!( user_cmd.unwrap().namespace, "user" );

  assert!( global_cmd.is_some(), "Should find global command" );
  assert_eq!( global_cmd.unwrap().namespace, "" );
}

#[ test ]
fn test_performance_mode_optimization()
{
  // Test performance mode optimizations
  let mut config = create_test_config();
  config.performance_mode = true;

  let aggregator = MultiYamlAggregator::new( config );

  // Performance mode should enable optimizations
  assert!( aggregator.is_performance_mode_enabled(), "Performance mode should be enabled" );

  // Should generate optimized PHF maps
  let phf_code = aggregator.generate_optimized_phf_code( &[] );
  assert!( phf_code.contains( "const " ), "Should generate const PHF maps in performance mode" );
}

#[ test ]
fn test_dynamic_fallback_integration()
{
  // Test integration with dynamic command fallback
  let mut config = create_test_config();
  config.enable_dynamic_fallback = true;

  let aggregator = MultiYamlAggregator::new( config );

  // Should generate code that supports dynamic fallback
  let integration_code = aggregator.generate_dynamic_fallback_code();
  assert!( integration_code.contains( "dynamic_registry" ), "Should include dynamic registry integration" );
  assert!( integration_code.contains( "fallback" ), "Should include fallback mechanism" );
}

#[ test ]
fn test_command_validation()
{
  // Test validation of command definitions during aggregation
  let config = create_test_config();
  let mut aggregator = MultiYamlAggregator::new( config );

  // Add YAML with invalid command definition
  let invalid_yaml = r#"
commands:
  - name: ""
    description: "Invalid command with empty name"
  - name: "valid_command"
    description: ""
"#;

  let source = create_test_yaml_source( "invalid.yaml", invalid_yaml );
  let result = aggregator.validate_and_add_source( source );

  // Should detect validation errors
  assert!( result.is_err(), "Should reject YAML with invalid command definitions" );

  let error = result.unwrap_err();
  assert!( error.to_string().contains( "empty name" ) || error.to_string().contains( "invalid" ), "Should provide meaningful error message" );
}

#[ test ]
fn test_output_module_generation()
{
  // Test generation of output module with aggregated commands
  let config = create_test_config();
  let mut aggregator = MultiYamlAggregator::new( config );

  let yaml_content = r#"
commands:
  - name: "test_output"
    description: "Test command for output generation"
"#;

  let source = create_test_yaml_source( "output_test.yaml", yaml_content );
  aggregator.add_yaml_source( source );

  let resolved_commands = aggregator.resolve_conflicts();

  // Generate complete output module
  let module_code = aggregator.generate_output_module( &resolved_commands );

  // Should generate complete Rust module
  assert!( module_code.contains( "pub mod aggregated_commands" ), "Should generate named module" );
  assert!( module_code.contains( "pub static COMMANDS" ), "Should include command map" );
  assert!( module_code.contains( "test_output" ), "Should include command definitions" );
  assert!( module_code.contains( "use phf" ), "Should import PHF" );
}