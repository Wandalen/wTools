//!
//! Tests for CommandRegistry hybrid command lookup functionality.
//!
//! This module tests the `CommandRegistry` type that provides hybrid command lookup
//! with both static PHF-based commands and dynamic runtime commands.
//!

use unilang ::prelude :: *;
#[cfg(feature = "advanced_cli_tests")]
use std ::time ::Instant;

/// Helper function to create a test CommandDefinition with minimal boilerplate
#[cfg(feature = "advanced_cli_tests")]
fn create_test_command( name: &str, description: &str ) -> CommandDefinition
{
  CommandDefinition
  {
  name: name.to_string(),
  namespace: String ::new(),
  description: description.to_string(),
  routine_link: None,
  auto_help_enabled: false,
  hint: String ::new(),
  status: "stable".to_string(),
  version: "1.0.0".to_string(),
  tags: Vec ::new(),
  aliases: Vec ::new(),
  permissions: Vec ::new(),
  idempotent: false,
  deprecation_message: String ::new(),
  http_method_hint: "GET".to_string(),
  examples: Vec ::new(),
  arguments: Vec ::new(),
 }
}

/// Helper function to create a test CommandDefinition with aliases
#[cfg(feature = "advanced_cli_tests")]
fn create_test_command_with_aliases( name: &str, description: &str, aliases: Vec< String > ) -> CommandDefinition
{
  CommandDefinition
  {
  name: name.to_string(),
  namespace: String ::new(),
  description: description.to_string(),
  routine_link: None,
  auto_help_enabled: false,
  hint: String ::new(),
  status: "stable".to_string(),
  version: "1.0.0".to_string(),
  tags: Vec ::new(),
  aliases,
  permissions: Vec ::new(),
  idempotent: false,
  deprecation_message: String ::new(),
  http_method_hint: "GET".to_string(),
  examples: Vec ::new(),
  arguments: Vec ::new(),
 }
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_static_command_registry_creation()
{
  // Test basic creation of CommandRegistry
  let _registry = CommandRegistry ::new();

  // Should be able to create without errors
  assert!( true, "CommandRegistry creation should succeed" );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_static_command_registry_from_phf()
{
  // Test creating registry from PHF map
  let registry = CommandRegistry ::from_static_commands();

  // Should initialize with static commands from generated PHF map
  let _command_count = registry.static_command_count();
  // Command count is always non-negative for usize
  assert!( true, "Should have non-negative command count" );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_hybrid_lookup_static_first()
{
  // Test that static commands take priority over dynamic commands with same name
  let mut registry = CommandRegistry ::from_static_commands();

  // Create a dynamic command with same name as a static one
  let dynamic_cmd = create_test_command( "help", "Dynamic help command" );

  registry.register_dynamic_command( dynamic_cmd );

  // Lookup should return static version, not dynamic
  let found_cmd = registry.get_command( ".help" );
  if let Some( cmd ) = found_cmd
  {
  // Static commands should have different characteristics
  assert!( cmd.description.contains( "help" ), "Should find help command" );
 }
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_dynamic_fallback_lookup()
{
  // Test that dynamic commands are found when no static command exists
  let mut registry = CommandRegistry ::new();

  let dynamic_cmd = create_test_command( "dynamic_test", "Dynamic test command" );

  registry.register_dynamic_command( dynamic_cmd );

  let found_cmd = registry.get_command( ".dynamic_test" );
  assert!( found_cmd.is_some(), "Should find dynamic command" );

  let cmd = found_cmd.unwrap();
  assert_eq!( cmd.name, "dynamic_test" );
  assert_eq!( cmd.description, "Dynamic test command" );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_static_command_enumeration()
{
  // Test ability to enumerate static commands
  let registry = CommandRegistry ::from_static_commands();

  let static_commands = registry.list_static_commands();
  // Length is always non-negative for Vec
  assert!( true, "Should return command list" );

  // Check that commands have expected structure
  for cmd in static_commands
  {
  assert!( !cmd.name.is_empty(), "Command name should not be empty" );
  assert!( !cmd.description.is_empty(), "Command description should not be empty" );
 }
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_dynamic_command_enumeration()
{
  // Test ability to enumerate dynamic commands
  let mut registry = CommandRegistry ::new();

  let cmd1 = create_test_command( "dyn1", "Dynamic command 1" );
  let cmd2 = create_test_command( "dyn2", "Dynamic command 2" );

  registry.register_dynamic_command( cmd1 );
  registry.register_dynamic_command( cmd2 );

  let dynamic_commands = registry.list_dynamic_commands();
  assert_eq!( dynamic_commands.len(), 2 );

  let names: Vec< String > = dynamic_commands.iter().map( | cmd | cmd.name.clone() ).collect();
  assert!( names.contains( &"dyn1".to_string() ) );
  assert!( names.contains( &"dyn2".to_string() ) );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_command_exists_check()
{
  // Test command existence checking
  let mut registry = CommandRegistry ::from_static_commands();

  // Add a dynamic command
  let dynamic_cmd = create_test_command( "test_exists", "Test existence command" );

  registry.register_dynamic_command( dynamic_cmd );

  // Should find both static and dynamic commands
  assert!( registry.has_command( ".test_exists" ), "Should find dynamic command" );

  // Should not find non-existent commands
  assert!( !registry.has_command( ".nonexistent" ), "Should not find non-existent command" );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_command_lookup_performance_bounds()
{
  // Test that command lookup meets performance requirements (<1ms p99 latency)
  // Note: This is a correctness test, not a performance benchmark
  let registry = CommandRegistry ::from_static_commands();

  // Perform multiple lookups to warm up any caches
  for _ in 0..100
  {
  let _ = registry.get_command( ".help" );
 }

  // Measure a batch of lookups (this is for correctness, not benchmarking)
  let start = Instant ::now();
  for _ in 0..1000
  {
  let _ = registry.get_command( ".help" );
 }
  let elapsed = start.elapsed();

  // Each lookup should be very fast (this is a sanity check, not precise benchmarking)
  let per_lookup = elapsed.as_nanos() as f64 / 1000.0;
  assert!( per_lookup < 1_000_000.0, "Lookup should be under 1ms on average (got {:.2}ns)", per_lookup );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_registry_mode_configuration()
{
  // Test different registry operation modes
  let static_only = CommandRegistry ::with_mode( RegistryMode ::StaticOnly );
  let dynamic_only = CommandRegistry ::with_mode( RegistryMode ::DynamicOnly );
  let hybrid = CommandRegistry ::with_mode( RegistryMode ::Hybrid );

  assert_eq!( static_only.mode(), RegistryMode ::StaticOnly );
  assert_eq!( dynamic_only.mode(), RegistryMode ::DynamicOnly );
  assert_eq!( hybrid.mode(), RegistryMode ::Hybrid );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_static_only_mode_behavior()
{
  // Test that StaticOnly mode ignores dynamic commands
  let mut registry = CommandRegistry ::with_mode( RegistryMode ::StaticOnly );

  let dynamic_cmd = create_test_command( "dynamic_ignored", "Should be ignored" );

  registry.register_dynamic_command( dynamic_cmd );

  // Dynamic command should be ignored in StaticOnly mode
  let found = registry.get_command( ".dynamic_ignored" );
  assert!( found.is_none(), "Dynamic commands should be ignored in StaticOnly mode" );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_dynamic_only_mode_behavior()
{
  // Test that DynamicOnly mode ignores static commands
  let mut registry = CommandRegistry ::with_mode( RegistryMode ::DynamicOnly );

  // Even if static commands exist, they should be ignored
  let found_static = registry.get_command( ".help" );
  assert!( found_static.is_none(), "Static commands should be ignored in DynamicOnly mode" );

  // But dynamic commands should work
  let dynamic_cmd = create_test_command( "dynamic_only", "Dynamic command" );

  registry.register_dynamic_command( dynamic_cmd );

  let found_dynamic = registry.get_command( ".dynamic_only" );
  assert!( found_dynamic.is_some(), "Dynamic commands should work in DynamicOnly mode" );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_registry_metrics_tracking()
{
  // Test that registry can provide metrics structure
  let registry = CommandRegistry ::from_static_commands();

  // Get metrics (should start at zero since get_command doesn't update metrics with &self)
  let metrics = registry.performance_metrics();

  // Verify metrics structure exists and is accessible
  let _total = metrics.total_lookups; // Should access without error
  let _static = metrics.static_lookups; // Should access without error
  let _dynamic = metrics.dynamic_lookups; // Should access without error
  assert!( true, "Should have accessible metrics structure" );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_command_registration_integration()
{
  // Test integration with existing CommandRegistry API surface
  let mut registry = CommandRegistry ::new();

  // Should support existing registration patterns
  let cmd = CommandDefinition
  {
  name: "integration_test".to_string(),
  namespace: String ::new(),
  description: "Integration test command".to_string(),
  routine_link: None,
  auto_help_enabled: false,
  hint: "integration".to_string(),
  status: "stable".to_string(),
  version: "1.0.0".to_string(),
  tags: Vec ::new(),
  aliases: Vec ::new(),
  permissions: Vec ::new(),
  idempotent: false,
  deprecation_message: String ::new(),
  http_method_hint: "GET".to_string(),
  examples: Vec ::new(),
  arguments: Vec ::new(),
 };

  registry.register_dynamic_command( cmd );

  // Should work with existing lookup patterns
  let found = registry.get_command( ".integration_test" );
  assert!( found.is_some() );

  let command = found.unwrap();
  assert_eq!( command.name, "integration_test" );
  assert_eq!( command.hint, "integration" );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_namespace_command_lookup()
{
  // Test lookup of namespaced commands
  let registry = CommandRegistry ::from_static_commands();

  // Should handle both global and namespaced commands
  let global_cmd = registry.get_command( ".help" );
  let namespaced_cmd = registry.get_command( "system.status" );

  // At least one should exist (depending on static commands available)
  assert!(
  global_cmd.is_some() || namespaced_cmd.is_some(),
  "Should find at least some commands"
 );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_command_priority_consistency()
{
  // Test that static command priority is consistent
  let mut registry = CommandRegistry ::from_static_commands();

  // Add dynamic command that might conflict
  let dynamic_cmd = create_test_command( "help", "Dynamic help override" );

  registry.register_dynamic_command( dynamic_cmd );

  // Multiple lookups should return the same command (static takes priority)
  let first_lookup = registry.get_command( ".help" );
  let second_lookup = registry.get_command( ".help" );

  assert_eq!( first_lookup.is_some(), second_lookup.is_some() );
  if let ( Some( first ), Some( second ) ) = ( first_lookup, second_lookup )
  {
  assert_eq!( first.name, second.name );
  assert_eq!( first.description, second.description );
 }
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_command_routine_registration()
{
  // Test registration of command routines
  let mut registry = CommandRegistry ::new();

  // Should support routine registration
  let cmd = create_test_command( "routine_test", "Routine test command" );

  registry.register_dynamic_command( cmd );

  // Register a routine for the command
  let routine = | _verified_cmd, _context | -> Result< OutputData, ErrorData >
  {
  Ok( OutputData { content: "Test output".to_string(), format: "text".to_string() } )
 };

  registry.register_routine( ".routine_test", Box ::new( routine ) );

  // Should be able to get the command and execute it
  let found_cmd = registry.get_command( ".routine_test" );
  assert!( found_cmd.is_some() );

  let has_routine = registry.has_routine( ".routine_test" );
  assert!( has_routine, "Should have registered routine" );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_registry_clear_and_reset()
{
  // Test clearing dynamic commands while preserving static ones
  let mut registry = CommandRegistry ::from_static_commands();

  let dynamic_cmd = create_test_command( "temporary", "Temporary command" );

  registry.register_dynamic_command( dynamic_cmd );

  // Should find the dynamic command
  assert!( registry.has_command( ".temporary" ) );

  // Clear dynamic commands
  registry.clear_dynamic_commands();

  // Dynamic command should be gone
  assert!( !registry.has_command( ".temporary" ) );

  // But static commands should remain
  let static_count_before = registry.static_command_count();
  let static_count_after = registry.static_command_count();
  assert_eq!( static_count_before, static_count_after );
}

#[cfg(feature = "advanced_cli_tests")]
#[ test ]
fn test_command_aliasing_support()
{
  // Test that command aliases work correctly
  let mut registry = CommandRegistry ::new();

  let cmd_with_aliases = create_test_command_with_aliases(
  "aliased_command",
  "Command with aliases",
  vec![ "alias1".to_string(), "alias2".to_string() ]
 );

  registry.register_dynamic_command( cmd_with_aliases );

  // Should find command by primary name
  assert!( registry.has_command( ".aliased_command" ) );

  // Should find command by aliases
  assert!( registry.has_command( "alias1" ) );
  assert!( registry.has_command( "alias2" ) );

  // All lookups should return the same command
  let by_name = registry.get_command( ".aliased_command" );
  let by_alias1 = registry.get_command( "alias1" );
  let by_alias2 = registry.get_command( "alias2" );

  assert!( by_name.is_some() && by_alias1.is_some() && by_alias2.is_some() );
}