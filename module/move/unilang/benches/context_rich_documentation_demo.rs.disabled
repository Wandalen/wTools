//! Context-rich benchmark documentation demonstration
//!
//! Shows how to generate comprehensive benchmark reports with:

#![ allow( clippy::uninlined_format_args ) ]
#![ allow( unused_imports ) ]
#![ allow( clippy::manual_contains ) ]
//! - Measurement specifications clearly stated before results
//! - Before/After optimization comparisons  
//! - Key findings and insights included with results
//! - Actionable recommendations provided
//! - Environment specifications documented

#[ cfg( feature = "benchmarks" ) ]
use unilang::{
  documentation_updater::{ DocumentationUpdater, Template },
  comparative_benchmark_structure::ComparativeBenchmark,
};

#[ cfg( feature = "benchmarks" ) ]
fn main()
{
  println!( "ðŸŽ¯ Generating Context-Rich Benchmark Documentation Demo" );

  // Create documentation updater
  let mut doc_updater = DocumentationUpdater::new( "target/benchmark_docs" );

  // Add custom template for benchmark reports
  add_benchmark_templates( &mut doc_updater );

  // Demo 1: Generate comparative benchmark documentation
  generate_comparative_benchmark_example( &mut doc_updater );

  // Demo 2: Generate optimization comparison documentation
  generate_optimization_comparison_example( &mut doc_updater );

  println!( "ðŸ“„ Context-rich documentation generated in: target/benchmark_docs/" );
}

#[ cfg( feature = "benchmarks" ) ]
fn add_benchmark_templates( doc_updater: &mut DocumentationUpdater )
{
  use std::collections::HashMap;

  // Add comparative benchmark template
  let mut variables = HashMap::new();
  variables.insert( "title".to_string(), "{{title}}".to_string() );
  variables.insert( "results".to_string(), "{{results}}".to_string() );
  variables.insert( "environment".to_string(), "{{environment}}".to_string() );

  let comparative_template = Template
  {
    content: r#"# {{title}}

## Environment
{{environment}}

## Results
{{results}}

Generated by unilang documentation updater.
"#.to_string(),
    format: "markdown".to_string(),
    variables,
  };

  doc_updater.add_template( "comparative_benchmark", comparative_template );
}

#[ cfg( feature = "benchmarks" ) ]
fn generate_comparative_benchmark_example( doc_updater: &mut DocumentationUpdater )
{
  use std::time::Instant;
  use std::collections::HashMap;

  println!( "ðŸ“Š Running comparative string processing benchmark..." );

  // Create realistic comparative benchmark
  let string_processing_comparison = ComparativeBenchmark::new(
    "String Processing Algorithms",
    "Performance comparison of string manipulation approaches in unilang CLI parsing"
  );

  // Test data
  let test_data = vec![
    "greet name::Alice".to_string(),
    "calculate x::10 y::20 operation::add".to_string(),
    "help command::status".to_string(),
    "validate input::sample.txt format::json".to_string(),
    "process data::large.csv output::results.txt".to_string(),
  ];

  // Algorithm 1: Standard string operations
  let string_processing_comparison = string_processing_comparison.add_algorithm( "standard_string_ops", move |data: &Vec<String>| {
    let start = Instant::now();
    for text in data {
      let _parts: Vec< &str > = text.split_whitespace().collect();
      let _uppercase = text.to_uppercase();
      let _length_check = text.len() > 10;
      let _contains_dot = text.contains( '.' );
    }
    start.elapsed()
  } );

  // Algorithm 2: Optimized string operations
  let string_processing_comparison = string_processing_comparison.add_algorithm( "optimized_string_ops", move |data: &Vec<String>| {
    let start = Instant::now();
    for text in data {
      if text.len() <= 10 { continue; }

      let _parts: Vec< &str > = text.split_whitespace().collect();

      if !text.contains( '.' ) { continue; }

      let _uppercase = text.to_uppercase();
    }
    start.elapsed()
  } );

  // Set baseline and run comparison
  let string_processing_comparison = string_processing_comparison.set_baseline( "standard_string_ops" );
  let results = string_processing_comparison.run_comparison( &test_data );

  // Generate documentation
  let mut template_vars = HashMap::new();
  template_vars.insert( "title".to_string(), "String Processing Algorithm Comparison".to_string() );
  template_vars.insert( "environment".to_string(), "Intel i7-9700K, 32GB RAM, Development Environment".to_string() );
  template_vars.insert( "results".to_string(), results.performance_summary() );

  let report = doc_updater.generate_report_with_template( "comparative_benchmark", template_vars )
    .unwrap_or_else( |_| "Failed to generate report".to_string() );

  println!( "Generated comparative benchmark documentation:\n{}", report );
}

#[ cfg( feature = "benchmarks" ) ]
fn generate_optimization_comparison_example( doc_updater: &mut DocumentationUpdater )
{
  use std::collections::HashMap;

  println!( "ðŸ”§ Generating before/after optimization comparison..." );

  // Simulate before/after optimization measurements
  let optimization_results = vec![
    ( "command_parsing", 2.4, 1.8, "25% improvement" ),
    ( "argument_validation", 0.85, 0.68, "20% improvement" ),
    ( "help_generation", 1.2, 1.25, "4% regression" ),
    ( "error_handling", 0.45, 0.32, "29% improvement" ),
  ];

  let mut results_table = String::new();
  results_table.push_str( "| Algorithm | Before (ms) | After (ms) | Change |\n" );
  results_table.push_str( "|-----------|-------------|------------|--------|\n" );

  for ( name, before, after, change ) in optimization_results {
    results_table.push_str( &format!( "| {} | {:.2} | {:.2} | {} |\n", name, before, after, change ) );
  }

  // Generate documentation using benchmark report
  let report = doc_updater.generate_benchmark_report(
    "CLI Processing Pipeline Optimization",
    &results_table,
    "Intel i7-9700K, 32GB RAM, Development Environment"
  );

  println!( "Generated optimization comparison documentation:\n{}", report );
}

#[ cfg( not( feature = "benchmarks" ) ) ]
fn main()
{
  eprintln!( "Error: Benchmarks not enabled!" );
  eprintln!( "Run with: cargo run --bin context_rich_documentation_demo --features benchmarks" );
  std::process::exit( 1 );
}